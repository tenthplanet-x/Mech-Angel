// --------------------美女保佑，永无Bug，不改需求，早点下班--------------------------------
// ...............8888:::8888888888888888888888888
// .............8888::::::8888888888888888888888888888
// ............88::::::::888:::8888888888888888888888888
// ..........88888888::::8:::::::::::88888888888888888888
// ........888.8::888888::::::::::::::::::88888888888...888
// ...........88::::88888888::::8::::::::::88888888888....8
// .........888888888888888888:8:::::::::::8888888888888
// ........88888888888888888888::::::::::::888888888888888
// ........8888888888888888888888:::::::::88888888888888888
// .........8888888888888888888888:::::::8888888888888888888
// ........8888888888888888::88888::::::888888888888888888888
// ......88888888888888888:::88888:::::8888888888888888...8888
// .....88888888888888888:::88888::::8::;o*8*o;888888888....88
// ....88888888888888888:::8888:::::8:::::::::::88888888....8
// ...88888888888888888::::88::::::8:;:::::::::::888888888
// ..8888888888888888888:::8::::::8::aAa::::::::88888888888.......8
// ..88...8888888888::88::::8::::8:::::::::::::888888888888888.8888
// .88..88888888888:::8:::::::::8::::::::::;::88:88888888888888888
// .8..8888888888888:::::::::::8::'@@@@@@@'::::8w8888888888888888
// ..88888888888:888::::::::::8:::::'@a@':::::88i888888888888888
// .8888888888::::88:::::::::888:::::::::::::888z88888888888888888
// 8888888888:::::8:::::::::888888:::::::::88888!888888888888888888
// 888888888:::::8:::::::::888888888A888A8V88888*88888888...88888888
// 888888.8:::::::::::::::8888888888:::::::8888888888888888...8888888
// 8888...8::::::::::::::888888888888::::::88888888888888888....88888
// .888...8:::::::::::::888888888888888:::::88888888888888888....8888
// ..888..8::::::::::::88888:888888888888::::8::8888888.888888...8888
// ...88..8::::::::::::8888:88888888888888888::::::888...88888...888
// ...88..8::::::::::88888::88888::888888888888:::::::8888888....88
// ...8...88::::::::88888:::8888:::::888888888888::::::::888.....4
// .......88:::::::88888:::::888:::::::88:::8888888::::::::88....2
// ......8888:::::88888:::::::88::::::::8:::::888888:::8:::::8
// .....88888:::::88888::::::::8:::::::::::8::::8888::::8::::8
// ....888888:::::88:8::::::::::8:::::::::::8:::8888::::::8::8
// ...88.88888:::888:8:::::::::::::::::::::::8:8888:::::::::8:
// ...8.888888:::88::8:::::::::::::::::::::::88:88::::::::::::8
// .....888888:::88::8::::::::::*88*::::::::::8:88::::::::::::::8
// ....8888888:::88::8:::::::::88@@88:::::::::8::88::::::::::::::8
// ....88888888::88::88::::::::88@@88:::::::::8:::8::::::::::::::*8
// ....88888..8:::8::88:::::::::*88*::::::::::8:::::::::::::::::88@@
// ....8888...88::::::88:::::::::::::::::::::88:::::::::::::::::88@@
// .....888....8:::::::88:::::::::::::::::::88::8::::::::::::::::*8
// .....888....88:::::::888::::::::::::::::88:::88:::::::::::::::8
// ......88.....8::::::::8888:::::::::::8888:::::88::::::::::::88
// .......88....88:::::::::888888888888888::::::::88:::::::::88
// ........88....88::::::::::::8888888::::::::::::::888888888
// .........88...888::::::::::::::::::::::::::::::::::888888
// ..........8...8888::::::::::::::::::::::8:::8::::::::88
// ..............88888::::::::::::::::::88::::::88::::::88
// .............8888888:::::::::::::::888:::::::88:::::88
// .............88888888:::::::::::::888:::::::::888:::8
// ............8888888888:::::::::::888:::::::::::88:::8
// ...........88.88888888:::::::::888::::::::::::::8:::8
// ...........8..888888.8:::::::88:::::::::::::::::8:::8:
// ..............888888.8::::::8:::::::::::::::::::8:::88
// .............888888..8:::::8::::::::::::::::::::::::8:8
// .............888888..8:::::8:::::::::@::::::::::::::8::8
// .............88888...8::::::::::::::@@:::::::::::::::8::8
// ............88888...8::::::::::::::@@@::::::::::::::::8::8
// ...........88888...8:::::::::::::::@@::::::::::::::::::8::8
// ..........88888...8:::::8::::::::::@::::::::::88:::::::8:::8
// ..........8888...8:::::8:::::::::::::::::::::::88:::::::8:::8
// .........8888...8:::::8:::::::::::::::::::::::888::::::::8:::8
// ........888....8:::::88::::::::::::::::::::::888:::::::::8::::8
// ......8888....88::::88:::::::::::::::::::::8888:::::::::8::8:::8
// .....888......8:::::8::::::::::::::::::::888::::::::::::8::88:::8
// ..8888.......88:::::::::::::::::::::::::88:::::::::::::88::88:::8:
// .............8:::::::::::::::::::::::::8:::::::::::::::88::88:::88
// ............88::::::8:::::::::::::::::::::::::::::::::::8::88:::88
// ............8::::::::8:::::::::::::::::::::::::::::::::::8::8:::88
// ...........88:::::::::8:::::::::::::8:::::::::::::::::::::8:8:::88
// ...........8:::::::::::888:::::::::8:::::::::::::::::::::::88::888
// ...........8::::::::::::88888888888::::::::::::::::::::::::88::88
// ...........8:::::::::::::888888888:::::::::::::::::::::::::8::88
// ...........8::::::::::::::8888888:::::::::::::::::::::::::8::88
// ...........8:::::::::::::::888888:::::::::::::::::::::::::8:88
// ...........8:::::::::::::::::888::::::::::::::::::::::::::888
// ...........8:::::::::::::::::::8::::::::::::::::::::::::::888
// ...........88:::::::::::::::::8::::::::::::::::::::::::::888
// ............8:::::::::::::::::8::::::::::::::::::::::::::888
// ............88:::::::::::::::8::::::::::::::::::::::::::888
// .............8:::::::::::::::8:::::::::::::::::::::::::888
// .............88:::::::::::::8:::::::::::::::::::::::::888
// ..............8:::::::::::::8::::::::::::::::::::::::888
// ..............88:::::::::::8::::::::::::::::::::::::888
// ...............8:::::::::::8:::::::::::::::::::::::888
// ...............88:::::::::8:::::::::::::::::::::::888
// ................8:::::::::8::::::::::::::::::::::888
// ................88:::::::8::::::::::::::::::::::888
// .................88::::::8:::::::::::::::::::::888
// .................88:::::8:::::::::::::::::::::888
// ..................88::::8::::::::::::::::::::888
// ..................88:::8::::::::::::::::::::888
// ...................88::8:::::::::::::::::::888
// ...................88:8:::::::::::::::::::888
// ....................888::::::::::::::::::888
// ....................88::::::::::::::::::888
// .....................8:::::::::::::::::888
// ....................88::::::::::::::::888
// ....................88:::::::::::::::888
// ....................88::::8:::::::::888:
// ....................888::::88:::::::8888
// .....................888:::::::::::888:8
// .....................888:::8:::::::8:8:8
// ......................88::8888:::::::8:8
// ......................88::888::::::::8:8
// ......................888::88::::::::8:8
// .......................88::88:::::::::8:8
// .......................88::88::::::::::8:8
// .......................88:::8:::::::::::88
// .......................888:::::::::::::::8:
// .......................888:::::::::::::::8:
// .......................888::::::::::::::::8
// .......................888::::::::::::::::8
// .......................888::::::::::::::::88
// ........................88::::::::::::::::88
// ........................888:::::::::::::::88
// ........................888:::::::::::::::88
// ........................888:::::::::::::::88
// ........................888:::::::::::::::88
// .........................88::::::::::::::888
// .........................888:::::::::::::88
// .........................888:::::::::::::88
// .........................888::::::::::::88
// ..........................88::::::::::::88
// ..........................88::::::::::::88
// ..........................88:::::::::::88
// ..........................888::::::::::88
// ..........................888::::::::::88
// ...........................88:::::::::88
// ...........................888::::::::88
// ...........................888::::::::88
// ............................88::::::::88
// ............................888::::::88
// ............................888::::::88
// ..............................88:::::88:
// ..............................88:::::8:8
// ..............................88:::::8:8
// ..............................:8::::::8:
// .............................8:8:::::::8
// ............................8:::8::::::8
// ...........................8::::8::::::8
// ..........................8:::::8:::::::8
// .........................8::::::88:::::::8
// .........................8:::::::8::::::::8
// .........................8;:;::::8:::::::::8
// .........................8:8:;:::8::::::::::8
// .........................88:8:8::8::8::8::8:88
// --------------------美女保佑，永无Bug，不改需求，早点下班---------------------------------
#pragma comment(lib,"Psapi.lib")
#include "GameServerApp.h"
#include "LC_NPCShopManager.h"
#include "LC_NPCTransferManager.h"
#include "SC_ServerScriptInterface.h"
#include "LC_FactionManager.h"
#include "LC_ServerActorOperationManager.h"
#include "LC_ServerGuildManager.h"
#include "LC_CrossRealmRaidManager.h"
#include "LC_RumorManager.h"
#include "UT_DirConfig.h"
#include "LC_PromoterAsset.h"
#include "LC_VIPAsset.h"
#include "LC_ActorAttributeMap.h"
#include "LC_OpenAbilityAsset.h"
#include "LC_TreasureChestsAsset.h"
#include "LC_SubordinateAsset.h"
#include "LC_CommonStatAsset.h"
#include "LC_ServerShopAsset.h"
#include "LC_GuildRaidDataManager.h"
#include "LC_ShotActivity.h"
#include "LC_AchievementManager_Common.h"
#include "LC_ItemBase.h"
#include "LC_TitleAsset.h"
#include "LC_SkillBookAsset.h"
#include "LC_GuildStruct.h"

#include "LC_ServerTaskManager.h"
#include "SM_ServerStateFactory.h"
#include "LC_ServerItemFactory.h"
#include "LC_ServerItemFlopManager.h"
#include "LC_ServerLogicManager.h"
#include "LC_ServerPlayerManager.h"
#include "LC_ServerPlayerEnterLeaveManager.h"
#include "LC_ServerPlayer.h"
#include "SM_ServerControllerFactory.h"
#include "SK_ServerSkillEventManager.h"
#include "UT_GameServerLogManager.h"
#include "LC_NPCTransferManager.h"
#include "NW_ServerSession.h"
#include "NW_Helper.h"
#include "game_version.h"

#include "PF_ServerPathManager.h"
#include "TT_TextManager.h"
#include "MC_Message2ClientManager.h"
#include "LC_ServerGameEventManager.h"
#include "TS_TranManager.h"
#include "LC_ServerNPCInteractionManager.h"
#include "LC_ServerPackEntryFactory.h"
#include "LC_ServerWorldManager.h"
#include "LC_ServerNPCManager.h"

#include "LC_ServerMapLogic_MonsterConfig.h"
#include "LC_ServerRewardManager.h"
#include "LC_ItemSuitManager.h"
#include "LC_ServerMapLogicFactory.h"

#include "LC_NPCSummorManager.h"

#include "UT_GMLogic.h"
#include "UT_GameServerProfile.h"
#include "SK_SP.h"
#include "ConfigManager.h"
#include "UT_DirConfig.h"

#include "HL_PacketHandler.h"

#include "SC_ScriptAction.h"

#include "syslog_port.h"
#include "ajson_mem.hpp"
#include "oss_log.h"
#include "UT_CmdLine.h"
#include "LC_CommandParserBase.h"
#include "LC_LogicIDManager.h"
#include "LS_LuaStateFactory.h"
#include "SK_Factory.h"
#include "LC_LogicTriggerManager.h"
#include "LC_ActorFilterManager.h"

#include "LC_ServerMysticalShop.h"
#include "LC_ServerAllianceManager.h"
#include "UT_ServerHelper.h"
#include "LC_SoulRefineAsset.h"
#include "LC_HttpHandler.h"
#include "LM_LocaleManager.h"
#include "LC_GuildLadderManager.h"
#include "LC_ActShopManager.h"
#include "gsnode.h"

#include "LC_ServerChestCSVManager.h"
#include "LC_ThirdPlatformReport.h"
#include "LC_MeltAsset.h"
#include "LC_BoneSoulAsset.h"
#include "LC_BoneSouleEffectManager.h"
#include "LC_MillionWeaponAsset.h"
#include "LC_WildPrincesManager.h"
#include "LC_ActivityRankRewardMgr.h"

#include "UT_Pick_Manager.h"
#include <boost/chrono.hpp>
#include "LC_LogicMapFileCache.h"
#include "UT_ServerHelper.h"

#ifdef WIN32
	#include <Psapi.h>
	#include <process.h>
	#include "XDebugDumper.h"
#else
	#include <unistd.h>
#endif
#include "UT_ObjectStatistics.h"
#include "UT_ClassRegistry.h"
using namespace Utility;
using namespace Protocol;
using namespace NetWork;
using namespace NetBase;
using namespace GameLogic;
using namespace CSVFile;
using namespace Skill;
using namespace StateMachine;

#define		GM_LOGUC_UPDATE_TIMER		1.00f
#define  CLIENT_GET_THROUGH_PER_SECOND  20
#define	 SESSIONKEY_VALID_TIME			300
server_version_info g_svr_version_info;
int32_t GET_PLATFORM_ID(void)
{
	static int32_t iPlatformID = get_platform_tp_by_union_id(GetGameUnionID());
	return iPlatformID;
}
int32_t GET_SERVER_ID(void)
{
	static int32_t iServerID = GetGameServerID();
	return iServerID;
}

void CloseSTDStream(void)
{
	//return;
	UT_GameServerLogManager* pkLogManager = UT_GameServerLogManager::GetSingletonPtr();
	pkLogManager->set_console(false);
	freopen("NUL", "w+", stdout);
	//freopen("NUL", "w+", stdin);
	//freopen("NUL", "w+", stderr);
}

void OpenSTDStream(void)
{
	UT_GameServerLogManager* pkLogManager = UT_GameServerLogManager::GetSingletonPtr();
	pkLogManager->set_console(true);
	freopen("CON", "w", stdout);
	//freopen("CON", "w", stdin);
	//freopen("CON", "w", stderr);
}

#ifdef WIN32
class ProceMemDetecter
{
public:
	ProceMemDetecter(){
		m_hProcess = ::OpenProcess(PROCESS_QUERY_INFORMATION | PROCESS_VM_READ, FALSE, ::GetCurrentProcessId());
		m_fLastSummary = 0.00f;
	}
	~ProceMemDetecter(){}
	void Update(float fCurrent){
		if ( fCurrent - m_fLastSummary <= 60.00f )
			return;

		m_fLastSummary = fCurrent;
		PROCESS_MEMORY_COUNTERS pmc;
		::GetProcessMemoryInfo(m_hProcess, &pmc, sizeof(PROCESS_MEMORY_COUNTERS));
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ProceMemDetecter Process Working Size: %u KB,   Peak %u KB, VM: %u KB, Peak VM: %u KB", pmc.WorkingSetSize / 1024, pmc.PeakWorkingSetSize / 1024, pmc.PagefileUsage/1024,pmc.PeakPagefileUsage/1024);
	}
private:
	HANDLE m_hProcess;
	float m_fLastSummary;
};

static ProceMemDetecter g_ProceMemDetecter;
#endif

//////////////////////////////////////////////////////////////////////////

#define Init_Boost_time_point(ts1, ts2)\
	boost::chrono::system_clock::time_point ts1, ts2;\

#define Get_Boost_time_point(ts)\
	ts = boost::chrono::system_clock::now();

double Get_Boost_time_point_count(boost::chrono::system_clock::time_point& ts1, boost::chrono::system_clock::time_point& ts2)
{
	boost::chrono::duration<double> sec = ts2 - ts1;
	ts1 = ts2;
	return sec.count() /** 1000*/;
}

//////////////////////////////////////////////////////////////////////////

VOID DestroyServerSideConnectedObject(NetworkObject* pNetworkObject);
//////////////////////////////////////////////////////////////////////////
//全局函数
//////////////////////////////////////////////////////////////////////////
//--------------------------------------------------
VOID DestroyServerSideConnectedObject(NetworkObject* pNetworkObject)
{
	DestoryServerSession((NW_ServerSession*)pNetworkObject);
}

void gmCommandHandler(const redis_define::redis_channel_msg& kmsg)
{
	GfxWriteFmtLog(LOG_GM_FILELINE, LOG_SWITCH_GM, "gmCommandHandlerChanel", kmsg.m_type() , kmsg.content().c_str());

	redis_define::gm_msg_req k_gm_req;
	if (!k_gm_req.ParseFromString(kmsg.content()))
	{
		return;
	}
	GfxWriteFmtLog(LOG_GM_FILELINE, LOG_SWITCH_GM, "gmCommandHandlerReq" , k_gm_req.command().c_str());
	Utility::UT_CommandLine  cmdLine;
	cmdLine.SplitLine(k_gm_req.command().c_str());
	DebugCommandResult kResult = LC_CommandParserBase::GetSingletonPtr()->ParseCommand(cmdLine, INIT_GM_SCRIPT_PRIORITY, kmsg.m_id(), &k_gm_req);
	GfxWriteFmtLog(LOG_GM_FILELINE, LOG_SWITCH_GM, "gmCommandHandlerResp", k_gm_req.command().c_str(), kResult.uiRslt, kResult.rsltMsg.c_str());
	oss_role_gm_command(NULL, kmsg.m_id(), cmdLine.GetCommandName(), k_gm_req.command().c_str(), kResult.uiRslt);
	if (RE_IN_TRANS != kResult.uiRslt)
	{
		static GameServerApp* pkServerApp = GetGameServerApp();
		Utility::gm_cmd_resp json_resp;
		json_resp.channel.type = MGPT_REDIS_RESP_GM_COMMAND;
		json_resp.channel.id = kmsg.m_id();
		json_resp.type = k_gm_req.type();
		json_resp.cmd = k_gm_req.command();
		json_resp.code = kResult.uiRslt;
		json_resp.msg.append(CodeConvert::MbsToUtf8(kResult.rsltMsg).c_str());
		json_resp.data.append(CodeConvert::MbsToUtf8(kResult.dataMsg).c_str());
		pkServerApp->PublishChannel(pkServerApp->GetRedisGMRespChannel(), json_resp);
	}
}

void httpRespHandler(const redis_define::redis_channel_msg& kmsg)
{
	http_resp k_http_resp;
	std::string errorMsg;
	if (!boost::ajson::load_from_buff(k_http_resp, kmsg.content().c_str(), errorMsg))
	{
		return;
	}
	static GameServerApp* pkServerApp = GetGameServerApp();
	static LC_HttpHandler* pkHttpHandler = pkServerApp->GetHttpHandler();
	if (!pkHttpHandler)
	{
		return;
	}
	pkHttpHandler->HandleResponse(k_http_resp.req_id, k_http_resp.result);
}

void rumorDirtyHandler(const redis_define::redis_channel_msg& kmsg)
{
	redis_define::rumor_dirty_notify k_rumor_dirty;
	if (!k_rumor_dirty.ParseFromString(kmsg.content()))
	{
		GfxWriteLog(LOG_ERROR_FILELINE , LOG_ERROR_FILELINE, "rumorDirtyHandler k_rumor_dirty:%s" , kmsg.content().c_str());
		return;
	}
	//LC_RumorManager::GetSingletonPtr()->UpdateRedis(k_rumor_dirty, true);
}


void on_sub(const std::string& scmd, const std::string& schannel, const std::string& scount)
{
	GfxWriteFmtLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "on subscribe", scmd, schannel, scount);
}
void on_msg(const std::string& schannel, const std::string& smessage)
{
	GfxWriteFmtLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "on message", schannel, smessage);
}

void MulticastMsgHelper::SetUp(GameServerApp* pkApp, mem::vector<Protocol::PS_ServerInfo>& gatewayInofs)
{
	app = pkApp;
	mem::vector<Protocol::PS_ServerInfo>::iterator it = gatewayInofs.begin();
	for (; it!=gatewayInofs.end(); ++it)
	{
		Protocol::PS_ServerInfo& rkSvrInfo = *it;
		GetUserCluster(SERVER_TYPE_GATEWAY, rkSvrInfo.m_iServerID);
	}
}

MultiUsersCluster* MulticastMsgHelper::GetUserCluster(int32_t iSvrType, int32_t iSvrID)
{
	MultiUsersClusterMap::iterator it = userIndicesCache.find(iSvrID);
	if (it != userIndicesCache.end())
	{
		return &it->second;
	}

	MultiUsersCluster& rkCache = userIndicesCache[GEN_UNIQUE_ID(GET_PLATFORM_ID(), iSvrType, iSvrID)];
	rkCache.Init(iSvrType, iSvrID);
	return &rkCache;
}

BOOL MulticastMsgHelper::Begin(uint16_t msgType, LC_PlayerOperator* filter)
{
	usMsgType = msgType;
	MultiUsersClusterMap::iterator it = userIndicesCache.begin();
	for (; it!=userIndicesCache.end(); ++it)
	{
		it->second.Clear();
	}
	multiCastMessage.clear();
	pkFilter = filter;
	return TRUE;
}

BOOL MulticastMsgHelper::Encode(Protocol::MG_BODY* pkMsgBody)
{
	if (NULL == pkMsgBody)
	{
		return TRUE;
	}
	multiCastMessage.m_szMessageBuff.resize(MAX_MULTICAST_MESSAGE_SIZE);
	return pkMsgBody->Encode(multiCastMessage.m_szMessageBuff);
}

BOOL MulticastMsgHelper::AddUserIndices(LC_ServerPlayer* pkPlayer)
{
	BOOL ret = TRUE;
	if (pkPlayer && (NULL==pkFilter||(*pkFilter)(pkPlayer)))
	{
		if (pkPlayer->GetSession())
		{
			MultiUsersCluster* pkCluser = GetUserCluster(SERVER_TYPE_GATEWAY, pkPlayer->GetSession()->PeerID());
			if (pkCluser)
			{
				Protocol::PS_UserSocketIndex userSock;
				userSock.m_uiUserID = pkPlayer->GetUserID();
				if (pkCluser->AddUserReturnFull(userSock))
				{
					multiCastMessage.m_akUserInfo = pkCluser->Indices();
					ret = app->MulticastMsgToGateway(pkCluser->ServerID(), usMsgType, &multiCastMessage);
					pkCluser->Clear();
				}
			}
		}
		
		if(pkPlayer->GetAsAControlee().IsValid())
		{
			MultiUsersCluster* pkCluser = GetUserCluster(SERVER_TYPE_GAME, pkPlayer->GetControlerPeer().ServerID());
			if (pkCluser)
			{
				Protocol::PS_UserSocketIndex userSock;
				userSock.m_uiUserID = pkPlayer->GetControlerPeer().UserID();
				userSock.m_iSocketIndex = pkPlayer->GetControlerPeer().GatewayID();
				if (pkCluser->AddUserReturnFull(userSock))
				{
					multiCastMessage.m_akUserInfo = pkCluser->Indices();
					ret = app->MulticastMsgByGame(pkCluser->ServerID(), usMsgType, &multiCastMessage);
					pkCluser->Clear();
				}
			}
		}		
	}
	return ret;
}
BOOL MulticastMsgHelper::AddUserIndices(Protocol::PS_UserSocketIndex& rkUserIndex)
{
	BOOL ret = TRUE;
	MultiUsersCluster* pkCluser = GetUserCluster(SERVER_TYPE_GATEWAY, rkUserIndex.m_iSocketIndex);
	if (pkCluser)
	{
		Protocol::PS_UserSocketIndex userSock;
		userSock.m_uiUserID = rkUserIndex.m_uiUserID;
		if (pkCluser->AddUserReturnFull(userSock))
		{
			multiCastMessage.m_akUserInfo = pkCluser->Indices();
			ret = app->MulticastMsgToGateway(pkCluser->ServerID(), usMsgType, &multiCastMessage);
			pkCluser->Clear();
		}
	}
	return ret;
}

BOOL MulticastMsgHelper::End(void)
{
	BOOL ret = TRUE;
	MultiUsersClusterMap::iterator it = userIndicesCache.begin();
	MultiUsersClusterMap::iterator itEnd = userIndicesCache.end();
	for ( ; it!=itEnd; ++it)
	{
		MultiUsersCluster& rkCluser = it->second;
		if (!rkCluser.IsEmpty())
		{
			multiCastMessage.m_akUserInfo = rkCluser.Indices();
			switch(rkCluser.ServerType())
			{
			case SERVER_TYPE_GATEWAY:
				ret &= app->MulticastMsgToGateway(rkCluser.ServerID(), usMsgType, &multiCastMessage);
				break;
			case SERVER_TYPE_GAME:
				ret &= app->MulticastMsgByGame(rkCluser.ServerID(), usMsgType, &multiCastMessage);
				break;
			default:
				break;
			}
			rkCluser.Clear();
		}
	}
	return TRUE;
}

//--------------------------------------------------
//GameServerApp
//--------------------------------------------------
GameServerApp::GameServerApp()
	: NW_NetManagerBase()
	, m_fLastLogicUpdateTime(0.0f)
	, m_fGameEventUpdateTime(0.0f)
	, m_fSkillEventUpdateTime(0.0f)
	, m_fTaskUpdateTime(0.0f)
	, m_pkGameEventManager(NULL)
	, m_pkSkillEventManager(NULL)
	, m_pkSIOManager(NULL)
	, m_pkDBServerSession(NULL)
	, m_pkLoginServerSession(NULL)
	, m_pkGroupServerSession(NULL)
	, m_pkMailServerSession(NULL)
	, m_pkChatServerSession(NULL)
	, m_pkTradeServerSession(NULL)
	, m_pkSocietyServerSession(NULL)
	, m_pkGlobalServerSession(NULL)
	, m_fLastDBServerSessionUpdateTime(0.0f)
	, m_fLastLoginServerSessionUpdateTime(0.0f)
	, m_fLastGMLogicUpdateTime(0.00f)
	, m_fLastGroupServerSessionUpdateTime(0.0f)
	, m_fLastNetDataOutputSaveTime(0.0f)
	, m_iGameServerTimeOut(0)
	, m_iGameServerAcceptCount(0)
	, m_iClientVersionLimit(0)
	, m_message2Client(NULL)
	, m_bBranchNode(false)
	, m_bUseNewPlayerMap(false)
	, m_iNewPlayerCountPerMap(0)
	, m_strConfigPath("./Data/Config/")
	, m_strLogPath("./log/")
	, m_strLocalePath("./Data/LocaleMsg/")
	, m_strAct360PriviUrl("http://hd.wan.360.cn/check_privi.html")
	, m_bSyncActiveSucceed(false)
	, m_iPredayActive(0)
	, m_iPredayCrossActive(0)
	, m_bInitEntryServer(false)
	, m_iServerEntryId(0)
	, m_nNodeType(0)
	, m_bToolMode(false)
	, m_bExitByToolMode(false)
	, m_nBotOPCode(-1)
{
	m_pkTranManager = NULL;
	m_pkTextManager = NULL;
	m_pkTaskManager = NULL;
	m_pkPackEntryFactory = NULL;
	m_pkLogicManager = NULL;
	m_pkTimeManager = NULL;
	m_pkTimerMgr = NULL;
	m_pkGuildRaidDataManager = NULL;
	m_pkNetSessionManager = NULL;
	m_allow_gm_cmd = false;
	m_360_privi_gm_test = false;
	m_ExportRobot = NULL;
	m_sSurviveCheckChanel = "";
	m_fSurviveCheckTime = 0.0f;
	m_pkThirdPlatFormReport = NULL;
}
//--------------------------------------------------
GameServerApp::~GameServerApp()
{
}
//--------------------------------------------------

#ifdef ACTIVATION_CODE
bool GameServerApp::Init()
{
	//读取配置文件
	if (FALSE == LoadServerConfig())
	{
		return false;
	}

	//目录管理
	{
		UT_DirConfig* obj = T_NEW_D UT_DirConfig;
		if(obj != NULL)
		{
			obj->Init("./Data/Config/DirConfig.ini");
		}
	}

	//日志系统
	{
		UT_GameServerLogManager* obj = T_NEW_D UT_GameServerLogManager;
	}

	//CSV静态数据管理
	{
		CF_ServerCSVManager* m_pkServerCSVManager = T_NEW_D CF_ServerCSVManager;
		if(m_pkServerCSVManager == NULL || m_pkServerCSVManager->Init() == false)
		{
			return false;
		}
	}

	IOHANDLER_DESC desc[1];
	desc[0].dwIoHandlerKey					= SERVER_IOHANDLER;
	desc[0].dwMaxConnectSession				= 30;
	desc[0].dwSendBufferSize				= 0x800000;
	desc[0].dwRecvBufferSize				= 0x800000;
	desc[0].dwTimeOut						= INFINITE;
	desc[0].dwMaxPacketSize					= Protocol::SIZE_MSG_BUFF;
	desc[0].fnDestroyConnectedObject		= DestroyServerSideConnectedObject;

	m_pkIOCPServer = new NW_IOCPServer;
	if (!m_pkIOCPServer->Init(desc, 1))
	{
		T_ASSERT(false);
		return false;
	}
	{
		redis_info& kSvrInfo = m_kGlobalRedis;
		m_kGlobalRedisHandler.AddPeer(kSvrInfo.ip, boost::lexical_cast<std::string>(kSvrInfo.port), kSvrInfo.auth);
		if(0 != m_kGlobalRedisHandler.Init())
		{
			return false;
		}
	}
	if (!m_kLocalRediss.empty())
	{
		{
			mem::vector<redis_info>::iterator it = m_kLocalRediss.begin();
			for (; it!=m_kLocalRediss.end(); ++it)
			{
				m_kRedisHandler.AddPeer(it->ip, boost::lexical_cast<std::string>(it->port), it->auth);
			}
		}
		if(0 != m_kRedisHandler.Init())
		{
			return false;
		}
	}
	return true;
}

void GameServerApp::UnInit()
{
	m_kRedisHandler.Unit();
	m_pkIOCPServer->Shutdown();
	T_SAFE_DELETE(m_pkIOCPServer);

	{
		CF_ServerCSVManager* m_pkServerCSVManager = CF_ServerCSVManager::GetSingletonPtr();
		if(m_pkServerCSVManager != NULL)
		{
			m_pkServerCSVManager->UnInit();
			T_SAFE_DELETE(m_pkServerCSVManager);
		}
	}

	{
		UT_GameServerLogManager* obj = UT_GameServerLogManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		UT_DirConfig* m_pkDirConfig = UT_DirConfig::GetSingletonPtr();
		m_pkDirConfig ->UnInit();
		T_SAFE_DELETE(m_pkDirConfig);
	}
}
#else
#define PERF_TEST

void GameServerApp::SetToolMode( bool bInput )
{
	m_bToolMode = bInput;
}

bool GameServerApp::GetToolMode()
{
	return m_bToolMode;
}

void GameServerApp::SetExitByToolMode(bool bInput)
{
	m_bExitByToolMode = bInput;
}

bool GameServerApp::GetExitByToolMode()
{
	return m_bExitByToolMode;
}

void GameServerApp::SetBotOPCode( int32_t nCode )
{
	m_nBotOPCode = nCode;
	if ( nCode != -1 )
		SetToolMode(true);
}

int32_t GameServerApp::GetBotOPCode()
{
	return m_nBotOPCode;
}

void GameServerApp::TryExecuteBotOP()
{
	if ( m_bToolMode == false )
		return;
	if ( m_nBotOPCode == -1 )
		return;

	printf( "tool mode execute.\n" );
	ExportRobot* pOPMgr = (ExportRobot*)ExportRobot::GetSingletonPtr();
	pOPMgr->SetOperator(null_unique_impl);

	OpenSTDStream();
	GfxWriteLog(LOG_TAG_SYSTEM, LOG_SWITCH_SYSTEM, "BotExportOperationDone.");
	CloseSTDStream();
	SetExitByToolMode(true);
}

bool GameServerApp::InitLess()
{
#ifdef PERF_TEST
	Init_Boost_time_point(ts1, ts2);
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//读取配置文件
	if (FALSE == LoadServerConfig())
	{
		std::cout << Utility::Utf8Show(" LoadServerConfig error !!!  ") << std::endl;
		return false;
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" LoadServerConfig use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//目录管理
	{
		UT_DirConfig* obj			= T_NEW_D UT_DirConfig;
		StringType kFileName		= "./Data/Config/DirConfig.ini";
		obj->Init(kFileName);
	}

	//ID管理
	{
		LC_LogicIDManager* m_pkLogicIDManager	= T_NEW_D LC_LogicIDManager;

		m_pkLogicIDManager->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 目录管理 ID管理 init use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif
	//事务管理
	{
		m_pkTranManager							= T_NEW_D TS_TranManager;
	}


#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//脚本
	{
		LS_LuaStateFactory* m_pkLuaStateFactory = T_NEW_D LS_LuaStateFactory;
		SC_ServerScriptInterface* m_pkServerScriptInterface	= T_NEW_D SC_ServerScriptInterface;
		m_pkServerScriptInterface->RegisterToLua();
		m_pkLuaStateFactory->Init();
		m_pkServerScriptInterface->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 脚本 init use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

	//日志系统
	{
		T_NEW_D UT_GameServerLogManager;
	}

	{
		LC_PackAsset::Init();
	}

	//文字管理
	{
		m_pkTextManager	= T_NEW_D TT_TextManager;
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//CSV静态数据管理
	{
		CF_ServerCSVManager* m_pkServerCSVManager = T_NEW_D CF_ServerCSVManager;
		if(m_pkServerCSVManager->Init() == false)
		{
			std::cout << Utility::Utf8Show("CSV静态数据管理error ！！！ ") << std::endl;
			return false;
		}
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show("CSV静态数据管理 use time:") << Get_Boost_time_point_count(ts1, ts2) << "secs." << std::endl;
#endif
	return true;
}

bool GameServerApp::Init()
{
	m_pkTimerMgr									= T_NEW_D UT_TimerManager();	
	if(InitLess() == false)
	{
		std::cout << Utility::Utf8Show(" InitLess error ！！！ ") << std::endl;
		return false;
	}
	//rtti
	{
		UT_ClassRegistry * m_pkClassRegistry	= T_NEW_D UT_ClassRegistry;
	}

	//本地化文字管理
	{
		LM_LocaleManager* pkMgr	= T_NEW_D LM_LocaleManager;
		pkMgr->Init(m_strLocalePath);
	}

#ifdef PERF_TEST
	Init_Boost_time_point(ts1, ts2);
#endif
	//公会副本数据
	{
		m_pkGuildRaidDataManager = T_NEW_D GameLogic::LC_GuildRaidDataManager;
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//技能
	{
		SK_Factory* m_pkSkillFactory				= T_NEW_D SK_Factory;
		m_pkSkillFactory->Init(false);
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" SK_Factory m_pkSkillFactory use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//任务
	{
		m_pkTaskManager								= T_NEW_D LC_ServerTaskManager;
		m_pkTaskManager->Init();
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" m_pkTaskManager use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

	
#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//状态机
	{
		SM_StateFactory* m_pkStateFactory			= T_NEW_D SM_ServerStateFactory;
		m_pkStateFactory->Init();

		SM_ControllerFactory* m_pkControllerFactory	= T_NEW_D SM_ServerControllerFactory;
		m_pkControllerFactory->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 状态机  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif


#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	{
		ItemEffectManage* inst = T_NEW_D ItemEffectManage();
		inst->Init();
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" ItemEffectManage  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//物品
	{
		LC_ItemFactoryBase* m_pkItemFactory			= T_NEW_D LC_ServerItemFactory;
		m_pkItemFactory->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" LC_ItemFactoryBase  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif


#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	{
		m_pkPackEntryFactory						= T_NEW_D LC_ServerPackEntryFactory;
		m_pkPackEntryFactory->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" m_pkPackEntryFactory  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif


#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//NPC商店
	{
		LC_NPCShopManager* m_pkNPCShopManager		= T_NEW_D LC_NPCShopManager;
		m_pkNPCShopManager->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" m_pkNPCShopManager  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif


#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	{
		LC_NPCTransferManager* m_pkNPCTransferManager		= T_NEW_D LC_NPCTransferManager;
		m_pkNPCTransferManager->Init();
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" m_pkNPCTransferManager  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	// 逻辑区域管理
	{
		m_pMapResourceCache = T_NEW_D FileSystem::LC_LogicMapFileCache;
		LC_LogicMapManager* m_pkLogicMapManager		= T_NEW_D LC_LogicMapManager;

		m_pkLogicMapManager->Load();

		LC_LogicTriggerManager* m_pkLogicTriggerManager = T_NEW_D LC_LogicTriggerManager;
		m_pkLogicTriggerManager->Init();
	}

#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show("逻辑区域管理 use time:") << Get_Boost_time_point_count(ts1, ts2) << "secs." << std::endl;
#endif

	m_pkNetSessionManager							= T_NEW_D NW_NetSessionManager;

	m_pkTimeManager									= T_NEW_D UT_TimeManager;

	m_pkTimeManager->StartTimer();
	m_pkGameEventManager							= T_NEW_D LC_ServerGameEventManager;

	m_pkSkillEventManager							= T_NEW_D SK_ServerSkillEventManager;



#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//地图参数管理
	{
		DungeonConfigDataManager* m_pkDungeonConfigDataManager = T_NEW_D DungeonConfigDataManager;
		m_pkDungeonConfigDataManager->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 地图参数管理  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//Server PathManager
	{
		PF_ServerPathManager* m_pkPathManager       = T_NEW_D PF_ServerPathManager;
		m_pkPathManager->Load();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" Server PathManager  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	//子弹碰撞数据
	{
		UT_Pick_Manager* m_pkPickManager			= T_NEW_D UT_Pick_Manager();
		CF_WorldMapList::DataEntryMapExternIterator kIter = CF_WorldMapList::GetSingletonPtr()->GetIterator();
		FileSystem::LC_LogicMapFileCache* pFileCache = m_pMapResourceCache;

		for( ; kIter.HasMoreElements(); kIter.MoveNext() )
		{
			const CF_WorldMapList::DataEntry* pkEntry = kIter.PeekNextValuePtr();
			UT_Pick_World * pkWorld = pFileCache->AllocatePickWorldData( pkEntry->_kSceneObjectCollision );
			if ( pkWorld == NULL )
				continue;
			m_pkPickManager->LoadWorld(pkEntry->_iID, pkWorld, pkEntry->_kSceneObjectCollision);
		}
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 子弹碰撞数据  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif

	LC_Helper::InitBuddyUpgradeRate();

	m_pkLogicManager								= T_NEW_D LC_ServerLogicManager;

	m_pkLogicManager->Init();

	//掉落物品管理
	{
		T_NEW_D LC_ServerItemFlopManager;
	}
	{
		T_NEW_D LC_ServerRewardManager;
	}
	{
		SK_SP* obj = T_NEW_D SK_SP;
		obj->Init();
	}
	{
		ItemSuitManager* obj = T_NEW_D ItemSuitManager;
		obj->Init();
	}

	//调试命令解析器
	{
		LC_CommandParserBase* m_pkCmdParser		= T_NEW_D LC_CommandParserBase("ServerDebugScriptSample.lua");
		m_pkCmdParser->Init();
		m_pkCmdParser->SetAllowDebugConsol(m_allow_gm_cmd);
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" A big wave init_1  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//NPC交互管理器
	{
		LC_ServerNPCInteractionManager* m_pkNPCInteractionManager	= T_NEW_D LC_ServerNPCInteractionManager;
		m_pkNPCInteractionManager->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" NPC交互管理器  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//阵营管理器
	{
		LC_FactionManager* m_pkFactionManager	= T_NEW_D LC_FactionManager;
		m_pkFactionManager->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 阵营管理器  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	/*
	{
	  LC_ServerExchangeManager * m_pkServerExchangeManager	= T_NEW_D LC_ServerExchangeManager;
	  m_pkServerExchangeManager->Init();
	}
	*/

	//操作管理
	{
		T_NEW_D LC_ServerActorOperationManager;
	}

	//门派
	{
		LC_ServerGuildManager* m_pkGuildManager	= T_NEW_D LC_ServerGuildManager();
		m_pkGuildManager->Init();
	}

	{
		LC_CrossRealmRaidManager* m_pkManager	= T_NEW_D LC_CrossRealmRaidManager();
		m_pkManager->Init();
	}

	//目标过滤管理器
	{
		LC_ActorFilterManager* m_pkActorFilterManager	= T_NEW_D LC_ActorFilterManager;
		m_pkActorFilterManager->Init();
	}

	//传闻
	{
		T_NEW_D LC_RumorManager;
	}

	//推广员
	{
		LC_PromoterManager* m_pkPromoterManager = T_NEW_D LC_PromoterManager;
		m_pkPromoterManager->Init();
	}

	//VIP
	{
		LC_VIPCmnManager* m_pkVIPCmnManager		= T_NEW_D LC_VIPCmnManager;
		m_pkVIPCmnManager->Init();
	}

	{
		LC_ActorAttributeManager* pkMgr			= T_NEW_D LC_ActorAttributeManager;
		pkMgr->Init();
	}

	{
		LC_OpenAbilityMgr* pkMgr				= T_NEW_D LC_OpenAbilityMgr;
		pkMgr->Init();
	}

	{
		LC_TreasureChestsManager* pkMgr			= T_NEW_D LC_TreasureChestsManager;
		pkMgr->Init();
	}
	{
		ScriptAction::SA_ActionManager* pkMgr	= T_NEW_D ScriptAction::SA_ActionManager;
		pkMgr->Init("ScriptAction.lua");
	}
	{
		LC_SubordinateManager* pkMgr			= T_NEW_D LC_SubordinateManager;
		pkMgr->Init();
	}
	{
		LC_SkillBookManager* pkMgr				= T_NEW_D LC_SkillBookManager;
		pkMgr->Init();
	}
	{
		LC_CommonStatManager* pkMgr				= T_NEW_D LC_CommonStatManager(m_server_union_info_.union_id);
		pkMgr->Init();
	}
	{
		LC_ServerShopManager* pkMgr				= T_NEW_D LC_ServerShopManager;
		pkMgr->Init();
	}
	{
		CAchievementManager* pkMgr		= T_NEW_D CAchievementManager;
		pkMgr->Init();
	}
	{
		CActShopManager* pkMgr		= T_NEW_D CActShopManager;
		pkMgr->Init();
	}
	{
		LC_SystemTitleManager* pkMgr			= T_NEW_D LC_SystemTitleManager;
		pkMgr->Init();
	}
	{
		LC_GuildRandomNameManager* pkMgr		= T_NEW_D LC_GuildRandomNameManager;
		pkMgr->Init();
	}
	{
		LC_ItemAuctionCategoryManager* pkMgr	= T_NEW_D LC_ItemAuctionCategoryManager;
		pkMgr->Init();
	}

	{
		CWildPrincesManager* pkMgr = T_NEW_D CWildPrincesManager;
		pkMgr->Init();
	}

	{
		CActivityRankRewardMgr* pkMgr = T_NEW_D CActivityRankRewardMgr;
		pkMgr->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" A big wave init_2  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	//NPC召唤物信息
	{
		LC_NPCSummorManager* pkMgr				= T_NEW_D LC_NPCSummorManager;
		pkMgr->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" NPC召唤物信息  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif
	//资源预警设置
	{
		LC_ResourceAlertManager* pkMgr			= T_NEW_D LC_ResourceAlertManager;
		pkMgr->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" 资源预警设置 init  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	{
		ServerMysticalShop* pKMgr				= T_NEW_D ServerMysticalShop;
		pKMgr->InitConfig();
	}

	{
		T_NEW_D LC_ServerAllianceManager();
	}

	{
		LC_SoulRefineDataAsset* pkMgr			= T_NEW_D LC_SoulRefineDataAsset;
		pkMgr->Init();
	}

	{
		m_pkThirdPlatFormReport					= T_NEW_D LC_ThirdPlatformReport;
	}

	{
		LC_FacebookRewardManager* pkMgr			= T_NEW_D LC_FacebookRewardManager;
		pkMgr->Init();
	}
	{
		LC_MeltDataManager* pkMgr			= T_NEW_D LC_MeltDataManager;
		pkMgr->Init();
	}
	{
		LC_BoneSoulManager* pkMgr			= T_NEW_D LC_BoneSoulManager;
		pkMgr->Init();
	}
	{
		LC_BoneSouleEffectManager* pkMgr = T_NEW_D LC_BoneSouleEffectManager;
		pkMgr->Init();
	}
	{
		LC_StarsRuneManager* pkMgr = T_NEW_D LC_StarsRuneManager;
		pkMgr->Init();
	}
	{
		LC_MillionWeaponManager* pkMgr = T_NEW_D LC_MillionWeaponManager;
		pkMgr->Init();
	}
	//公会天梯管理
	{
		LC_GuildLadderManager* pkMgr	= T_NEW_D LC_GuildLadderManager;
		pkMgr->Init();
	}
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" Another big wave  init  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

#ifdef PERF_TEST
	Get_Boost_time_point(ts1);
#endif
	IOHANDLER_DESC desc[1];
	desc[0].dwIoHandlerKey					= SERVER_IOHANDLER;
	desc[0].dwMaxConnectSession				= 30;
	//desc[0].dwMaxConnectSession				= 18;
	desc[0].dwSendBufferSize				= 0x1600000;
	//desc[0].dwSendBufferSize				= 4*1024*1024;
	desc[0].dwRecvBufferSize				= 0x1600000;
	//desc[0].dwRecvBufferSize				= 4*1024*1024;
	desc[0].dwTimeOut						= INFINITE;
	desc[0].dwMaxPacketSize					= Protocol::SIZE_MSG_BUFF;
	desc[0].fnDestroyConnectedObject		= DestroyServerSideConnectedObject;

	m_pkIOCPServer = new NW_IOCPServer;
	if (!m_pkIOCPServer->Init(desc, 1))
	{
		std::cout << Utility::Utf8Show(" m_pkIOCPServer init error !!! ")<< std::endl;
		return false;
	}

	m_pkSIOManager							= new NW_SIOSessionManager(4);
	m_pkSIOManager->SetLocalInfo(m_kServerInfo);
	m_pkSIOManager->run();
	if (IsBranchNode())
	{
		m_pkSIOManager->accept(m_kServerInfo.m_szIP.c_str(), m_kServerInfo.m_iPort);
	}

	// memory checking: 500M
	InitMessage2Client();

	g_registerGameHandler();

	//必须在最后
	m_pkDBServerSession						= CreateServerSession(NST_GAMESERVER_TO_DBSERVER, m_kDBServerInfo);
	m_pkLoginServerSession					= CreateServerSession(NST_GAMESERVER_TO_LOGINSERVER, m_kLoginServerInfo);
	m_pkGroupServerSession					= CreateServerSession(NST_GAMESERVER_TO_GROUPSERVER, m_kGroupServerInfo);
	m_pkMailServerSession					= CreateServerSession(NST_GAMESERVER_TO_MAILSERVER, m_kMailServerInfo);
	m_pkChatServerSession					= CreateServerSession(NST_GAMESERVER_TO_CHATSERVER, m_kChatServerInfo);
	m_pkTradeServerSession					= CreateServerSession(NST_GAMESERVER_TO_TRADESERVER, m_kTradeServerInfo);
	m_pkSocietyServerSession				= CreateServerSession(NST_GAMESERVER_TO_SOCIETYSERVER, m_kSocietyServerInfo);
	m_pkGlobalServerSession					= CreateServerSession(NST_GAMESERVER_TO_GLOBALSERVER, m_kGlobalServerInfo);

	mem::vector<Protocol::PS_ServerInfo>&	gatewayInofs = GetGatewayInfo();
	for (size_t i = 0; i < gatewayInofs.size(); ++i)
	{
		NW_ServerSession* game2GatewaySession = CreateServerSession(NST_GAMESERVER_TO_GATEWAY, gatewayInofs[i]);
		game2GatewaySession->SetMessageRecorder(&m_messageRecorder);
		m_kGame2GatewaySessions[game2GatewaySession->PeerID()] = (game2GatewaySession);
	}

	m_multiMsgHelper.SetUp(this, gatewayInofs);

	if (!m_ServerManager.Init(GetServerInfo().m_iServerID, GetServerInfo().m_iType))
	{
		return false;
	}
	m_ExportRobot							= T_NEW_D ExportRobot;
	ConfigManagerInit();
#ifdef PERF_TEST
	Get_Boost_time_point(ts2);
	std::cout << Utility::Utf8Show(" GameServerApp session inited  use time: ") << Get_Boost_time_point_count(ts1, ts2) << " secs." << std::endl;
#endif

	{
		redis_info& kSvrInfo = m_kGlobalRedis;
		m_kGlobalRedisHandler.AddPeer(kSvrInfo.ip, boost::lexical_cast<std::string>(kSvrInfo.port).c_str(), kSvrInfo.auth);
		if(0 != m_kGlobalRedisHandler.Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp global redis init fail！！！") << Utility::Utf8Show(m_kGlobalRedisHandler.GetLastError().c_str()) << std::endl;
			return false;
		}

		m_kGlobalRedisChannel.AddRedis(kSvrInfo.ip, boost::lexical_cast<std::string>(kSvrInfo.port).c_str(), kSvrInfo.auth);

		if (0!=m_kGlobalRedisChannel.InitRedis())
		{
			std::cout << Utility::Utf8Show("GameServerApp global redis channel init fail！！！") << Utility::Utf8Show(m_kGlobalRedisChannel.GetLastError().c_str()) << std::endl;
			return false;
		}
		m_kGlobalRedisChannel.Start();
		std::cout << Utility::Utf8Show("GameServerApp global redis inited！！！") << std::endl;
	}

	if (!m_kMonitorRediss.empty())
	{
		{
			mem::vector<redis_info>::iterator it = m_kMonitorRediss.begin();
			for (; it!=m_kMonitorRediss.end(); ++it)
			{
				m_kMonitorRedisChannel.AddRedis(it->ip, boost::lexical_cast<std::string>(it->port), it->auth);
			}
		}

		if (0!=m_kMonitorRedisChannel.InitRedis())
		{
			std::cout << Utility::Utf8Show("GameServerApp redis channel init fail！！！") << Utility::Utf8Show(m_kMonitorRedisChannel.GetLastError().c_str()) << std::endl;
			return false;
		}
		m_kMonitorRedisChannel.Start();
		std::cout << Utility::Utf8Show("GameServerApp monitor redis inited！！！") << std::endl;
	}

	if (!m_kLocalRediss.empty())
	{
		{
			mem::vector<redis_info>::iterator it = m_kLocalRediss.begin();
			for (; it!=m_kLocalRediss.end(); ++it)
			{
				m_kRedisHandler.AddPeer(it->ip, boost::lexical_cast<std::string>(it->port), it->auth);
			}
		}

		if(0 != m_kRedisHandler.Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp local redis init fail！！！") << Utility::Utf8Show(m_kRedisHandler.GetLastError().c_str()) << std::endl;
			return false;
		}

		{
			mem::vector<redis_info>::iterator it = m_kLocalRediss.begin();
			for (; it!=m_kLocalRediss.end(); ++it)
			{
				m_kRedisChannel.AddRedis(it->ip, boost::lexical_cast<std::string>(it->port), it->auth);
			}
		}

		m_kRedisChannel.FakeSubscribe(GetRedisGMReqChannel(), gmCommandHandler);
		m_kRedisChannel.FakeSubscribe(GetRedisHttpRespChannel(), httpRespHandler);
		m_kRedisChannel.FakeSubscribe(GetRumorDirtyChannel(), rumorDirtyHandler);
		if (0!=m_kRedisChannel.InitRedis())
		{
			std::cout << Utility::Utf8Show("GameServerApp redis channel init fail！！！") << Utility::Utf8Show(m_kRedisChannel.GetLastError().c_str()) << std::endl;
			return false;
		}

		m_kRedisChannel.Start();
		std::cout << Utility::Utf8Show("GameServerApp local redis inited！！！") << std::endl;

		Utility::TestSubscribe(m_kRedisChannel, GET_PROCESS_TIME);
	}
	{
		if (!m_kTextFilterChannel.Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp chat channel init fail ! ! !") << std::endl;
			return false;
		}
		m_kTextFilterChannel.start();
		std::cout << Utility::Utf8Show("GameServerApp chat channel init ! ! !") << std::endl;
	}

	{
		if (!m_kAsyHttpClient.Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp async http client init fail ! ! !") << std::endl;
			return false;
		}
		m_kAsyHttpClient.start();
		std::cout << Utility::Utf8Show("GameServerApp async http client init ! ! !") << std::endl;
	}


	{
		LC_ShotActivityManager* pkMgr = T_NEW_D LC_ShotActivityManager;
		pkMgr->Init();
	}

	{
		if (!m_kDailyDataReport.Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp daily data report init fail ! ! !") << std::endl;
			return false;
		}
	}

	{
		m_kHttpHandler = T_NEW_D LC_HttpHandler();
		if (!m_kHttpHandler->Init())
		{
			std::cout << Utility::Utf8Show("GameServerApp http handler init fail ! ! !") << std::endl;
			return false;
		}
	}

	{
		if(m_pkLogicManager != NULL)
		{
			m_pkLogicManager->OnDbConnect();
		}
	}

	char chanelKey[512] = {0};
	sprintf_s(chanelKey, 511, "%s:%d_%d" , GetGameSurviveCheckKey().c_str(), m_kServerInfo.m_iType, m_kServerInfo.m_iServerID);
	m_sSurviveCheckChanel = chanelKey;
	m_fSurviveCheckTime = 0.0f;
	m_uServerPid = getpid();

	GetServerManager()->GetCorssLevel();

	//init custom resource version 
	{
		int ret = 0;
		std::string sCusResVerKey = GetRedisServerPredix() + UT_REDIS_KEY_CUS_RES_VERSION;
		std::string sCusResVer;		
		UT_REDIS_CMD_WITH_REPLY(ret, GetRedisHandler(), sCusResVer, hget, sCusResVerKey, GAME_VERSION_STRING());
		if (0==ret && !sCusResVer.empty())
		{
			STRNCPY(g_svr_version_info.custom_res_version(), sCusResVer.c_str(), g_svr_version_info.custom_res_version_size());
			TStringVector kCSVs;
			ConfigManagerReload(sCusResVer.c_str(), kCSVs);
		}
	}
	//init bonus role list
	{
		int ret = 0;
		std::string sKey = GetRedisServerPredix() + PLATFORM_BONUS_ROLE;

		Utility::Redis_Handler* pkRedisHandler = GetRedisHandler();
		UT_REDIS_CMD_BEGIN(ret, pkRedisHandler);
		redispp::MultiBulkEnumerator replys;
		replys = pkRedisConn->smembers(sKey);
		std::string str;
		while (replys.next(&str))
		{
			if (str.empty())
			{
				continue;
			}
			unique_id_type id = NOW_UNIQUE_ID(GET_PLATFORM_ID(), atoll(str.c_str()));
			m_kBonusRoleSet.insert(id);
		}
		UT_REDIS_CMD_END(ret, pkRedisHandler);
	}

	//init preday active
	float fCurrentTime = m_pkTimeManager->GetProcessTime();
	SyncPredayActive(fCurrentTime);

	LoadUpdateBulletin();

	//  清空在线角色列表
	UT_ServerHelper::ResetOnLinePlayer();

	LC_ThirdPlatformReport::GetSingletonPtr()->LoadConfig();


	GSNodeAllInfoMap map;
	GSNode::GetGsNodesInfo(&m_kRedisHandler, map);
	GSNodeNetwork::Instance().serializeIn(map);
	
	std::cout << Utility::Utf8Show("Init done.") << std::endl;
	UT_ServerHelper::LoadMapIDAndMirrorTaskID();
	UT_ServerHelper::GetAllGuildMapStateMutableParameterFromRedis();
	return true;
}
//--------------------------------------------------
void GameServerApp::UnInit()
{
	{
		LC_ShotActivityManager* pkMgr = LC_ShotActivityManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		m_kGlobalRedisChannel.End();
		m_kGlobalRedisChannel.UnitRedis();

		m_kMonitorRedisChannel.End();
		m_kMonitorRedisChannel.UnitRedis();

		m_kRedisChannel.End();
		m_kRedisChannel.UnitRedis();
	}

	{
		m_kGlobalRedisHandler.Unit();
		m_kRedisHandler.Unit();
	}

	{
		m_kTextFilterChannel.end();
		m_kTextFilterChannel.Unit();
	}

	{
		m_kAsyHttpClient.end();
		m_kAsyHttpClient.Unit();
	}

	{
		m_kHttpHandler->UnInit();
		T_DELETE_D(m_kHttpHandler);
	}

	if (m_pkSIOManager)
	{
		m_pkSIOManager->stop();
		delete (m_pkSIOManager);
		m_pkSIOManager = NULL;
	}

	UninitMessageChannel();

	m_pkDBServerSession->Disconnect();
	m_pkLoginServerSession->Disconnect();
	m_pkGroupServerSession->Disconnect();
	m_pkMailServerSession->Disconnect();
	m_pkChatServerSession->Disconnect();
	m_pkTradeServerSession->Disconnect();
	m_pkSocietyServerSession->Disconnect();
	m_pkGlobalServerSession->Disconnect();
	
	{
		NW_ServerSessionMap::iterator it = m_kGame2GatewaySessions.begin();
		for (; it!=m_kGame2GatewaySessions.end(); ++it)
		{
			it->second->Disconnect();
		}
		m_kGame2GatewaySessions.clear();
	}
	
	{
		NW_ServerSessionMap::iterator it = m_kGame2GameSessions.begin();
		for (; it!=m_kGame2GameSessions.end(); ++it)
		{
			it->second->Disconnect();
		}
		m_kGame2GameSessions.clear();
	}

	T_SAFE_DELETE(m_pkTranManager);

	m_pkIOCPServer->Shutdown();
	T_SAFE_DELETE(m_pkIOCPServer);

	{
		UT_DirConfig* m_pkDirConfig = UT_DirConfig::GetSingletonPtr();
		m_pkDirConfig ->UnInit();
		T_SAFE_DELETE(m_pkDirConfig);
	}

	m_pkLogicManager->UnInit();
	T_SAFE_DELETE(m_pkLogicManager);

	{
		LC_LogicIDManager* m_pkLogicIDManager = LC_LogicIDManager::GetSingletonPtr();
		m_pkLogicIDManager->UnInit();
		T_SAFE_DELETE(m_pkLogicIDManager);
	}

	{
		SC_ServerScriptInterface* m_pkServerScriptInterface = SC_ServerScriptInterface::GetSingletonPtr();
		m_pkServerScriptInterface->UnInit();
		T_SAFE_DELETE(m_pkServerScriptInterface);
	}

	{
		UT_GameServerLogManager* obj = UT_GameServerLogManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		CAchievementManager* pkMgr = CAchievementManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		CActShopManager* pkMgr = CActShopManager::GetSingletonPtr();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_SystemTitleManager* pkMgr = LC_SystemTitleManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_GuildRandomNameManager* pkMgr = LC_GuildRandomNameManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_ItemAuctionCategoryManager* pkMgr = LC_ItemAuctionCategoryManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		CWildPrincesManager* pkMgr = CWildPrincesManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		CActivityRankRewardMgr* pkMgr = CActivityRankRewardMgr::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_CommonShopManager* pkMgr = LC_ServerShopManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_CommonStatManager* pkMgr = LC_CommonStatManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_SubordinateManager* pkMgr = LC_SubordinateManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_SkillBookManager* pkMgr = LC_SkillBookManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		ScriptAction::SA_ActionManager* pkMgr = ScriptAction::SA_ActionManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_TreasureChestsManager* pkMgr = LC_TreasureChestsManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_OpenAbilityMgr* pkMgr = LC_OpenAbilityMgr::GetSingletonPtr();
		pkMgr->UnInit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_ActorAttributeManager* pkMgr = LC_ActorAttributeManager::GetSingletonPtr();
		pkMgr->UnInit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_VIPCmnManager* pkVIPCmnMgr = LC_VIPCmnManager::GetSingletonPtr();
		pkVIPCmnMgr->UnInit();
		T_SAFE_DELETE(pkVIPCmnMgr);
	}

	{
		LC_PromoterManager* pkPromoterMgr = LC_PromoterManager::GetSingletonPtr();
		pkPromoterMgr->UnInit();
		T_SAFE_DELETE(pkPromoterMgr);
	}

	{
		SK_Factory* m_pkSkillFactory = SK_Factory::GetSingletonPtr();
		m_pkSkillFactory->UnInit();
		T_SAFE_DELETE(m_pkSkillFactory);
	}

	m_pkTaskManager->UnInit();
	T_SAFE_DELETE(m_pkTaskManager);

	{
		SM_StateFactory* m_pkStateFactory = SM_StateFactory::GetSingletonPtr();
		m_pkStateFactory->UnInit();
		T_SAFE_DELETE(m_pkStateFactory);
	}

	{
		SM_ControllerFactory* m_pkControllerFactory = SM_ControllerFactory::GetSingletonPtr();
		m_pkControllerFactory->UnInit();
		T_SAFE_DELETE(m_pkControllerFactory);
	}

	{
		LC_ItemFactoryBase* m_pkItemFactory = LC_ItemFactoryBase::GetSingletonPtr();
		m_pkItemFactory->UnInit();
		T_SAFE_DELETE(m_pkItemFactory);
	}

	m_pkPackEntryFactory->UnInit();
	T_SAFE_DELETE(m_pkPackEntryFactory);

	{
		LC_NPCShopManager* m_pkNPCShopManager = LC_NPCShopManager::GetSingletonPtr();
		m_pkNPCShopManager->UnInit();
		T_SAFE_DELETE(m_pkNPCShopManager);
	}

	{
		LC_NPCTransferManager* m_pkNPCTransferManager = LC_NPCTransferManager::GetSingletonPtr();
		m_pkNPCTransferManager->UnInit();
		T_SAFE_DELETE(m_pkNPCTransferManager);
	}

	{
		LC_LogicMapManager* m_pkLogicMapManager = LC_LogicMapManager::GetSingletonPtr();
		m_pkLogicMapManager->Shutdown();
		T_SAFE_DELETE(m_pkLogicMapManager);
	}

	{
		LC_PackAsset::Uninit();
	}

	{
		CF_ServerCSVManager* m_pkServerCSVManager = CF_ServerCSVManager::GetSingletonPtr();
		if(m_pkServerCSVManager != NULL)
		{
			m_pkServerCSVManager->UnInit();
			T_SAFE_DELETE(m_pkServerCSVManager);
		}
	}

	{
		LC_LogicTriggerManager* m_pkLogicTriggerManager = LC_LogicTriggerManager::GetSingletonPtr();
		m_pkLogicTriggerManager->Shutdown();
		T_SAFE_DELETE(m_pkLogicTriggerManager);
	}

	T_SAFE_DELETE(m_pkGuildRaidDataManager);
	T_SAFE_DELETE(m_pkNetSessionManager);
	T_SAFE_DELETE(m_pkTimeManager);

	T_SAFE_DELETE(m_pkTimerMgr);

	T_SAFE_DELETE(m_pkGameEventManager);

	T_SAFE_DELETE(m_pkSkillEventManager);

	{
		DungeonConfigDataManager* obj = DungeonConfigDataManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		LC_ServerItemFlopManager* obj = LC_ServerItemFlopManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		ItemEffectManage* inst = ItemEffectManage::GetSingletonPtr();
		T_SAFE_DELETE(inst);
	}

	{
		LC_ServerRewardManager* obj = LC_ServerRewardManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}
	{
		SK_SP* obj = SK_SP::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}
	{
		ItemSuitManager* obj = ItemSuitManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}
	{
		LC_CommandParserBase* m_pkCmdParser = LC_CommandParserBase::GetSingletonPtr();
		m_pkCmdParser->UnInit();
		T_SAFE_DELETE(m_pkCmdParser);
	}

	{
		PF_ServerPathManager* obj = PF_ServerPathManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}
	//子弹碰撞数据
	{
		UT_Pick_Manager* obj = UT_Pick_Manager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	T_SAFE_DELETE(m_pkTextManager);
	m_pMapResourceCache->Unit();
	T_SAFE_DELETE(m_pMapResourceCache);
	{
		LC_ServerNPCInteractionManager* obj = (LC_ServerNPCInteractionManager*)LC_ServerNPCInteractionManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		LC_FactionManager* m_pkFactionManager = LC_FactionManager::GetSingletonPtr();
		m_pkFactionManager->UnInit();
		T_SAFE_DELETE(m_pkFactionManager);
	}

	{
		LC_ServerActorOperationManager* obj = (LC_ServerActorOperationManager*)LC_ServerActorOperationManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		LC_ServerGuildManager* obj = LC_ServerGuildManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	{
		LC_ActorFilterManager* m_pkActorFilterManager = LC_ActorFilterManager::GetSingletonPtr();
		m_pkActorFilterManager->UnInit();
		T_SAFE_DELETE(m_pkActorFilterManager);
	}

	{
		LS_LuaStateFactory* m_pkLuaStateFactory = LS_LuaStateFactory::GetSingletonPtr();
		m_pkLuaStateFactory->UnInit();
		T_SAFE_DELETE(m_pkLuaStateFactory);
	}

	//传闻
	{
		LC_RumorManager* obj = LC_RumorManager::GetSingletonPtr();
		T_SAFE_DELETE(obj);
	}

	//NPC召唤物信息
	{
		LC_NPCSummorManager* pkMgr = LC_NPCSummorManager::GetSingletonPtr();
		pkMgr->UnInit();
		T_SAFE_DELETE(pkMgr);
	}

	//资源预警配置
	{
		LC_ResourceAlertManager* pkMgr = LC_ResourceAlertManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LM_LocaleManager* pkMgr = LM_LocaleManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	//Facebook奖励
	{
		LC_FacebookRewardManager* pkMgr = LC_FacebookRewardManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_BoneSouleEffectManager* pkMgr = LC_BoneSouleEffectManager::GetSingletonPtr();
		pkMgr->UnInit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_MillionWeaponManager* pkMgr = LC_MillionWeaponManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}

	{
		LC_GuildLadderManager* pkMgr = LC_GuildLadderManager::GetSingletonPtr();
		pkMgr->Unit();
		T_SAFE_DELETE(pkMgr);
	}
	
	T_SAFE_DELETE(m_pkThirdPlatFormReport);

	m_ServerManager.Uinit();

	ConfigManagerUnInit();

	m_ServerManager.Uinit();

	//rtti
	{
		UT_ClassRegistry * m_pkClassRegistry	= UT_ClassRegistry::GetSingletonPtr();
		T_DELETE_D m_pkClassRegistry;
	}

	m_fSurviveCheckTime = 0.0f;
}
#endif
//-------------------------------------------------------------------------------
NW_ServerSessionMap GameServerApp::GetServerSession(NetSessionType sessiontype)
{
	NW_ServerSessionMap result;
	switch (sessiontype)
	{
	case NST_GAMESERVER_TO_DBSERVER:
		{
			result[m_pkDBServerSession->PeerID()] = m_pkDBServerSession;
			break;
		}
	case NST_GAMESERVER_TO_LOGINSERVER:
		{
			result[m_pkLoginServerSession->PeerID()] = m_pkLoginServerSession;
			break;
		}
	case NST_GAMESERVER_TO_GROUPSERVER:
		{
			result[m_pkGroupServerSession->PeerID()] = m_pkGroupServerSession;
			break;
		}
	case NST_GAMESERVER_TO_MAILSERVER:
		{
			result[m_pkMailServerSession->PeerID()] = m_pkMailServerSession;
			break;
		}
	case NST_GAMESERVER_TO_CHATSERVER:
		{
			result[m_pkChatServerSession->PeerID()] = m_pkChatServerSession;
			break;
		}
	case NST_GAMESERVER_TO_GAMESERVER:
		{
			TRANSFER_CONTAINER_DATAS(NW_ServerSessionMap, m_kGame2GameSessions, result, insert);
			break;
		}
	case NST_GAMESERVER_TO_GATEWAY:
		{
			TRANSFER_CONTAINER_DATAS(NW_ServerSessionMap, m_kGame2GatewaySessions, result, insert);
			break;
		}
	case NST_GAMESERVER_TO_TRADESERVER:
		{
			result[m_pkTradeServerSession->PeerID()] = m_pkTradeServerSession;
			break;
		}
	case NST_GAMESERVER_TO_SOCIETYSERVER:
		{
			result[m_pkSocietyServerSession->PeerID()] = m_pkSocietyServerSession;
			break;
		}
	case NST_GAMESERVER_TO_GLOBALSERVER:
		{
			result[m_pkGlobalServerSession->PeerID()] = m_pkGlobalServerSession;
			break;
		}
	default:
		break;
	}
	return result;
}
const std::string& GameServerApp::GetRedisEntryServerPredix(void) 
{
	return m_sRedisEntryServerPrefix;
}

void GameServerApp::SetRedisEntryServerPredix(int entryServerID) 
{
	m_bInitEntryServer = true;
	m_sRedisEntryServerPrefix = Utility::RedisServerPrefix(m_server_union_info_.union_id, m_server_union_info_.group_id, entryServerID);
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "SetRedisEntryServerPredix m_sRedisEntryServerPrefix:%s\n",m_sRedisEntryServerPrefix.c_str());
}

bool GameServerApp::GetInitEntryServeState()
{
	return m_bInitEntryServer;
}

std::string GameServerApp::GetRedisServerPredix(int32_t iServerID)
{
	return Utility::RedisServerPrefix(m_server_union_info_.union_id, m_server_union_info_.group_id, iServerID);
}
const std::string& GameServerApp::GetRedisPrefix(int32_t iSphereType)
{
	switch(iSphereType)
	{
	case INF_SPH_TP_SERVER:
		return m_sRedisServerPrefix;
		break;
	case INF_SPH_TP_GROUP:
		return m_sRedisGroupPrefix;
		break;
	case INF_SPH_TP_UNION:
		return m_sRedisGlobalPrefix;
		break;
	default:
		break;
	}
	static std::string null_prefix;
	return null_prefix;
}
Utility::Redis_Handler* GameServerApp::GetRedisHandler(int32_t iSphereType)
{
	switch(iSphereType)
	{
	case INF_SPH_TP_SERVER:
	case INF_SPH_TP_GROUP:
		return &m_kRedisHandler;
		break;
	case INF_SPH_TP_UNION:
		return &m_kGlobalRedisHandler;
		break;
	default:
		break;
	}
	return NULL;
}
Utility::Redis_Channel* GameServerApp::GetRedisChannel(int32_t iSphereType)
{
	switch(iSphereType)
	{
	case INF_SPH_TP_SERVER:
	case INF_SPH_TP_GROUP:
		return &m_kRedisChannel;
		break;
	case INF_SPH_TP_UNION:
		return &m_kGlobalRedisChannel;
		break;
	default:
		break;
	}
	return NULL;
}

void TimerMgr_Update_SEH_shell(Utility::UT_TimerManager* pMgr)
{
//#ifdef WIN32
#if 0
	__try
	{
		pMgr->Update();
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pMgr->Update();
#endif
}

void GameEventManager_Update_SEH_shell(GameLogic::LC_GameEventManager* pMgr,  float fCurrentTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		pMgr->DispatchGameEvent(fCurrentTime);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pMgr->DispatchGameEvent(fCurrentTime);
#endif
}

void LogicMgr_Update_SEH_shell(LC_ServerLogicManager* m_pkLogicManager, Utility::UT_TimeManager*	 m_pkTimeManager, float fCurrentTime, float fDeltaTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		m_pkLogicManager->Update(fCurrentTime, fDeltaTime, m_pkTimeManager);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	m_pkLogicManager->Update(fCurrentTime, fDeltaTime, m_pkTimeManager);
#endif
}

void SkillEventMgr_Update_SEH_shell(SK_SkillEventManagerBase* pManager, Utility::UT_TimeManager*	 m_pkTimeManager, float fCurrentTime, float fDeltaTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager->Update(fCurrentTime, fDeltaTime);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager->Update(fCurrentTime, fDeltaTime);
#endif
}

void TranManager_Update_SEH_shell(TS_TranManager* pManager)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager->Update();
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager->Update();
#endif
}

void TextManager_Update_SEH_shell(TT_TextManager* pManager, float fCurrent)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager->Update(fCurrent);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager->Update(fCurrent);
#endif
}

void TextFilterChannel_Update_SEH_shell(TextFilterChannel& pManager, float fCurrentTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager.Update(fCurrentTime);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager.Update(fCurrentTime);
#endif
}

void DailyDataReport_Update_SEH_shell(LC_DailyDataReport& pManager, float fCurrentTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager.Update(fCurrentTime);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager.Update(fCurrentTime);
#endif
}

void TaskManager_Update_SEH_shell(GameLogic::LC_TaskManager* pManager, float fCurrentTime, float fDeltaTime)
{
//#ifdef WIN32
#if 0
	__try
	{
		pManager->Update(fCurrentTime, fDeltaTime);
	}
	__except(CrashHandler(GetExceptionInformation()))
	{
	}
#else
	pManager->Update(fCurrentTime, fDeltaTime);
#endif
}

//--------------------------------------------------
void GameServerApp::Update()
{
	UT_SERVER_PROFILE(kProfile, "Main Loop", 0.1f);
	m_pkTimerMgr->Tick();
	m_pkTimeManager->Tick();
	float fCurrentTime = m_pkTimeManager->GetProcessTime();
	float fCurrentTime1 = fCurrentTime;

	//收发消息
	if (m_pkIOCPServer)
	{
		m_pkIOCPServer->Update();
	}

	if(GetInitEntryServeState())
	{
		UT_ServerHelper::InitCSV();

		UT_ServerHelper::LoadServerFirstKillBossInfo();
		UT_ServerHelper::SettleYiZhongQinXiGameStory();
		UT_ServerHelper::SettleAnswer(true);
		UT_ServerHelper::CreateLimitActivity();
		UT_ServerHelper::CreateLimitActivityB();
		UT_ServerHelper::SettleSubB();
		UT_ServerHelper::InitBestGuildInfo();
		UT_ServerHelper::SettleBestGuildReward();
		UT_ServerHelper::SettleBestGuildActivityReward();
		UT_ServerHelper::InitRegularBossKillerInfo();

		UT_ServerHelper::SettleYiJiTuXi(true);

		UT_ServerHelper::ApplySendReward();
		UT_ServerHelper::EraseSendRewardCache();
		
		UT_ServerHelper::UpdateWatchTowerInfoCacheToRedis();

		UT_ServerHelper::UpdateMail();

		UT_ServerHelper::LoadGuildMapBossInfo();

		if(IsServerConnect(SERVER_TYPE_GROUP))
		{
			UT_ServerHelper::SendGuildPresentExpInfoToSociety();
			UT_ServerHelper::TryExportRobotToGroup();
		}

		if(IsServerConnect(SERVER_TYPE_MAIL_DB))
		{
			UT_ServerHelper::CheckSettleHuanJingDamage();
			UT_ServerHelper::RankReward(Rank_Type_FinishMainTaskID, true);
		}

		if(IsServerConnect(SERVER_TYPE_SOCIETY) && IsServerConnect(SERVER_TYPE_MAIL_DB))
		{
			UT_ServerHelper::SendMailMsgToSociety();
		}

	}
	//收发消息
	if (m_pkSIOManager)
	{
		m_pkSIOManager->update();
	}

	if (m_pkTranManager)
	{
		//m_pkTranManager->Update();
		TranManager_Update_SEH_shell(m_pkTranManager);
	}

	

	//REDIS CAHNEL
	m_kRedisChannel.Update(fCurrentTime);

	//GLOBAL REDIS CAHNEL
	m_kGlobalRedisChannel.Update(fCurrentTime);

	//CHAT CHANNEL
	//m_kTextFilterChannel.Update(fCurrentTime);
	TextFilterChannel_Update_SEH_shell(m_kTextFilterChannel, fCurrentTime);

	//ASY HTTP
	m_kAsyHttpClient.Update();
	
	//DATA RECORD
	//m_kDailyDataReport.Update(fCurrentTime);
	DailyDataReport_Update_SEH_shell(m_kDailyDataReport, fCurrentTime);

	//Sync preday active
	if (!m_bSyncActiveSucceed)
	{
		SyncPredayActive(fCurrentTime);
	}

	if (m_pkTextManager)
	{
		//m_pkTextManager->Update(fCurrentTime);
		TextManager_Update_SEH_shell(m_pkTextManager, fCurrentTime);
	}
	m_pkTimeManager->Tick();
	float fCurrentTime2 = m_pkTimeManager->GetProcessTime();

	float fDeltaTime = fCurrentTime - m_fGameEventUpdateTime;
	//if(fDeltaTime > 0.25)
	{
		m_fGameEventUpdateTime = fCurrentTime;
		if (m_pkGameEventManager)
		{
			//m_pkGameEventManager->DispatchGameEvent(fCurrentTime);
			GameEventManager_Update_SEH_shell(m_pkGameEventManager, fCurrentTime);
		}
	}
	m_pkTimeManager->Tick();
	float fCurrentTime3 = m_pkTimeManager->GetProcessTime();

	fDeltaTime = fCurrentTime - m_fSkillEventUpdateTime;
	//if (fDeltaTime > 0.25)
	{
		m_fSkillEventUpdateTime = fCurrentTime;
		if (NULL != m_pkSkillEventManager)
		{
			//((SK_ServerSkillEventManager*)m_pkSkillEventManager)->Update(fCurrentTime, fDeltaTime);
			SkillEventMgr_Update_SEH_shell(m_pkSkillEventManager, m_pkTimeManager, fCurrentTime, fDeltaTime);
		}
	}
	m_pkTimeManager->Tick();
	float fCurrentTime4 = m_pkTimeManager->GetProcessTime();

	fDeltaTime = fCurrentTime - m_fTaskUpdateTime;
	if (fDeltaTime > 0.15)
	{
		m_fTaskUpdateTime = fCurrentTime;
		if (m_pkTaskManager)
			//m_pkTaskManager->Update(fCurrentTime, fDeltaTime);
			TaskManager_Update_SEH_shell(m_pkTaskManager, fCurrentTime, fDeltaTime);
	}

	fDeltaTime = fCurrentTime - m_fLastLogicUpdateTime;
	if (fDeltaTime > 0.05f)
	{
		m_fLastLogicUpdateTime = fCurrentTime;
		if (m_pkLogicManager)
		{
			//m_pkLogicManager->Update(fCurrentTime, fDeltaTime, m_pkTimeManager);
			LogicMgr_Update_SEH_shell(m_pkLogicManager, m_pkTimeManager, fCurrentTime, fDeltaTime);
		}
		Message2Client(fCurrentTime);
	}

	m_pkTimeManager->Tick();
	float fCurrentTime5 = m_pkTimeManager->GetProcessTime();
	if(m_pkTimerMgr)
	{
		//UT_SERVER_PROFILE(kProfile, "UT_TimerManager::Update",0.002f);
		//m_pkTimerMgr->Update();
		TimerMgr_Update_SEH_shell(m_pkTimerMgr);
	}

	m_pkTimeManager->Tick();
	float fCurrentTime6 = m_pkTimeManager->GetProcessTime();

	//Message2Client(fCurrentTime);
	//每10秒发一个心跳包
	fDeltaTime = fCurrentTime - m_fLastDBServerSessionUpdateTime;
	if (fDeltaTime > 10.0f)
	{
		m_fLastDBServerSessionUpdateTime = fCurrentTime;
		if (m_pkNetSessionManager)
		{
			m_pkNetSessionManager->Update(fCurrentTime, fDeltaTime);
		}
		if(IsServerConnect(SERVER_TYPE_DB)&&IsServerConnect(SERVER_TYPE_SOCIETY)&&IsServerConnect(SERVER_TYPE_MAIL_DB))
		{
			UT_ServerHelper::UpdateCacheRankOpen();
			UT_ServerHelper::UpdateRankOpenInfo();
		}
	}

	m_pkTimeManager->Tick();
	float fCurrentTime7 = m_pkTimeManager->GetProcessTime();

	//每5秒发一次玩家数量
	fDeltaTime = fCurrentTime - m_fLastLoginServerSessionUpdateTime;
	if (fDeltaTime > 30.0f)
	{
		m_fLastLoginServerSessionUpdateTime = fCurrentTime;
		SendServerInfo(SERVER_TYPE_LOGIN);
		//SendServerInfoToGroupSvr();
	}

	LC_ServerShopManager::GetSingletonPtr()->Tick((uint32_t)fCurrentTime);

	Utility::UT_GMLogic* pGMLogic = Utility::UT_GMLogic::GetSingletonPtr();
	fDeltaTime = fCurrentTime - m_fLastGMLogicUpdateTime;
	if ( fDeltaTime > GM_LOGUC_UPDATE_TIMER )
	{
		m_fLastGMLogicUpdateTime = fCurrentTime;
		pGMLogic->Update( fCurrentTime, fDeltaTime );
	}

	m_pkTimeManager->Tick();
	float fCurrentTime8 = m_pkTimeManager->GetProcessTime();

	fDeltaTime = fCurrentTime - m_fLastNetDataOutputSaveTime;
	if (fDeltaTime > 60.0f)
	{
		m_fLastNetDataOutputSaveTime = fCurrentTime;
		if (m_pkLogicManager)
		{
			//m_messageRecorder.Output(m_pkLogicManager->GetPlayerIDCount());
		}
		m_messageRecorder.Clear();
		dump_packet_process_info();
	}
	//公会管理器更新
	LC_ServerGuildManager* manager = LC_ServerGuildManager::GetSingletonPtr();
	if (manager != NULL)
	{
		manager->Update(fCurrentTime, fDeltaTime);
	}
	
	//进程僵死Tick
	publishSurviveByRedis();

	//ServerManager更新
	m_ServerManager.Update(fCurrentTime);

	m_pkTimeManager->Tick();
	float endTime = m_pkTimeManager->GetProcessTime();

	LS_LuaStateFactory::GetSingletonPtr()->Update( fCurrentTime, fDeltaTime );
	if (endTime - fCurrentTime1 > 0.1f)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "GameServerApp::Update [%f] seconds！	%f,%f,%f,%f,%f,%f,%f", endTime - fCurrentTime1
					, fCurrentTime2 - fCurrentTime1, fCurrentTime3 - fCurrentTime2, fCurrentTime4 - fCurrentTime3, fCurrentTime5 - fCurrentTime4
					, fCurrentTime6 - fCurrentTime5, fCurrentTime7 - fCurrentTime6, fCurrentTime8 - fCurrentTime7);
	}

#ifdef WIN32
	g_ProceMemDetecter.Update(fCurrentTime);
#endif
	m_ExportRobot->Update(fCurrentTime);

	//< 统计信息
	Memory::UT_ObjectStatistics::GetSingleton().Update(fCurrentTime, fDeltaTime);
}

//--------------------------------------------------
void GameServerApp::Save2Exit()
{

}

//--------------------------------------------------
struct ServerSurviveNode
{
	uint32_t type;
	uint32_t id;
	uint64_t time;
	uint32_t pid;
};
AJSON(ServerSurviveNode, (type)(id)(time)(pid))
//--------------------------------------------------
void GameServerApp::publishSurviveByRedis()
{
	float fCurrentTime = m_pkTimeManager->GetProcessTime();
	if(fCurrentTime > m_fSurviveCheckTime && fCurrentTime - m_fSurviveCheckTime >= 5.0f)		//5秒钟的间隔
	{
		json_op<ServerSurviveNode> json_resp;
		ServerSurviveNode& node = json_resp.json;
		node.type = m_kServerInfo.m_iType;
		node.id = m_kServerInfo.m_iServerID;
		node.time = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		node.pid = m_uServerPid;
		ASYNC_REDIS_REQUEST_NCB(m_kRedisChannel, &redispp::Connection::publish, m_sSurviveCheckChanel, json_resp);

		m_fSurviveCheckTime = fCurrentTime;
	}
}
void GameServerApp::AddGameServer(NW_ServerSession* pkGameSession)
{
	if (NULL == pkGameSession)
	{
		return;
	}
	m_kGame2GameSessions[pkGameSession->GetServerInfo().m_iServerID] = pkGameSession;
}
NW_ServerSession* GameServerApp::RegisterGameServer(Protocol::PS_ServerInfo& rkServer)
{
	if (rkServer.m_iType != SERVER_TYPE_GAME)
	{
		return NULL;
	}

	NW_ServerSession* session = GetSession(rkServer.m_iType, rkServer.m_iServerID);
	//如果不存在  直接创建
	if (NULL == session)
	{	
		session = CreateServerSession(NST_GAMESERVER_TO_GAMESERVER, rkServer);
		if (session)
		{
			m_kGame2GameSessions[rkServer.m_iServerID] = session;
		}
	}
	return session;
}
//--------------------------------------------------
void GameServerApp::InitMessage2Client()
{
	m_message2Client = T_NEW_D MC_Message2ClientManager();
	m_message2Client->Init();
}
//--------------------------------------------------
void GameServerApp::UninitMessageChannel()
{
	m_message2Client->Fint();
	T_SAFE_DELETE(m_message2Client);
}
//--------------------------------------------------
void GameServerApp::Message2Client(float currentTime)
{
	if (m_message2Client)
	{
		m_message2Client->Update(currentTime);
	}
}
BOOL GameServerApp::IsServerConnect(int server_type)
{
	switch (server_type)
	{
		case SERVER_TYPE_DB:
			return m_pkDBServerSession->IsConnected();
		case SERVER_TYPE_SOCIETY:
			return m_pkSocietyServerSession->IsConnected();
		case SERVER_TYPE_MAIL_DB:
			return m_pkMailServerSession->IsConnected();
		case SERVER_TYPE_GROUP:
			return m_pkGroupServerSession->IsConnected();
			
	}
	return false;
}
NW_ServerSession* GameServerApp::GetSession(int server_type, int32_t iID)
{
	NW_ServerSession* pkResult = NULL;
	switch (server_type)
	{
	case SERVER_TYPE_GAME:
		{
			NW_ServerSessionMap::iterator it = m_kGame2GameSessions.find(iID);
			//return (it!=m_kGame2GameSessions.end()) ? it->second : NULL;
			pkResult = (it!=m_kGame2GameSessions.end()) ? it->second : NULL;
		}
		break;
	case SERVER_TYPE_DB:
		{
			pkResult = m_pkDBServerSession;
		}
		break;
	case SERVER_TYPE_LOGIN:
		{
			pkResult = m_pkLoginServerSession;
		}
		break;
	case SERVER_TYPE_GROUP:
		{
			pkResult = m_pkGroupServerSession;
		}
		break;
	case SERVER_TYPE_MAIL_DB:
		{
			pkResult = m_pkMailServerSession;
		}
		break;
	case SERVER_TYPE_GATEWAY:
		{
			NW_ServerSessionMap::iterator it = m_kGame2GatewaySessions.find(iID);
			//return (it!=m_kGame2GatewaySessions.end()) ? it->second : NULL;
			pkResult = (it!=m_kGame2GatewaySessions.end()) ? it->second : NULL;
		}
		break;
	case SERVER_TYPE_IM:
		{
			pkResult = m_pkChatServerSession;
		}
		break;
	case SERVER_TYPE_TRADE:
		{
			pkResult = m_pkTradeServerSession;
		}
		break;
	case SERVER_TYPE_SOCIETY:
		{
			pkResult = m_pkSocietyServerSession;
		}
		break;
	case SERVER_TYPE_GLOBAL:
		{
			pkResult = m_pkGlobalServerSession;
		}
		break;
	default:
		{
			GfxWriteFmtLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "unkown server type", server_type);
		}
		break;
	}
	if ( pkResult && pkResult->IsConnected() == false )
		return NULL;
	return pkResult;
}

//----------------------------------------------------------------------------

static inline int gen_server_id(int type, int id)
{
	switch(type)
	{
	case SERVER_TYPE_GAME:
	case SERVER_TYPE_INSTANCE:
		return id;
		break;
	default:
		break;
	}
	return 10000000 + type * 100000 + id;
}

struct server_tcp_config
{
	int			type;
	int			id;
	StringType	ip;
	int			port;
	int			svr_id;

	server_tcp_config(): id(0), ip("0.0.0.0"), port(10000) {}
	void auto_server_id(int itype) { type=itype; svr_id = gen_server_id(itype, id);}
};

AJSON_CODE(server_tcp_config, (id)(ip)(port))
AJSON_CODE(redis_info, (ip)(port)(auth))
AJSON(gm_account, (user)(pwd)(priority))
AJSON_CODE(init_setting, (version)(activation_codes)(gm_accounts)(cmds))
/////////////////////////////////////////////////////////////////////////////////////////////////////
struct game_server_config
{
	game_server_config()
		: game_server_type(3),
		  timeout_second(300000),
		  accept_client_count(2100),
		  allow_client_count(2000),
		  minimum_client_version(0),
		  allow_gm_cmd(0),
		  use_newplayer_map(0),
		  newplayer_per_map(250),
		  group_id(0),
		  union_id(0),
		  log_dir("")
	{
	}

	void auto_server_id(void)
	{
		self.auto_server_id(SERVER_TYPE_GAME);
		login_server.auto_server_id(SERVER_TYPE_LOGIN);
		group_server.auto_server_id(SERVER_TYPE_GROUP);
		chat_server.auto_server_id(SERVER_TYPE_IM);
		game_db_server.auto_server_id(SERVER_TYPE_DB);
		mail_db_server.auto_server_id(SERVER_TYPE_MAIL_DB);
		trade_server.auto_server_id(SERVER_TYPE_TRADE);
		society_server.auto_server_id(SERVER_TYPE_SOCIETY);
		global_server.auto_server_id(SERVER_TYPE_GLOBAL);

		mem::vector<server_tcp_config>::iterator it = gateway_server.begin();
		for (; it != gateway_server.end(); ++it)
		{
			it->auto_server_id(SERVER_TYPE_GATEWAY);
		}
	}

	server_tcp_config	self;

	int		game_server_type;
	int		timeout_second;
	int		accept_client_count;
	int		allow_client_count;
	int		minimum_client_version;
	int		allow_gm_cmd;
	int		use_newplayer_map;
	int		newplayer_per_map;

	server_tcp_config	login_server;
	server_tcp_config	group_server;
	//server_tcp_config	gm_server;
	server_tcp_config	chat_server;
	server_tcp_config	game_db_server;
	server_tcp_config	mail_db_server;
	//server_tcp_config	friend_db_server;
	//server_tcp_config	guild_db_server;
	//server_tcp_config	award_server;
	server_tcp_config	trade_server;
	server_tcp_config	society_server;
	server_tcp_config	global_server;

	mem::vector<server_tcp_config>	gateway_server;
	mem::vector<StringType>	oss_filter;
	mem::vector<redis_info> local_rediss;
	mem::vector<redis_info> monitor_rediss;
	redis_info              global_redis;

	StringType	oss_log_server_ip;

	int         group_id;			//大区id
	StringType	group_name;			//大区名字
	int			union_id;			//联运商id
	StringType	union_name;			//联运商名称
	StringType	log_dir;			//日志目录
	init_setting init_set;

	std::string	act_360_privi_url;	//360特权活动URL
	std::string server_list_prefix;	//redis server list 前缀

};

AJSON_CODE(game_server_config, (self)(game_server_type)(timeout_second)(accept_client_count)(allow_client_count)(minimum_client_version)(use_newplayer_map)
	  (newplayer_per_map)(login_server)(group_server)(chat_server)(game_db_server)(mail_db_server)(allow_gm_cmd)
	  (trade_server)(society_server)(global_server)(gateway_server)(oss_filter)(local_rediss)(monitor_rediss)(global_redis)
	  (group_id)(group_name)(union_id)(union_name)(oss_log_server_ip)(init_set)(log_dir)(act_360_privi_url)(server_list_prefix))

/////////////////////////////////////////////////////////////////////////////////////////////////////
void fill_server_info(Protocol::PS_ServerInfo& sinfo , server_tcp_config& stc)
{
	sinfo.m_iType = stc.type;
	sinfo.m_iServerID = stc.svr_id;
	TPSTR2STDSTR(stc.ip, sinfo.m_szIP);
	sinfo.m_iPort = stc.port;
}

BOOL GameServerApp::LoadServerConfig(void)
{
	game_server_config gsc;
	StringType error_string;
	StringType strPath = m_strConfigPath + "Server.json";
	if (!boost::ajson::load_from_file(gsc, const_cast<char*>(strPath.c_str()), error_string))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[error]: load server.json file error:%s.\n", error_string.c_str());
		return FALSE;
	}

	gsc.auto_server_id();

	int32_t nServerIdFromArgv = GetGameServerApp()->GetServerManager()->GetServerIdFromArgv();
	if ( nServerIdFromArgv != -1 )
	{
		gsc.self.id = nServerIdFromArgv;
		gsc.self.svr_id = nServerIdFromArgv;
	}

	fill_server_info(m_kServerInfo, gsc.self);
	m_kServerInfo.m_iType = gsc.game_server_type;
	SetServerEntryId(m_kServerInfo.m_iServerID);	// 默认与GS id相同

	m_iGameServerTimeOut	 = gsc.timeout_second;
	m_iGameServerAcceptCount =  gsc.accept_client_count;
	m_kServerInfo.m_iWaitCount = gsc.allow_client_count;

	m_iClientVersionLimit = GAME_VERSION();

	m_allow_gm_cmd = (0 < gsc.allow_gm_cmd);

	GfxWriteLog(LOG_SYSTEM_FILELINE, LOG_SWITCH_SYSTEM, "start GameServer :  %s  ID: %d TimeOut: %d AcceptCount: %d\n", m_kServerInfo.m_szName.c_str(), m_kServerInfo.m_iServerID, m_iGameServerTimeOut, m_iGameServerAcceptCount);

	m_kServerInfo.m_iCapacity = m_iGameServerAcceptCount;

	fill_server_info(m_kDBServerInfo, gsc.game_db_server);
	fill_server_info(m_kLoginServerInfo, gsc.login_server);
	fill_server_info(m_kGroupServerInfo, gsc.group_server);
	fill_server_info(m_kChatServerInfo, gsc.chat_server);
	fill_server_info(m_kMailServerInfo, gsc.mail_db_server);
	fill_server_info(m_kTradeServerInfo, gsc.trade_server);
	fill_server_info(m_kSocietyServerInfo, gsc.society_server);
	fill_server_info(m_kGlobalServerInfo, gsc.global_server);

	server_union_info& info = GetServerUnionInfo();
	info.group_id = gsc.group_id;
	info.group_name = gsc.group_name;
	info.union_id = gsc.union_id;
	info.union_name = gsc.union_name;

	for (std::size_t i = 0; i < gsc.gateway_server.size(); ++i)
	{
		PS_ServerInfo kGatewayInfo;
		fill_server_info(kGatewayInfo, gsc.gateway_server[i]);
		m_gatewayInfos.push_back(kGatewayInfo);
	}

	for (std::size_t i = 0; i < gsc.local_rediss.size(); ++i)
	{
		struct hostent * pHost = NULL;
		pHost = gethostbyname( gsc.local_rediss[i].ip.c_str() );
		char* szIPAddr = NULL;
		szIPAddr  = inet_ntoa( *(struct in_addr*)pHost->h_addr_list[0] );
		gsc.local_rediss[i].ip = szIPAddr;
		m_kLocalRediss.push_back(gsc.local_rediss[i]);
	}

	for (std::size_t i = 0; i < gsc.monitor_rediss.size(); ++i)
	{
		struct hostent * pHost = NULL;
		pHost = gethostbyname( gsc.monitor_rediss[i].ip.c_str() );
		char* szIPAddr = NULL;
		szIPAddr  = inet_ntoa( *(struct in_addr*)pHost->h_addr_list[0] );
		gsc.monitor_rediss[i].ip = szIPAddr;
		m_kMonitorRediss.push_back(gsc.monitor_rediss[i]);
	}

	struct hostent * pHost = NULL;
	pHost = gethostbyname( gsc.global_redis.ip.c_str() );
	char* szIPAddr = NULL;
	szIPAddr  = inet_ntoa( *(struct in_addr*)pHost->h_addr_list[0] );
	gsc.global_redis.ip = szIPAddr;
	m_kGlobalRedis = gsc.global_redis;

	for (std::size_t i = 0; i < gsc.oss_filter.size(); ++i)
	{
		oss::disable_oss(gsc.oss_filter[i]);
	}

	if (gsc.oss_log_server_ip.length())
	{
		init_syslog(gsc.oss_log_server_ip.c_str());
	}
	else
	{
		init_syslog("127.0.0.1");
	}

	m_bBranchNode = IS_GAME_BRANCH_NODE(m_kServerInfo.m_szIP.c_str(), m_kServerInfo.m_iPort);
	//新手分流配置
	m_bUseNewPlayerMap		= true;
	m_iNewPlayerCountPerMap = 100;

	m_sRedisGlobalPrefix	= Utility::RedisGlobalPrefix(m_server_union_info_.union_id);
	m_sRedisGroupPrefix		= Utility::RedisGroupPrefix(m_server_union_info_.union_id, m_server_union_info_.group_id);
	m_sRedisServerPrefix	= Utility::RedisServerPrefix(m_server_union_info_.union_id, m_server_union_info_.group_id, m_kServerInfo.m_iServerID);

	m_initSetting			= gsc.init_set;

	if(gsc.log_dir.length() > 0 && (m_strLogPath.length() <= 0 || m_strLogPath == "./log/"))
	{
		m_strLogPath		= gsc.log_dir;
	}

	if (gsc.act_360_privi_url.length() > 0)
	{
		m_strAct360PriviUrl = gsc.act_360_privi_url;
	}

	if (gsc.server_list_prefix.empty())
	{
		m_strServerListPrefix = m_sRedisGroupPrefix;
	}
	else
	{
		m_strServerListPrefix = gsc.server_list_prefix;
	}
	return TRUE;
}
void GameServerApp::SetMsgHead(uint16_t usMsgType, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence, uint8_t cDstType, int32_t iDstID, int32_t iReserved)
{
	if(iSequence == 0)
	{
		iSequence = uiCharID.catagory();
	}
	m_kMsgHead.Clear();
	m_kMsgHead.m_usMsgType	= usMsgType;
	m_kMsgHead.m_cSrcType	= m_kServerInfo.m_iType;
	m_kMsgHead.m_iSrcID		= m_kServerInfo.m_iServerID;
	m_kMsgHead.m_cDstType	= cDstType;
	m_kMsgHead.m_iDstID		= iDstID;
	m_kMsgHead.m_iSequence	= iSequence;
	m_kMsgHead.m_uiUserID	= uiUserID;
	m_kMsgHead.m_uiCharID	= uiCharID;
	m_kMsgHead.m_iReserved	= iReserved;
}

void GameServerApp::SetMsgHeadToClient(uint16_t usMsgType, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence, uint8_t cDstType, int32_t iDstID)
{
	m_kMsgHead.Clear();

	m_kMsgHead.m_usMsgType	= usMsgType;
	m_kMsgHead.m_cSrcType	=  m_kServerInfo.m_iType;;
	m_kMsgHead.m_iSrcID		= m_kServerInfo.m_iServerID;
	m_kMsgHead.m_cDstType	= SERVER_TYPE_CLIENT;
	m_kMsgHead.m_iDstID		= uiUserID;
	m_kMsgHead.m_uiUserID	= uiUserID;
	m_kMsgHead.m_uiCharID	= uiCharID;
	m_kMsgHead.SetRouterFlag();
	m_kMsgHead.m_iReserved = iDstID;
}

void GameServerApp::SetMulticastMsgHead(uint16_t usMsgType)
{
	m_kMsgHead.Clear();

	m_kMsgHead.m_usMsgType	= usMsgType;
	m_kMsgHead.m_cSrcType	= m_kServerInfo.m_iType;;
	m_kMsgHead.m_iSrcID		= m_kServerInfo.m_iServerID;
	m_kMsgHead.m_cDstType	= SERVER_TYPE_CLIENT;
	m_kMsgHead.SetMulticastFlag();
}

void GameServerApp::SetBroadcastMsgHead(uint16_t usMsgType)
{
	m_kMsgHead.Clear();

	m_kMsgHead.m_usMsgType	= usMsgType;
	m_kMsgHead.m_cSrcType	= m_kServerInfo.m_iType;;
	m_kMsgHead.m_iSrcID		= m_kServerInfo.m_iServerID;
	m_kMsgHead.m_cDstType	= SERVER_TYPE_CLIENT;
	m_kMsgHead.SetBroadcastFlag();
}
BOOL GameServerApp::SendMsgToServerType(Protocol::SS_MG_HEAD& rkMsgHead, Protocol::MG_BODY* pkMsgBody)
{
	if (m_kPakcetHandler.EncodeSSMsg(rkMsgHead, pkMsgBody))
	{
		NW_NetSessionBase* session = GetSession(rkMsgHead.m_cDstType, rkMsgHead.m_iDstID);
		if (session)
		{
			return session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return FALSE;
}
BOOL GameServerApp::SendMsgToServerType(Protocol::SS_MG_HEAD& rkMsgHead, const char* msg_body, uint16_t body_size)
{
	if (m_kPakcetHandler.EncodeSSMsg(rkMsgHead, msg_body, body_size))
	{
		NW_NetSessionBase* session = GetSession(rkMsgHead.m_cDstType, rkMsgHead.m_iDstID);
		if (session)
		{
			return session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return FALSE;
}

BOOL GameServerApp::SendMsgToServerType(MG_SERVER_TYPES server_type, int32_t iID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence, int32_t iReserved, uint16_t nRouteFlag)
{
	NW_ServerSession* info = GetSession(server_type, iID);
	if (info)
	{
		SetMsgHead(usMsgType, uiUserID, uiCharID, iSequence, server_type, info->PeerID(), iReserved);
		switch(nRouteFlag)
		{
		case MG_SERVER_ROUTER_FLAG_SINGLE:
			{
				m_kMsgHead.SetRouterGSingleFlag();
			}
			break;
		case MG_SERVER_ROUTER_FLAG_GROUP:
			{
				m_kMsgHead.SetRouterGGroupFlag();
			}
			break;
		case MG_SERVER_ROUTER_FLAG_CLIENT:
			{
				m_kMsgHead.SetRouterGClientFlag();
			}
			break;
		default:
			break;
		}
		return SendMsgToServerType(m_kMsgHead, pkMsgBody);
	}
	return false;
}

BOOL GameServerApp::SendMsgToServerType(MG_SERVER_TYPES server_type, int32_t iID , uint16_t usMsgType, const char* pMsg, uint16_t nSize, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence, int32_t iReserved, uint16_t nRouteFlag)
{
	NW_ServerSession* info = GetSession(server_type, iID);
	if (info)
	{
		SetMsgHead(usMsgType, uiUserID, uiCharID, iSequence, server_type, info->PeerID(), iReserved);
		switch(nRouteFlag)
		{
		case MG_SERVER_ROUTER_FLAG_SINGLE:
			{
				m_kMsgHead.SetRouterGSingleFlag();
			}
			break;
		case MG_SERVER_ROUTER_FLAG_GROUP:
			{
				m_kMsgHead.SetRouterGGroupFlag();
			}
			break;
		case MG_SERVER_ROUTER_FLAG_CLIENT:
			{
				m_kMsgHead.SetRouterGClientFlag();
			}
			break;
		default:
			break;
		}
		return SendMsgToServerType(m_kMsgHead, pMsg, nSize);
	}
	return false;
}

BOOL GameServerApp::SendMsgToServerByGateway(int32_t iID, uint8_t serverType, uint32_t serverID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence)
{
	BOOL rtn = FALSE;
	SetMsgHead(usMsgType, uiUserID, uiCharID, iSequence, serverType, serverID);
	m_kMsgHead.SetRouterFlag();

	if (m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, pkMsgBody))
	{
		NW_NetSessionBase* session = GetSession(SERVER_TYPE_GATEWAY, iID);
		if ((session))
		{
			rtn = session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return rtn;
}

BOOL GameServerApp::SendMsgToClientByGateway(int32_t iID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence)
{
	BOOL rtn = FALSE;
	SetMsgHeadToClient(usMsgType, uiUserID, uiCharID, iSequence, SERVER_TYPE_GATEWAY, iID);
	if ( false == m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, pkMsgBody))
		return rtn;
	// transcribe fight 战斗录制
	if( true == GameLogic::LC_Helper::_CheckArenaRecordByType(usMsgType))
		GameLogic::LC_Helper::makeTranscribeFightMsg(usMsgType, pkMsgBody,  uiUserID,m_pkTimeManager->GetProcessTime());
	NW_NetSessionBase* session = GetSession(SERVER_TYPE_GATEWAY, iID);
	if( NULL  == session )
		return rtn;
	record_send_packet(usMsgType, m_kPakcetHandler.GetMsgSize());
	
	rtn = session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
	return rtn;
}

BOOL GameServerApp::SendMsgFightTranscribeRecord(int32_t iID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence)
{
	BOOL rtn = FALSE;
	SetMsgHeadToClient(usMsgType, uiUserID, uiCharID, iSequence, SERVER_TYPE_GATEWAY, iID);
	if ( false == m_kPakcetHandler_1.EncodeSSMsg(m_kMsgHead_1, pkMsgBody))
		return rtn;
	// transcribe fight 战斗录制
	if( true == GameLogic::LC_Helper::_CheckArenaRecordByType(usMsgType))
		GameLogic::LC_Helper::makeTranscribeFightMsg(usMsgType, pkMsgBody,  uiUserID,m_pkTimeManager->GetProcessTime());
	return rtn;
}

BOOL GameServerApp::SendMsgToClientByGateway(int32_t iID, uint16_t usMsgType, const char* pMsg, uint16_t nSize, uint32_t uiUserID, const unique_id_impl& uiCharID, int32_t iSequence)
{
	BOOL rtn = FALSE;
	SetMsgHeadToClient(usMsgType, uiUserID, uiCharID, iSequence, SERVER_TYPE_GATEWAY, iID);
	if (m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, pMsg, nSize))
	{
		NW_NetSessionBase* session = GetSession(SERVER_TYPE_GATEWAY, iID);
		if ((session))
		{
			record_send_packet(usMsgType, m_kPakcetHandler.GetMsgSize());
			rtn = session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return rtn;
}



BOOL GameServerApp::MulticastMsgByGame(int32_t iID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody)
{
	BOOL rtn = TRUE;
	SetMulticastMsgHead(usMsgType);
	if (m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, pkMsgBody))
	{
		NW_NetSessionBase* session = GetSession(SERVER_TYPE_GAME, iID);
		if ((session))
		{
			record_send_packet(usMsgType, m_kPakcetHandler.GetMsgSize());
			rtn = session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return rtn;
}

BOOL GameServerApp::MulticastMsgToGateway(int32_t iID, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody)
{
	BOOL rtn = TRUE;
	SetMulticastMsgHead(usMsgType);
	if (m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, pkMsgBody))
	{
		NW_NetSessionBase* session = GetSession(SERVER_TYPE_GATEWAY, iID);
		if ((session))
		{
			record_send_packet(usMsgType, m_kPakcetHandler.GetMsgSize());
			rtn = session->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	return rtn;
}

BOOL GameServerApp::MulticastMsgToGateway(LC_PlayerPtrList& playerList, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, LC_PlayerOperator* pkFilter)
{
	if (playerList.empty())
	{
		return TRUE;
	}

	BOOL rtn = FALSE;
	do 
	{
		if (!m_multiMsgHelper.Begin(usMsgType, pkFilter))
		{
			break;
		}
		if (!m_multiMsgHelper.Encode(pkMsgBody))
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[error]: MulticastMsgToGateway Encode Fail!:%u.\n", usMsgType);
			break;
		}
		for (LC_PlayerPtrList::iterator it = playerList.begin(); it != playerList.end(); ++it)
		{
			LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)*it;
			m_multiMsgHelper.AddUserIndices(pkPlayer);
			
			// transcribe fight 战斗录制
			if( true == GameLogic::LC_Helper::_CheckArenaRecordByType(usMsgType))
				GameLogic::LC_Helper::makeTranscribeFightMsg(usMsgType, pkMsgBody, pkPlayer->GetUserID(),m_pkTimeManager->GetProcessTime());
		}
		rtn = m_multiMsgHelper.End();
	} while (0);

	return rtn;
}

BOOL GameServerApp::MulticastMsgToGateway(const LC_PlayerIDPtrMap& playerList, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, LC_PlayerOperator* pkFilter)
{
	if (playerList.empty())
	{
		return TRUE;
	}

	BOOL rtn = FALSE;
	do 
	{
		if (!m_multiMsgHelper.Begin(usMsgType, pkFilter))
		{
			break;
		}
		if (!m_multiMsgHelper.Encode(pkMsgBody))
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[error]: MulticastMsgToGateway Encode Fail!:%u.\n", usMsgType);
			break;
		}
		for (LC_PlayerIDPtrMap::const_iterator cit = playerList.begin(); cit != playerList.end(); ++cit)
		{
			LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)cit->second;
			m_multiMsgHelper.AddUserIndices(pkPlayer);
			// transcribe fight 战斗录制
			if( true == GameLogic::LC_Helper::_CheckArenaRecordByType(usMsgType))
				GameLogic::LC_Helper::makeTranscribeFightMsg(usMsgType, pkMsgBody, pkPlayer->GetUserID(),m_pkTimeManager->GetProcessTime());
		}
		rtn = m_multiMsgHelper.End();
	} while (0);

	return rtn;
}

BOOL GameServerApp::MulticastMsgToGateway(mem::vector<const GameLogic::LC_PlayerIDPtrMap*>& playerListVec, uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody, LC_PlayerOperator* pkFilter)
{
	if (playerListVec.empty())
	{
		return TRUE;
	}

	BOOL rtn = FALSE;
	do 
	{
		if (!m_multiMsgHelper.Begin(usMsgType, pkFilter))
		{
			break;
		}
		if (!m_multiMsgHelper.Encode(pkMsgBody))
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[error]: MulticastMsgToGateway Encode Fail!:%u.\n", usMsgType);
			break;
		}
		for (size_t i=0; i<playerListVec.size(); ++i)
		{
			const LC_PlayerIDPtrMap* pkPlayerIDs = playerListVec[i];
			if (NULL == pkPlayerIDs)
			{
				continue;
			}
			for (LC_PlayerIDPtrMap::const_iterator cit = pkPlayerIDs->begin(); cit !=  pkPlayerIDs->end(); ++cit)
			{
				LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)cit->second;
				m_multiMsgHelper.AddUserIndices(pkPlayer);
				// transcribe fight 战斗录制
				if( true == GameLogic::LC_Helper::_CheckArenaRecordByType(usMsgType))
					GameLogic::LC_Helper::makeTranscribeFightMsg(usMsgType, pkMsgBody, pkPlayer->GetUserID(),m_pkTimeManager->GetProcessTime());
			}
		}
		rtn = m_multiMsgHelper.End();
	} while (0);

	return rtn;
}

BOOL GameServerApp::BroadCastMsgToClient(uint16_t usMsgType, Protocol::MG_BODY* pkMsgBody)
{
	BOOL rtn = TRUE;
	SetBroadcastMsgHead(usMsgType);

	Protocol::MG_BroadCastMessage broadcastMessage;
	if (NULL != pkMsgBody)
	{
		broadcastMessage.m_szMessageBuff.resize(MAX_BROADCAST_MESSAGE_SIZE);
		if(!pkMsgBody->Encode(broadcastMessage.m_szMessageBuff))
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[error]: BroadCastMsgToClient Encode Fail!:%u.\n", usMsgType);
		}
	}
	broadcastMessage.m_iGroupID = GetServerInfo().m_iServerID;

	if (m_kPakcetHandler.EncodeSSMsg(m_kMsgHead, &broadcastMessage))
	{
		NW_ServerSessionMap::iterator it = m_kGame2GatewaySessions.begin();
		for (; it!=m_kGame2GatewaySessions.end(); ++it)
		{
			record_send_packet(usMsgType, m_kPakcetHandler.GetMsgSize());
			rtn = it->second->Send(m_kPakcetHandler.GetBuff(), m_kPakcetHandler.GetMsgSize());
		}
	}
	else
	{
		rtn = FALSE;
	}
	return rtn;
}

void GameServerApp::StopGameLogic()
{
	m_pkLogicManager->StopGameLogic();
}

void GameServerApp::SetGameServerInfos(const mem::vector<Protocol::PS_ServerInfo>& gameServerInfos)
{
	m_GameServerInfos.assign(gameServerInfos.begin(), gameServerInfos.end());
}

E_LocalServerState GameServerApp::CheckLocalServer(int iServerID)
{
	if(0 == iServerID)
		return E_LocalServerState_Error;

	int serverEntryID = GSNodeNetwork::Instance().getEntryIdByMergeId(iServerID);
	int iCurServer = this->GetServerEntryId();
	if (serverEntryID == iCurServer)	// m_kServerInfo.m_iServerID
	{
		return E_LocalServerState_Local;
	}
	GameServerManager* pkSvrMgr = GetServerManager();
	PS_ServerSimInfo* pkActive = pkSvrMgr->GetActive(serverEntryID);
	if(pkActive == NULL)
	{
		return E_LocalServerState_Error;
	}
	if(pkActive->m_iServerID == iCurServer)	// m_kServerInfo.m_iServerID
	{
		return E_LocalServerState_Local;
	}
	return E_LocalServerState_Cross;
}

static void set_cus_res_ver_cb(int32_t err, bool& ret)
{
	if (err)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SetCustomResVersion Err:%d Ret:%d", err, int(ret));
	}
}

void GameServerApp::ReloadCsv(const StringType& rkCSVFile, const StringType& sVersion)
{
	TStringVector strList;
	Utility::tokenize_unnull(rkCSVFile, strList, ";");
	ConfigManagerReload(sVersion, strList, true);
	SetCustomResVersion(sVersion.c_str());
}

void GameServerApp::SetCustomResVersion(const std::string& ver)
{
	if (ver.compare(g_svr_version_info.custom_res_version())==0)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SetCustomResVersion SameVersion:%s", ver.c_str());
		return;
	}

	STRNCPY(g_svr_version_info.custom_res_version(), ver.c_str(), g_svr_version_info.custom_res_version_size());

	int32_t ret = 0;
	std::string sCusResVerKey = GetRedisServerPredix() + UT_REDIS_KEY_CUS_RES_VERSION;
	ASYNC_REDIS_REQUEST(ret, GetRedisChannel(), &redispp::Connection::hset, set_cus_res_ver_cb, sCusResVerKey, GAME_VERSION_STRING(), ver);
}

void GameServerApp::SetServerId( int32_t nServerId )
{
	m_kServerInfo.m_iServerID = nServerId;
}

double GameServerApp::GetBossShieldRate()
{
	GameServerManager* pkServerMgr = GetServerManager();
	{
		uint32_t startTime = (uint32_t)pkServerMgr->GetServerStartTime();
		uint32_t conflateTime = (uint32_t)pkServerMgr->GetServerConflateTime();
		uint32_t timestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		if (LC_Helper::CheckIsSameDay(startTime, timestamp) || LC_Helper::CheckIsSameDay(conflateTime, timestamp))
		{
			return 1.0;
		}
	}
	return UT_MathBase::MaxDouble(0.2, UT_MathBase::MinDouble(m_iPredayActive / 150.0, 1.0));
}

double GameServerApp::GetCrossBossShieldRate()
{
	GameServerManager* pkServerMgr = GetServerManager();
	{
		uint32_t startTime = (uint32_t)pkServerMgr->GetServerStartTime();
		uint32_t conflateTime = (uint32_t)pkServerMgr->GetServerConflateTime();
		uint32_t timestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		if (LC_Helper::CheckIsSameDay(startTime, timestamp) || LC_Helper::CheckIsSameDay(conflateTime, timestamp))
		{
			return 1.0;
		}
	}
	return UT_MathBase::MaxDouble(0.2, UT_MathBase::MinDouble(m_iPredayCrossActive / 300.0, 1.0));
}

void GameServerApp::SyncPredayActive(float fCurrentTime)
{
	static float fLastSyncTime = m_pkTimeManager->GetProcessTime();
	if (fLastSyncTime + 300 > fCurrentTime)
	{
		return;
	}
	fLastSyncTime = fCurrentTime;

	int ret = 0;
	std::string sKey = GetRedisGroupPrefix() + UT_REDIS_KEY_PREDAY_ACTIVE;

	Utility::Redis_Handler* pkRedisHandler = GetRedisHandler();
	UT_REDIS_CMD_BEGIN(ret, pkRedisHandler);
	redispp::MultiBulkEnumerator replys;
	replys = pkRedisConn->hgetAll(sKey);

	m_bSyncActiveSucceed = true;
	m_iPredayActive = 0;
	m_iPredayCrossActive = 0;
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	int32_t index = 0, serverID = 0;
	std::string str;
	while (replys.next(&str))
	{
		if (str.empty())
		{
			++index;
			continue;
		}
		int64_t value = boost::lexical_cast<int64_t>(str);
		if (index % 2 == 0)
		{
			serverID = (int32_t)value;
		}
		else
		{
			uint32_t timestamp = (uint32_t)(value / PREDAY_ACTIVE_MASK);
			int32_t active = (int32_t)(value % PREDAY_ACTIVE_MASK);
			if (LC_Helper::CheckIsSameDay(timestamp, currentTime))
			{
				if (serverID == GetGameServerID())
				{
					m_iPredayActive = active;
				}
				m_iPredayCrossActive += active;
			}
			else
			{
				m_bSyncActiveSucceed = false;
			}
		}
		++index;
	}
	UT_REDIS_CMD_END(ret, pkRedisHandler);
}

void GameServerApp::LoadUpdateBulletin()
{
	int ret = 0;
	std::string sKey = GetRedisGroupPrefix() + UT_REDIS_KEY_UPDATE_BULLETIN;

	redispp::StringReply reply;
	Utility::Redis_Handler* pkRedisHandler = GetRedisHandler();
	UT_REDIS_CMD_WITH_REPLY(ret, pkRedisHandler, reply, get, sKey);
	if (ret == 0 && reply.result())
	{
		StringType str = STDSTR2TPSTR(reply);
		StringType errorMsg;
		boost::ajson::load_from_buff(m_kUpdateBulletin, str.c_str(), errorMsg);
	}
}

void GameServerApp::SetUpdateBulletin(uint32_t iUpdateTime, const StringType& sBulletin)
{
	m_kUpdateBulletin.update_time = iUpdateTime;
	m_kUpdateBulletin.bulletin = sBulletin;
}

void GameServerApp::SetNodeType( int32_t nType )
{
	m_nNodeType = nType;
}

int32_t GameServerApp::GetNodeType()
{
	return m_nNodeType;
}

bool GameServerApp::IsNodeType_Global()
{
	return (m_nNodeType == eGameNodeType_Global);
}

