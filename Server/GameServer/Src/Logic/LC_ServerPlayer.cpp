#include "LM_LocaleManager.h"
#include "LC_ServerPlayer.h"
#include "LC_ServerMap.h"
#include "LC_ServerNPC.h"
#include "LC_ServerPlayerGroupManager.h"
#include "LC_ServerPlayerGroup.h" 
#include "LC_ServerPlaceHolder.h"
#include "LC_ServerDuelFlow.h"
#include "LC_ServerPlayerManager.h"
#include "LC_ServerLogicManager.h"
#include "LC_GameEvent.h"
#include "LC_ServerSector.h"
#include "LC_ServerTaskMap.h"
#include "LC_ServerTaskManager.h"
#include "LC_ServerPlayerMonitor.h"
#include "LC_ServerItemFactory.h"
#include "LC_RumorManager.h"
#include "LC_ServerWorldManager.h"
#include "LC_TranscriptionDataType.h"
#include "LC_GameStory_Manager.h"
#include "LC_StoryLogic_Manager.h"
#include "LC_ServerGuildManager.h"
#include "LC_RankManager.h"
#include "LC_ServerPlayerEnterLeaveManager.h"
#include "LC_ShortcutBar.h"
#include "LC_ServerNPCManager.h"
#include "LC_LogicIDManager.h"
#include "LC_ServerShopAsset.h"
#include "LC_PackEntryFactory.h"
#include "LC_ServerMysticalShop.h"
#include "LC_ServerGuildWarAsset.h"
#include "LC_GameEventManager.h"
#include "LC_ThirdPlatformReport.h"
#include "LC_Arena_Manager.h"
#include "LC_ServerAllianceManager.h"
#include "LC_GuildLadderManager.h"
#include "LC_ServerGoalAsset.h"
#include "LC_ServerMapLogic_TranscriptionRuleManger.h"
#include "LC_SubEquipPack.h"
#include "LC_ActSubordinateRewardManager.h"
#include "LC_ActShopManager.h"
#include "LC_ServerTools.h"
#include "LC_ServerGuessAsset.h"
#include "LC_DamageRankManager.h"

#include "SM_ServerControllerFactory.h"
#include "SM_ServerStateFactory.h"
#include "SK_ServerSkillEventManager.h"
#include "SK_Factory.h"
#include "UT_TimeManager.h"
#include "UT_TimeUtil.h"
#include "UT_Timer.h"
#include "UT_PathFindHelp.h"
#include "UT_GameServerProfile.h"
#include "NW_Helper.h"
#include "NW_ServerSession.h"

#include "GameServerApp.h"
#include "GlobalSettings.h"
#include "ConfigManager.h"
#include "IdDefine.h"
#include "UT_Singleton.h"
#include "NewUserEvent.h"
#include "LC_Define.h"
#include "UT_OperateLog.h"
#include "XDebugDumper.h"
//Prison
#include "PF_ServerPathManager.h"
#include "SC_ServerSkillInterface.h"
#include "SC_ServerScriptInterface.h"
#include "SC_ServerDebugInterface.h"

#include "../Buddy/BuddyInstance.h"
#include "../Buddy/BuddyHelper.h"
#include "../Buddy/BuddyChain.h"

//协议
#include "redis.pb.h"
#include "MG_Stream.h"
#include "MG_PB.h"
#include "MG_AssistProtocol.h"
#include "MG_CS_FriendProtocol.h"
#include "MG_BackPackProtocol.h"
#include "MG_ShortcutKeyProtocol.h"
#include "MG_Game2Guild.h"
#include "MG_Common.h"
#include "MG_Forbid.h"
#include "MG_TaskProtocol.h"
#include "MG_LoginProtocol.h"
#include "MG_PetProtocol.h"
#include "MG_GameProtocol.h"
#include "MC_MessagePackageHelp.h"
#include "MG_GroupProtocol.h"
#include <algorithm>
#include <time.h>
#include <math.h>
#include <boost/algorithm/string.hpp>
#include<memory>
#include "oss_define.h"
#include "oss_internal_define.h"
#include "publish_define.h"
#include "oss_360_define.h"
#include "gsnode.h"

#include "ACT_ActivitySchedule.h"
#include "ACT_ActivityAsset.h"
#include "ACT_ActivityDataManager.h"
#include "ACT_Lottery.h"

// 表格
#include "CF_BossInvade.h"
#include "CF_BuddyLimit.h"
#include "CF_AutoRecharge.h"
#include "CF_ItemExistenceFunc.h"
#include "CF_ItemEquipLimitFunc.h"
#include "CF_MailCharge.h"
#include "CF_GameStory.h"
#include "CF_Helper.h"
#include "CF_SystemTitleList.h"
#include "CF_TranscriptionRule.h"
#include "CF_SummorFriendTalk.h"
#include "CF_CharAttributeFunc.h"
#include "CF_GreatKungFu.h"
#include "CF_OpenLevel.h"
#include "CF_WorldMapList.h"
#include "CF_SkillLevelUp.h"
#include "CF_AchievementList.h"
#include "CF_RechargeReturnConfig.h"
#include "CF_ItemGen.h"
#include "CF_ItemEffect.h"
#include "CF_BulletCd.h"
#include "CF_ItemDisassembleUseFunc.h"
#include "CF_BuddyUnlock.h"
#include "CF_SoulConnect.h"
#include "CF_DailyActivity.h"
#include "CF_CollectionActivation.h"
#include "CF_CollectionReward.h"
#include "CF_SkillBookInitAttribute.h"
#include "CF_TreasureAddAward.h"
#include "CF_HolyDeed.h"
#include "CF_BossInvade.h"
#include "CF_BossInvadeRankReward.h"
#include "CF_AchievementRewards.h"
#include "CF_StarVeinList.h"
#include "CF_FirstDailyCharge.h"
#include "CF_SkillBookUnlock.h"
#include "CF_TaskChapters.h"
#include "CF_RuneLevelUp.h"
#include "CF_BiographyTask.h"
#include "CF_Biography.h"
#include "CF_TaskReachRewards.h"
#include "CF_TimeLimitedActivity.h"
#include "CF_ACTShopA.h"
#include "CF_BossFirstKill.h"
#include "CF_GloryExpeditionDailyRewards.h"
#include "CF_BestGuildChapterID.h"
#include "CF_StarVeinGoalList.h"
#include "CF_RuneList.h"
#include "CF_ShopGroupOpenSetting.h"
#include "CF_InvestmentPlan.h"
#include "CF_InvestmentCard.h"
#include "CF_InvestmentCardTask.h"
#include "CF_VipNew.h"
#include "CF_TestDatabase.h"
#include "CF_TestAccPointRewards.h"
#include "CF_ACTSubordinateRewardB.h"
#include "CF_CommanderTitle.h"
#include "CF_SpecialTraining.h"
#include "CF_HeadFrame.h"
#include "CF_GloryExpedition.h"
#include "CF_EquipCommanderSlotReinforce.h"
#include "CF_EquipCommanderSlotReinforceSuit.h"
#include "CF_EquipCommanderJinglian.h"
#include "CF_EquipCommanderJinglianSuit.h"
#include "CF_YiJiTuXiStageReward.h"
#include "CF_YiJiXunBaoStageReward.h"
#include "CF_RotaryTable.h"
#include "CF_RotaryTableReward.h"
#include "CF_BestGuild.h"
#include "CF_EquipCommanderSlotMoldingSpirit.h"
#include "CF_EquipCommanderSlotMoldingSpiritSuit.h"
#include "CF_PetIslandStageReward.h"
#include "CF_EscortReward.h"
#include "CF_BestGuildDailyTask.h"
#include "CF_BestGuildTask.h"
#include "CF_NewAchievementReward.h"
#include "CF_TreasurePos.h"
#include "CF_TreasureEvent.h"
#include "CF_GuildTower.h"
#include "CF_ItemGenMonsterDrop.h"
#include "CF_BuddyTransform.h"
#include "CF_SubordinateTransform.h"
#include "CF_GameRestartNotice.h"
#include "CF_BuddyThemeBossType.h"
#include "CF_BuddyThemeSecondary.h"
#include "CF_SignInDailyReward.h"
#include "CF_SignInReward.h"
#include "CF_BuddyThemeMain.h"
#include "CF_Charge.h"
#include "CF_SkyArenaRank.h"
#include "CF_Scheme.h"
#include "CF_ActivityTime.h"
#include "CF_RankCondition.h"
#include "CF_ACTChargeProfitB.h"
#include "CF_HolidayActivitySecondary.h"
#include "LC_Helper.h"
class ACT_ScheduleDataManager;
class ACT_ScheduleManager;
using namespace GameLogic;
using namespace GameStory;
using namespace StateMachine;
using namespace Protocol;
using namespace CSVFile;
using namespace Utility;
using namespace Skill;
using namespace OPERATELOG;
//---------------------------------------
#define GAMESTORY_TYPE_EXCHANGE 2
#define	BUDDY_CHAR_ID_BEGIN			10000000

#define		RESET_ROLL_SKILL_TIMER		0.6f

//#define		STOP_FOLLOW_DISTANCE				200
//#define		BUDDY_FOLLOW_ANGLE					24

static StringType gs_strNullStr = "";
static LC_CombatRecorder gs_CombatRecorder_Error;

int32_t LC_ServerPlayer::m_nUpdateResult = true;

static const mem::map<int16_t, PetInstance*> gs_no_use;

inline bool is_normal_attack_skill(int skillid)
{
	if (21100001 == skillid)
	{
		return true;
	}
	if (21200001 == skillid)
	{
		return true;
	}
	if (21300001 == skillid)
	{
		return true;
	}
	if (21400001 == skillid)
	{
		return true;
	}
	if (21500001 == skillid)
	{
		return true;
	}
	if (21600001 == skillid)
	{
		return true;
	}
	return false;
}

static int GetFirstRaidID()
{
	CF_TranscriptionRule::DataEntryMapExternIterator i = SafeGetSingleton<CF_TranscriptionRule>()->GetIterator();
	if (i.HasMoreElements())
	{
		const CF_TranscriptionRule::DataEntry& entry = i.PeekNextValue();
		return entry._iID;
	}
	return 0;
}
static int GetFirstMapID()
{
	CF_WorldMapList::DataEntryMapExternIterator i = SafeGetSingleton<CF_WorldMapList>()->GetIterator();
	if (i.HasMoreElements())
	{
		const CF_WorldMapList::DataEntry& entry = i.PeekNextValue();
		return entry._iID;
	}
	return 0;
}
AJSON(platform_node, (vip_type)(is_vip)(is_year_vip)(vip_level)(is_high_vip)(is_expand_vip)(timestamp)(extend));
//----------------------------------------------------------
LC_ServerPlayer::LC_ServerPlayer()
	: LC_PlayerBase()
	, m_pkSession(NULL)
	, m_nSessionId(0)
	, m_bPendingItemSkill(false)
	, m_lPendingItemSkillTypeID(0)
	, m_lPendingItemTypeID(0)
	, m_lSpawnMapID(-1)
	, m_bLoadDataFromLoginFlag(false)
	, m_bLoadDataFromDB(false)
	, m_fLastUnidonUpdateTime(0)
	, m_fLastOSSPosTime(0.0f)
	//, m_lHPFromDB(0)
	//, m_lMPFromDB(0)
	, m_bIsSyncTutorialInfo(true)
	, m_bIsSyncShortcutKeyInfo(true)
	, m_isOffline(false)
	, m_offlingTime(0)
	, m_clientLoading(false)
	, m_loadTime(0)
	, m_normalQuit(false)
	, m_bIsRelogin(false)
	, m_bHandleTask(false)
	, m_uiHeadPic(0)
	, m_byDeleteFlag(0)
	, m_iDeleteTime(0)
	, m_iLastOfflineTime(0)
	, m_fLastProfileTime(0)
	, m_nLotteryConsumeUnBindYuanBaoCount(0)
	, m_bGuildRewardFlag(true)
	, m_bGuildRewardIsVaild(false)
	, m_bLoginBuff(false)
	, m_nNewVipLevel(0)
	, m_bNewVipState(false)
	, m_nDailyActivity(0)
	, m_serverViewState(SERVER_STATE_INVALID)
	, m_fLastClientCheckTime(0.0f)
	, m_fLastServerCheckTime(0.0f)
	, m_fLastTimerCheckTime(0.0f)
	, m_fLastSyncMoveTime(-9999999.0f)
	, m_fLastServerSetLocationTime(0.0f)
	, m_fLastPickItemTime(0.0f)
	, m_lAccumulateMoveDistance(0)
	, m_CloseFlyFlagTime(0)
	, m_CloseFlyFlagBeginTime(0)
	, m_LastJumpBeginTime(0)
	, m_LastJumpEndTime(0)
	, m_bFollowedByGM(false)
	, m_uiLoginIP(0)
	, m_uiClientIP(0)
	, m_ulClientMAC(0)
	, m_iLastUpdateItemLogTime(0)
	, m_fFightStateBeginTime(0.0f)
	, m_fFightOutBeginTime(0.0f)
	, m_bGetGuildData(false)
	, m_lAccountLoginTime(0)
	, m_Courage(false)
	, m_fLastUpdatePropellTime(0)
	, m_uiPropellID(0)
	, m_iComboEffectRound(0)
	, m_iComboCountAtLastRound(0)
	, m_fComboEffectTime(0.0f)
	, m_AIControlNotify(false)
	, m_nAttackNoticeCD(0)
	, m_nCrossServerType(-1)
	, m_tCrossServerCheck(0)
	, m_iLastRechargeTime(0)
	, m_iLastSyncAllianceTime(0)
	, m_nActivateBuddyInSceneCount(0)
	, m_nCharDataVersion(0)
	, m_bSoloDulePlay(false)
	, m_bRecoverFromSoloPlay( false)
	, m_nSevenDayTrailFlag(true)
	, m_nFDFlag(0)
	, m_bRelieveBeforeEnterMapTag(false)
	, m_nTaskRankIndex(-1)
	, m_nTaskHonorPoints(0)
	, m_nAssignEscortTaskTime(0)
	, m_nEscortTimes(0)
	, m_nRobbingTimes(0)
	, m_nMainTaskFinishCount(0)
	, m_nDailyFlag(false)
	, m_bACTSubSave(false)
	, m_bACTSubSave_Plus(false)
	, m_bDecompositionController(GetGlobalSetting.DecompositionController)
	, m_nControllerItemlevel(GetGlobalSetting.ControllerItemlevel)
	, m_nControllerItemGrade(GetGlobalSetting.ControllerItemGrade)
	, m_bDecompositionVehicle(GetGlobalSetting.DecompositionVehicle)
	, m_nVehicleItemLevel(GetGlobalSetting.VehicleItemLevel)
	, m_nVehicleItemGrade(GetGlobalSetting.VehicleItemGrade)
	, m_bDecompositionDevaeye(GetGlobalSetting.DecompositionDevaeye)
	, m_nDevaeyeItemLevel(GetGlobalSetting.DevaeyeItemLevel)
	, m_nDevaeyeItemGrade(GetGlobalSetting.DevaeyeItemGrade)
	, m_bDecompositionWing(GetGlobalSetting.DecompositionWing)
	, m_nWingItemLevel(GetGlobalSetting.WingItemLevel)
	, m_nWingItemGrade(GetGlobalSetting.WingItemGrade)	
	, m_bAutoDecomposition(false)
	, m_bDecompositionInit(false)
	, m_nIsRobot(false)
	, m_nProfilePictureID(0)
	, m_nRefreshRewardTaskTimes(0)
	, m_nTotalRaidStarNum(0)
	, m_nCheckBiography(true)
	, m_nYiZhongQinXiState(false)
	, m_nYiZhongQinXiEndTime(0)
	, m_nAnswerActivityEndTime(0)
	, m_nCommanderTitle(0)
	, m_bUpdataRedis(false)
	, m_nAnswerAccPoint(ANSWER_NOT_JOIN)
	, m_nAnswerGuildAccPoint(0)
	, m_fFinalDamageRate(1.00f)
	, m_nLastMapResId(0)
	, m_nFinishMainTaskID(0)
	, m_fixMainTaskBug(true)
	, m_pPKRecorder_Cache(NULL)
	, m_pTaskMap_Cache(NULL)
	, m_pOwnerPlayer_Cache(NULL)
	, m_nActiveServer_Cache( - 1 )
	, m_bLogicCombatFlag_Cache(false)
	, m_bCombatFlag(false)
	, m_nSevenDayEndTime1(0)
	, m_nSevenDayEndTime2(0)
	, m_nFirstDayLoginRewardTime(0)
	, m_nCollectBossJP(0)
	, m_nYiJiTuXiEndTime(0)
	, m_nYiJiTuXiSendFlag(false)
	, m_nYiJiXunBaoEndTime(0)
	, m_nYiJiXunBaoSendFlag(false)
	, m_nPetIslandsEndTime(0)
	, m_nPetIslandsSendFlag(false)
	, m_bKillNPCExpFlag(false)
	, m_nBestGuildCounter(0)
	, m_nBestGuildRewardFlag(false)
	, m_nSettleAccountPoint(0)
	, m_nChainFlag(0)
	, m_nEquipSuitLevel(0)
	, m_nRegularBossGroupID(0)
	, m_nRegularBossGroupCDTime(0)
	, m_nUpdateTimes(0)
	, m_nAcceptRewardTaskTimes(0)
	, m_nRewardTaskEndTime(0)
	, m_DailyReward(0)
	, m_nKillControllerAccountDailyCount(0)
	, m_updateGuildStamp(0)
	, m_nJoinTimeStamp(0)
	, m_nFirstChargeTime(0)
	, m_nUsedVIPExtraRewardTimes(0)
	, m_nNewAchievementStarNum(0)
	, m_RecomputerControllerScore(false)
	, m_bSendGuildPresentInfoFlag(false)
	, m_nShowGuildPresentName(true)
	, m_bSaveFlag(false)
	, m_nTreasureMapID(0)
	, m_nNewVipDropTime(0)
	, m_nAttackFlag(false)
	, m_fLastRecover(0.0f)
	, m_bInitGame(false)
	, b_ActivateSummitArena(false)
	, b_NotifySummitArenaState(false)
	, m_DropTimesAsset(GetGlobalSetting.nDropTimesRevertTime, GetGlobalSetting.nKillNpcDropMaxTimes, RecoverType_BossDrop, 19)
	, m_YuanZhengPointAsset(GetGlobalSetting.YuanZhengPointRevertTime, GetGlobalSetting.YuanZhengPointMaxCount, RecoverType_YuanZhengPoint)
	, m_StarShipTimesAsset(GetGlobalSetting.StarShipTimesRevertTime, GetGlobalSetting.StarShipTimesMaxCount, RecoverType_StarShip, 1041)
{
	m_nSendOSSLoginTime = 0;
	m_dataChangeFlag.SetPlayer(this);
	m_nSTRewardRecord.clear();
	m_vecTreasureNum.clear();
	//SM_StateMachine::Init();
	m_nSubBInfo.clear();
	m_nSendSubInfo.clear();
	m_nRankGroupID.clear();
	m_nDamageRankReward.clear();

	ReuseHuanJingData();

	m_BestGuildFinishedAchievement1.clear();
	m_BestGuildFinishedAchievement2.clear();
	m_nBestGuildTaskID1.clear();
	m_nBestGuildTaskID2.clear();
	m_nBestGuildCounter = 0;
	m_nBestGuildRewardFlag = false;

	m_nGoalAsset.Clear();

	m_nResourceRetrieveMgr.ReUse();

	m_nProfilePictureRecord.clear();

	m_nFirstChargeRewardState.clear();

	m_QuickRaidAsset.Clear();

	m_nGuildFightScore.clear();
	m_nBestGuildActivityEndTime.clear();
	m_nAssignBestGuildTaskEndTime.clear();
	m_nStoryAssignTaskTime.clear();
	m_nPlayerLastRankIndex.clear();
	m_nPlayerCurrentRankIndex.clear();

	m_nTreasurePos.clear();

	m_nChapterRewardRecord.clear();
	m_nChapterRaidStarNum.clear();

	m_nYiJiTuXiStageRewardRecord.clear();
	m_nYiJiXunBaoStageRewardRecord.clear();
	m_nPetIslandsStageRewardRecord.clear();
	m_nResetAllCommonStatID.clear();

	m_nFinishGameStoryMapID.clear();
	m_nTest.clear();
	m_byBusyState = CLIENT_DEBUG_NOT_BUSY;

	m_pkShortcurtBar = T_NEW_D LC_ShortcutBar((LC_PlayerBase*)this);
	m_pkTaskMap		 = T_NEW_D LC_ServerTaskMap;
	m_pkTaskMap->SetOwner(this);

	m_nMonstarCombatDataMap.clear();
	m_nPlayerCombatDataMap.clear();

	m_kPackAsset.SetOwner(this);

	m_nFirstKillBossRewardRecord.clear();
	m_nKillBossRecord.clear();

	m_nSubSkillID.clear();
	m_nVIPDropItemInfo.clear();

	m_nCurrentCommanderTitleFrameID = 1;
	m_nCommanderTitleFrameIDRecord.clear();
	m_nCommanderTitleFrameIDRecord.insert(std::make_pair(m_nCurrentCommanderTitleFrameID, true));

	m_kACTScheduleAsset.SetOwner(this);
	m_kResourceAlert.SetOwner(this);

	m_nAnswerRecord.clear();
	m_nAnswerRewardRecord.clear();

	m_kFOVMap.SetDataChangerObserver(&m_dataChangeFlag);

	m_kSkillStateMap->SetDataChangerObserver(&m_dataChangeFlag);

	m_ulDBSaveMaskFlag = 0;

	m_nPlaceHolderLogicID.clear();
	m_nVipRewardRecord.clear();

	m_kGameServerPackFilter.Reset();
	m_kGameServerPackFilter.SetGlobalFilterFrequency(30);

	m_pkGuildwarAssert = T_NEW_D LC_GuildWarAssert;

	m_stateCount = ST_PLAYER_PASSIVE_MOVE + 1;
	m_kStateMap = (SM_StateBase**) T_MALLOC(sizeof(SM_StateBase*)*m_stateCount, Memory::MEMCATEGORY_GENERAL);
	::memset(m_kStateMap, 0, sizeof(SM_StateBase*)*m_stateCount);
	_uninitStateMap();

	//状态控制器
	//m_pkSMController = SM_ServerControllerFactory::GetSingletonPtr()->RequestController(SCT_SERVER_PLAYER);

	m_nGameStoryJoinTimes.clear();

	m_nNewAchievementRewardRecord.clear();

	m_nLotteryConsumeUnBindYuanBaoCount = 0;
	m_nDailyActivityRewardID.clear();
	m_nActivateStarVeinID.clear();
	m_nStarVeinGoalID.clear();
	m_firstDailyChargeRewards.clear();
	m_collectionActivationIDMap.clear();
	m_collectionAchievementIDSet.clear();
	m_nHolyDeedRecords.clear();
	m_collectionRewardSet.clear();
	m_biographytRewardPartSet.clear();
	m_biographySet.clear();
	m_nAssignBiographySet.clear();
	m_nFinishBiographyPartSet.clear();
	m_nNextAssignBiographyPartSet.clear();
	m_nShareCDTimeRecord.clear();
	m_nTimeLimitedRecord.clear();
	m_ShopTimes.clear();
	m_ShopStartTime.clear();
	m_nUnbindYuanbaoShopItemInfo.clear();
	m_nGuildShopItemInfo.clear();
	m_nMoneyCourageShopItemInfo.clear();
	m_nBossJPShopItemInfo.clear();
	m_nLimitShopItemInfo.clear();
	m_nInvestmentCardRecord.clear();
	m_nInvestmentCardFreeRewardID.clear();
	m_nInvestmentCardHighRewardID.clear();
	m_nInvestmentCardStartTime.clear();
	m_showCoreArrMap.Clear();
	ReUse();

	m_CommandEquipPack.Init( GetGlobalSetting.CommandPackSize );
	m_nCommanderSubEquipPack_Vehicle.Init(LC_SUB_TP_VEHICLE, GetGlobalSetting.MountPackSize);
	m_nCommanderSubEquipPack_DevaEye.Init(LC_SUB_TP_DEVA_EYE, GetGlobalSetting.PetPackSize);
	m_nCommanderSubEquipPack_Muhun.Init(LC_SUB_TP_MUHUN, GetGlobalSetting.WingPackSize);
	m_BuddyEquipData.Init();

	m_RuneData.Init();
	m_nSummitArenaHonorMaps.clear();

	return;
}
//----------------------------------------------------------
LC_ServerPlayer::~LC_ServerPlayer()
{
	T_SAFE_DELETE(m_pkShortcurtBar);
	T_SAFE_DELETE(m_pkTaskMap);
	T_SAFE_DELETE(m_pkGuildwarAssert);
	if (m_kStateMap)
	{
		T_FREE(m_kStateMap, Memory::MEMCATEGORY_GENERAL);
		m_kStateMap = NULL;
	}
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::RefreshSMController()
{
	_initSMController( "" );
}

//#define		ALL_PLAYER_CONTROLLER	1

void LC_ServerPlayer::_initSMController(const StringType& rkScriptName)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return;

	LC_ServerPlayer* pCurrentPlayer = GetCurrentActivateBuddy();

	bool bClone = pOwnerPlayer->IsClone();
	bool bBuddy = IsBuddy();
	bool bAIControl = pOwnerPlayer->GetAIControl();
	SM_ControllerFactory* pkCtrlFactory = SM_ControllerFactory::GetSingletonPtr();
	StateMachine::SM_ControllerBase*	pkSMController = NULL;
	if (bAIControl == true)
	{
#if defined ALL_PLAYER_CONTROLLER
		SetControlType(eControlType_Player);
		m_pkSMController = pkCtrlFactory->RequestController(SCT_SERVER_PLAYER);;
		SetAIControlNotify(true);
#else
		if (pCurrentPlayer && pCurrentPlayer->GetID() == GetID())
		{
			pCurrentPlayer->SetControlType(eControlType_Player);
			pkSMController = pkCtrlFactory->RequestController(SCT_SERVER_PLAYER);
			pCurrentPlayer->m_pkSMController = pkSMController;
			SetAIControlNotify(true);
		}
		else
		{
			m_pkSMController = pkCtrlFactory->RequestController(SCT_SERVER_BUDDY);
		}
			
#endif
	}
	else
		m_pkSMController = pkCtrlFactory->RequestController(SCT_SERVER_BUDDY);
	m_bControledByScript = false;
}
//-----------------------------------------------------------------------------------
void LC_ServerPlayer::_initStateMap(const StringType& rkScriptName, bool bForce)
{
	if (m_bStateMapInitFlag && !bForce)
		return;

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;
	if (!bForce)
	{
		_uninitStateMap();
		ClearState();
	}
	LC_ServerPlayer* pCurPlayer = GetCurrentActivateBuddy();
	if ( pOwner->GetAIControl() && bForce)
	{
		LC_ServerPlayer* pPlayer = this;
		if ( pCurPlayer )
			pPlayer = pCurPlayer;
		SM_ServerStateFactory* pkStateFactory = (SM_ServerStateFactory*)SM_ServerStateFactory::GetSingletonPtr();

		pPlayer->m_kStateMap[ST_DEFAULT]			= pkStateFactory->RequestState(ST_DEFAULT);

		for (int i = ST_PLAYER_STAND; i <= ST_PLAYER_CHASE; i++)
		{
			pPlayer->m_kStateMap[i] = pkStateFactory->RequestState(i);
		}
		if(pOwner->GetSoloDulePlay())
		{
			pPlayer->SetNextState(ST_PLAYER_CHASE);
			pPlayer->m_iDefaultState = ST_PLAYER_CHASE;
		}
		else
		{
			pPlayer->Start(ST_PLAYER_BORN, 0.0f, 0.0f);
			pPlayer->m_iDefaultState = ST_PLAYER_STAND;
		}
		
		
	}
	m_bStateMapInitFlag = true;
	return;
}
//---------------------------------------------------------
void LC_ServerPlayer::_uninitStateMap()
{
	for (int i = 0 ; i < m_stateCount; ++i)
	{
		m_kStateMap[i] = NULL;
	}
}

//---------------------------------------------------------
StateMachine::SM_StateBase* LC_ServerPlayer::_findState(int iStateType)
{
	if (IS_SKILL_TYPE(iStateType))
	{
		static Skill::SK_Factory* skf = Skill::SK_Factory::GetSingletonPtr();
		return skf->RequestSkillExcute(iStateType);		//SkillExecute也是状态的一种
	}
	else
	{
		if (0 <= iStateType && iStateType < m_stateCount)
		{
			return m_kStateMap[iStateType];
		}
	}

	return NULL;
}

void LC_ServerPlayer::AddAliveBuddyCount()
{
	if(m_nAliveBuddyCount < 3)
		m_nAliveBuddyCount++;

}

void LC_ServerPlayer::SetAliveBuddyCount(int nAliveCount)
{
	m_nAliveBuddyCount = nAliveCount;
	if(m_nAliveBuddyCount > MAX_ACTIVE_BUDDY_NUM)
		m_nAliveBuddyCount = MAX_ACTIVE_BUDDY_NUM;

}
void LC_ServerPlayer::SubAliveBuddyCount()
{
	if(m_nAliveBuddyCount > 0)
		m_nAliveBuddyCount--;
}
int32_t LC_ServerPlayer::GetAliveBuddyCount()
{
	return m_nAliveBuddyCount;
}

ResultType LC_ServerPlayer::SignInByType(int type)
{
	ResultType res = RE_FAIL;
	time_t Curstamp = (time_t)GET_CURRENT_TIMESTAMP_IN_SECONDS();
	tm* curtm = localtime(&Curstamp);

	int day = curtm->tm_mday;
	CF_SignInDailyReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SignInDailyReward>(day);
	if(NULL == pkData)
	{
		return res;
	}

	int logType = eOssLogSignType_Try;
	switch(type)
	{
	case SIGNIN_TYPE_1:
		{
			logType = eOssLogSignType_Try;
			bool flag = m_signinAssert.SignIn(curtm->tm_mday,GET_CURRENT_TIMESTAMP_IN_SECONDS());
			if(false == flag)
			{
				return res;
			}

			GetOpenAbilityAsset().OnSignIn();

			{
				LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
				LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
				if (pkGameEvent)
				{
					pkGameEvent->SetEventType(GLET_SIGNIN);
					pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
					pkGameEvent->SetEventParam(EP_SIGNIN_PLAYER_ID, GetID());
					pkGameEvent->SetEventParam(EP_SIGNIN_TTL_CNT, m_signinAssert.GetTotalCnt());
					pkGameEvent->SetEventParam(EP_SIGNIN_MAP_ID, GetMapResID());
					pkEventManager->InsertGameEvent(pkGameEvent);
				}
			}
			//每日签到--埋点日志
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(day);
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, SIGNIN_OPERATE, OPERATE_LOGTYPE1);
			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_Reward, kItems);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_SIGNIN_DAILY, day, pkData->_sMailTitle, pkData->_sMailDesc, true,false,false,nLogCode,nParams);
		}
		break;
	case SIGNIN_TYPE_2:
		{
			logType = eOssLogSignType_360MicroTry;

			bool flag = m_n360MicroSignInAssert.SignIn(curtm->tm_mday,GET_CURRENT_TIMESTAMP_IN_SECONDS());
			if(false == flag)
			{
				return res;
			}
			//每日签到--埋点日志
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WEIDUANSIGNIN_OPERATE, OPERATE_LOGTYPE1);
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(day);
			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_RewardMiniLauncher, kItems);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_MICROSIGNIN_DAILY, day, pkData->_sMailTitle, pkData->_sMailDesc, true,false,false,nLogCode,nParams);
		}
		break;
	default:
		return RE_FAIL;
	}

	if(RE_SUCCESS == res)
	{
		//achievement
		AchievementEvent kEvent;
		kEvent.SetConditionInfo(type);
		kEvent.SetNum(1);
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SIGNIN, kEvent);

		oss_360_log_sign(type, this);

		SyncSignIn(type);
		SetDirtyFlag(DIRTY_FLAG_SIGNIN_ASSET, false);
	}

	return res;
}

ResultType LC_ServerPlayer::ReSignInByType(int type, int day)
{
	ResultType res = RE_FAIL;

	CF_SignInDailyReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SignInDailyReward>(day);
	if(NULL == pkData)
	{
		return res;
	}

	time_t ct = (time_t)GET_CURRENT_TIMESTAMP_IN_SECONDS();
	tm ctm = *localtime(&ct);
	ctm.tm_mday = day;
	ctm.tm_hour = 23;
	ctm.tm_min = 59;
	ctm.tm_sec = 59;
	if (GetRegTime() > (uint32_t)mktime(&ctm))
	{
		return RE_SIGNIN_DAY_ERR;
	}

	int logType = eOssLogSignType_Retry;
	switch(type)
	{
	case SIGNIN_TYPE_1:
		{
			logType = eOssLogSignType_Retry;
			int curtime = m_signinAssert.GetReSignInTime(GET_CURRENT_TIMESTAMP_IN_SECONDS());
			if (curtime >= m_signinAssert.GetMaxReSignInTime(this, type))
			{
				return RE_SIGNIN_TIME_OUT;
			}

			bool ret = m_signinAssert.SignIn(day, ct);
			if (!ret)
			{
				return RE_SIGNIN_DAY_ERR;
			}

			GetOpenAbilityAsset().OnSignIn();

			{
				LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
				LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
				if (pkGameEvent)
				{
					pkGameEvent->SetEventType(GLET_SIGNIN);
					pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
					pkGameEvent->SetEventParam(EP_SIGNIN_PLAYER_ID, GetID());
					pkGameEvent->SetEventParam(EP_SIGNIN_TTL_CNT, m_signinAssert.GetTotalCnt());
					pkGameEvent->SetEventParam(EP_SIGNIN_MAP_ID, GetMapResID());
					pkEventManager->InsertGameEvent(pkGameEvent);
				}
			}
			//补签--埋点日志
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(day);
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, SIGNIN_OPERATE, OPERATE_LOGTYPE3);
			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_Reward, kItems);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_ERSIGNIN_DAILY, day, pkData->_sMailTitle, pkData->_sMailDesc, true,false,false,nLogCode,nParams);
		}
		break;
	case SIGNIN_TYPE_2:
		{
			logType = eOssLogSignType_360MicroRetry;

			int curtime = m_n360MicroSignInAssert.GetReSignInTime(GET_CURRENT_TIMESTAMP_IN_SECONDS());
			if (curtime >= m_n360MicroSignInAssert.GetMaxReSignInTime(this, type))
			{
				return RE_SIGNIN_TIME_OUT;
			}

			bool ret = m_n360MicroSignInAssert.SignIn(day, ct);
			if (!ret)
			{
				return RE_SIGNIN_DAY_ERR;
			}
			//微端补签--埋点日志
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(day);
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WEIDUANSIGNIN_OPERATE, OPERATE_LOGTYPE3);
			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_RewardMiniLauncher, kItems);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_MICRORESIGNIN_DAILY, day, pkData->_sMailTitle, pkData->_sMailDesc, true,false,false,nLogCode,nParams);
		}
		break;
	default:
		return RE_FAIL;
	}

	if(RE_SUCCESS == res)
	{
		AchievementEvent kEvent;
		kEvent.SetConditionInfo(type);
		kEvent.SetNum(1);
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SIGNIN, kEvent);

		oss_360_log_sign(type, this);
		SyncSignIn(type);
		SetDirtyFlag(DIRTY_FLAG_SIGNIN_ASSET, false);
	}

	return res;
}

ResultType LC_ServerPlayer::GetSignInRewardItem(int type, int id)
{	
	CF_SignInReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SignInReward>(id);
	if(NULL == pkData)
	{
		return RE_SIGNIN_REWARD_TYPE_ERROR;
	}

	ResultType res = RE_FAIL;
	switch(type)
	{
	case SIGNIN_TYPE_1:
		{
			//检查次数
			if(m_signinAssert.GetCount(GET_CURRENT_TIMESTAMP_IN_SECONDS()) < id)
			{
				return RE_SIGNIN_REWARD_TIME_ERROR;
			}

			//检查是否领过
			if (!m_signinAssert.IsRewardVaild(id, GET_CURRENT_TIMESTAMP_IN_SECONDS()))
			{
				return RE_SIGNIN_REWARD_GETED;
			}

			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_Reward, kItems);
			if(kItems.empty())
			{
				return RE_SIGNIN_REWARD_EMPTY;
			}
			//累积签到奖励--埋点日志
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(id);
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, SIGNIN_OPERATE, OPERATE_LOGTYPE2);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_SIGNIN, id, pkData->_sMailTitle, pkData->_sMailDesc, true, false, false,nLogCode,nParams);
			if(RE_SUCCESS == res)
			{
				m_signinAssert.Reward(id, GET_CURRENT_TIMESTAMP_IN_SECONDS());
			}
		}
		break;
	case SIGNIN_TYPE_2:
		{
			//检查次数
			if(m_n360MicroSignInAssert.GetCount(GET_CURRENT_TIMESTAMP_IN_SECONDS()) < id)
			{
				return RE_SIGNIN_REWARD_TIME_ERROR;
			}

			//检查是否领过
			if (!m_n360MicroSignInAssert.IsRewardVaild(id, GET_CURRENT_TIMESTAMP_IN_SECONDS()))
			{
				return RE_SIGNIN_REWARD_GETED;
			}

			UT_SIMDataList kItems;
			Utility::ParseFmtString2DataIFs(pkData->_RewardMiniLauncher, kItems);
			if(kItems.empty())
			{
				return RE_SIGNIN_REWARD_EMPTY;
			}
			//微端累积签到奖励--埋点日志
			vector<int> nParams;
			nParams.clear();
			nParams.push_back(id);
			int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WEIDUANSIGNIN_OPERATE, OPERATE_LOGTYPE2);
			res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_MICROSIGNIN, id, pkData->_sMailTitle, pkData->_sMailDesc, true,false,false,nLogCode,nParams);
			if(RE_SUCCESS == res)
			{
				m_n360MicroSignInAssert.Reward(id, GET_CURRENT_TIMESTAMP_IN_SECONDS());
			}
		}
		break;
	default:
		return RE_FAIL;
	}

	if(RE_SUCCESS == res)
	{
		SyncSignIn(type);
		SetDirtyFlag(DIRTY_FLAG_SIGNIN_ASSET, false);
	}

	return res;
}
//----------------------------------------------------------------------------
static const float assetTimers[] = {0.3f, 0.5f, 0.8f, 1.3f, 2.1f, 3.4f, 5.5f};
//----------------------------------------------------------------------------
void LC_ServerPlayer::InitRobotLogicData(int32_t robotCharID)
{
	const CF_ExportSoloDuleRobotInfo::DataEntry* pkData  = SafeGetCSVFileDataEntryPtr<CF_ExportSoloDuleRobotInfo>(robotCharID);
	if (NULL == pkData)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[%d] InitRobotLogicData error1", robotCharID);
		return;
	}

	LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	if(NULL == pkPlayerManager)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[%d]InitRobotLogicData pkPlayerManager is NULL", robotCharID);
		return;
	}
	m_kAttributeMap.Clear();
	m_iDefaultState		= ST_PLAYER_STAND;
	ClearDirtyFlag();
	ClearDirtyFlagRevisionID();

	SetOwnerPlayerId(m_iID);
	m_ppActivateBuddyDataPtr[0] = this;

	if(false == InitRobotOwnerPlayerInfo(pkData))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[%d]InitRobotLogicData InitRobotOwnerPlayerInfo error!", robotCharID);
		return;
	}
	int buddyId_1 = 0;
	int buddyId_2 = 0;
	int buddyId_3 = 0;
	if(pkData->_groupInfo.size() >= 1)
	{
		buddyId_1 = pkData->_groupInfo[0].ParamA();
		buddyId_2 = pkData->_groupInfo[0].ParamB();
		buddyId_3 = pkData->_groupInfo[0].ParamC();
	}
	if(buddyId_1 == 0 && buddyId_2 == 0 && buddyId_3 == 0)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[%d]InitRobotLogicData InitRobotOwnerPlayerInfo buddyId_1= 0  buddyId_2= 0  buddyId_3= 0 error!", robotCharID);
		return;
	}
	for(int i=0; i<pkData->_buddyBaseInfo.size(); ++i)
	{
		int buddyID = pkData->_buddyBaseInfo[i].IID();
		int buddyTemplateID = pkData->_buddyBaseInfo[i].ParamA();
		if(		buddyID != buddyId_1 
			&&	buddyID != buddyId_2  
			&&	buddyID != buddyId_3)
		{
			InitBuddyInfo(buddyID, buddyTemplateID);
		}
		else
		{
			if(buddyId_1 != 0 && buddyID == buddyId_1 )
			{
				BuddyInstance* pkBuddy = InitBuddyInfo(buddyID, buddyTemplateID);
				if(NULL == pkBuddy)
					continue;
				SetBuddyIndex(0);
				SetBuddyTemplateID(buddyID);
				SetAssignedBuddyInstance(buddyID);
				SetControlType(eControlType_Player);
				AddAliveBuddyCount();
				pkBuddy->OnBind(GetID());
				m_ppActivateBuddyTemplateId[0] = buddyID;
			}
			else if(buddyId_2 != 0 || buddyId_3 != 0 )
			{
				int nIndex = 1;
				if(buddyID == buddyId_3)
					nIndex = 2;
				static LC_LogicIDManager* pkLogicIDManager	= LC_LogicIDManager::GetSingletonPtr();
				object_id_type objectID = pkLogicIDManager->RequestLogicID(LOT_PLAYER_CLONE);
				object_id_type instanceID = LC_LogicIDManager::GetSingletonPtr()->RequestLogicID(LOT_BUDDY);
				LC_ServerPlayer* pkBuddyPlayer = (LC_ServerPlayer*)pkPlayerManager->CreatePlayer(objectID, m_Instance + instanceID, buddyID, (1<<24) | PLY_DEF_CLONE_BITS|PLY_DEF_BUDDY_BITS);	
				if (pkBuddyPlayer == NULL)
					continue;
				m_ppActivateBuddyDataPtr[nIndex] = pkBuddyPlayer;
				pkBuddyPlayer->SetBuddyAllocateId(instanceID);
				pkBuddyPlayer->SetOwnerPlayerId(GetID()); // robot
				pkBuddyPlayer->SetBuddyIndex(nIndex);
				BuddyInstance* pkBuddy = InitBuddyInfo(buddyID, buddyTemplateID);
				if(NULL == pkBuddy)
					continue;
			
				pkBuddyPlayer->SetBuddyTemplateID(buddyID);
				pkBuddyPlayer->SetAssignedBuddyInstance(buddyID);
				pkBuddyPlayer->SetControlType(eControlType_Buddy);
				AddAliveBuddyCount();
				pkBuddy->OnBind(pkBuddyPlayer->GetID());
				m_ppActivateBuddyTemplateId[nIndex] = buddyID;
			}
		}
	}
	int32_t schemeID = LC_Helper::GetSchemeIDFromMapID(GetBuddySchemeMgr().GetBeChallangeMapID());
    if(-1 != schemeID)
    {
       GetBuddySchemeMgr().SetCurrentSchemeInfo(schemeID, INIT_SCHEME_GROUPID);
    }

	std::vector<LC_ServerPlayer*> vecBuddyPtrPlayer;
	GetAllBuddyPtrPlayer(vecBuddyPtrPlayer);
	for (int i = 0; i < vecBuddyPtrPlayer.size(); i++)
	{
		LC_ServerPlayer* pkBuddyPlayer = vecBuddyPtrPlayer[i];
		IF_A_NA_PLAYER(pkBuddyPlayer)
			continue;
		pkBuddyPlayer->FinishPlayerCloneLoad(i, true, SchemeType_Defence,1);
	}
	ExecuteSummonFinishHandle();
}

bool LC_ServerPlayer::InitRobotOwnerPlayerInfo(const CF_ExportSoloDuleRobotInfo::DataEntry* pkData)
{
	if(NULL==pkData || pkData->_buddyBaseInfo.empty())
	{
		return false;
	}

	const Utility::UT_SIMDataInfo& buddyData = pkData->_buddyBaseInfo[0];
	int buddyID= buddyData.IID();
	SetRobot();

	StringStreamType ss;
	ss << "s" << GetGameServerEntryID() << "." << pkData->_name;

	SetCharName(ss.str());
	SetLevel(pkData->_controllerLevel);
	SetBornCharType(pkData->_createBuddyCID);
	SetProfilePictureID(pkData->_createBuddyCID);
	SetCommanderTitle(1);
	SetCurrentCommanderTitleFrameID(1);
	SetBuddyRuneSlotState();
	SetBuddyEquipSlotStarState();
	GetBuddySchemeMgr().SetRobotSchemeData(pkData->_groupInfo);
	SetSkyArenaScoreValue(pkData->_score);
	return true;
}

BuddyInstance* LC_ServerPlayer::InitBuddyInfo(int buddyID,int buddyTemplateID)
{
	CF_ExportRobotBuddyTemplateInfo::DataEntry* pkTempData = SafeGetCSVFileDataEntryPtr<CF_ExportRobotBuddyTemplateInfo>(buddyTemplateID);
	if(NULL == pkTempData)
		return NULL;
	BuddyInstance* pkBuddy = T_NEW_D BuddyInstance(m_nOwnerPlayerId);
	if(NULL == pkBuddy)
		return NULL;

	Utility::UT_SIMDataList buddyInfo = pkTempData->_buddyBaseInfo;
	Utility::UT_SIMDataList equipInfo = pkTempData->_buddyEquipSlotInfo;
	Utility::UT_SIMDataList runeInfo = pkTempData->_buddyRuneInfo;

	int buddyLevel = buddyInfo[0].IID();
	int buddyStarLevel = buddyInfo[0].ParamA();
	int buddyPropertyID = buddyInfo[0].ParamC();
	pkBuddy->InitSoloDuleBuddyData(this, buddyID, buddyLevel, buddyStarLevel, buddyPropertyID);
	pkBuddy->GetRunePack().InitRobotBuddyRuneItemInfo(runeInfo);
	pkBuddy->GetEquipPack().InitRobotEquipInfo(equipInfo);
	pkBuddy->SetBuddyCurrentTransformID(100*buddyID+1, true);
	m_ppUsableBuddyInstance.insert(std::make_pair(buddyID, pkBuddy));
	return pkBuddy;
}

void LC_ServerPlayer::SetBuddyIndex(int index)
{
	m_nIndexAsBuddy = index;
}

void LC_ServerPlayer::SetBuddyTemplateID(int buddyID)
{
	m_nBuddyTemplateId = buddyID;
}

void LC_ServerPlayer::SetAssignedBuddyInstance(int buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	BuddyInstance* pkBuddy = pkOwnerPlayer->GetBuddyInstanceByID(buddyID);
	if(NULL != pkBuddy)
	{
		m_pAssignedBuddyInstance = pkBuddy;
	}
}

void LC_ServerPlayer::InitLogicData()
{
	LC_PlayerBase::InitLogicData();

	m_kAttributeTimer.SetTimer(60);
	m_kUpdateLogicAreaInfo.SetTimer(1.0f);
	if (m_pkTaskMap)m_pkTaskMap->Clear();

	m_iHeartBeatCount = 0;

	_initSMController("");
	_initStateMap("");

	{
		m_kUpdateAssetTimers.resize(ASSET_TIMER_MAX);
		mem::vector<Utility::UT_Timer>::iterator it = m_kUpdateAssetTimers.begin();
		for (int i = 0; it != m_kUpdateAssetTimers.end(); ++it, ++i)
		{
			it->SetTimer(assetTimers[i]);
		}
	}

	if (!IsInstance())
	{
		return;
	}

	m_DBUpdateTimer.SetTimer(_DBP_UPDATE_CYCLE_DELAY);
	m_UpdateItemTimer.SetTimer(_GSP_UPDATE_ITEM);
	m_kLogTimer.SetTimer(15);

	m_kUpdateCashOPTimer.SetTimer(_GSP_UPDATE_CASH_OP);
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::Release()
{
	m_kAttributeTimer.StopTimer();
	m_kUpdateLogicAreaInfo.StopTimer();

	if (!IsInstance())
	{
		return;
	}
	m_DBUpdateTimer.StopTimer();
	m_UpdateItemTimer.StopTimer();
	m_kLogTimer.StopTimer();

	m_kUpdateCashOPTimer.StopTimer();

	{
		mem::vector<Utility::UT_Timer>::iterator it = m_kUpdateAssetTimers.begin();

		for (; it != m_kUpdateAssetTimers.end(); ++it)
		{
			it->StopTimer();
		}
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::Update_CacheForPerf()
{
	// MainController needs no running cache data.
	m_pOwnerPlayer_Cache = GetOwnerPlayer_Impl();
	if (IsMainController())
		return;
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
	{
		//GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "LC_ServerPlayer::Update_CacheForPerf error: pOwner is NULL objid: %d", m_nOwnerPlayerId);
		return;
	}

	// cache RideCharType
	LC_PlayerBase::m_kRiderCharType = pOwner->GetRideCharTypeStruct();
	LC_ActorBase::m_usFactionID = pOwner->m_usFactionID;
	LC_PlayerBase::m_uiGuildID = pOwner->m_uiGuildID;
	LC_ActorBase::m_lLevel = pOwner->m_lLevel;
	LC_PlayerBase::m_bAIControl = pOwner->m_bAIControl;
	LC_Attacker::SetSelectTargetID( pOwner->GetSelectTargetID() );
	m_bLogicCombatFlag_Cache = pOwner->m_bLogicCombatFlag;
}

void LC_ServerPlayer::Update(float fCurrentTime, float fDeltaTime)
{
	if (fDeltaTime < 0.00001f)
		return;

	m_nUpdateResult = true;
	++m_nUpdateTimes;

	Update_CacheForPerf();
	ResetFinalDamageRateByMap();
	int nDebugDistance = UT_MathBase::LineLengthXYInt(m_kCurrentLocation, m_kTargetLocation);
	uint32_t uNowTimeStamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if( false == IsRobot() 
		&& true ==  IsMainController()
		&& false == GetbLoadFromSocietyFlag() 
		&& ( m_updateGuildStamp + 2 <= uNowTimeStamp 
		|| 0 == m_updateGuildStamp ))
	{
		// player entergame  guildinfo not load send to society get guild info 
		GetGuildDataFromDB();		
	}
	LC_ActorAttributeMap* pAttrMap = GetFinalAttributeMap();
	if (	NULL ==  m_pAssignedBuddyInstance 
		||	NULL ==  pAttrMap 
		||  NULL == m_pkMap )
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "LC_ServerPlayer::Update error:m_pAssignedBuddyInstance[0x%p],pAttrMap[0x%p],m_pkMap[0x%p]: %u ",(void*)&m_pAssignedBuddyInstance,(void*)&pAttrMap,(void*)&m_pkMap ,m_iID);
		return;
	}

	int32_t nOrigCurState = m_iCurrentState;
	int32_t nOrigNextState = m_iNextState;
	int32_t nOrigDefState = m_iDefaultState;
	int32_t nOrigPreState = m_iPreState;
	bool bValid = IsValid();
	attr_value_type nHP = GetHP();
	attr_value_type nMaxHP = pAttrMap->GetAttribute(ATT_MAX_HP);

	bool bAIControl = GetAIControl();
	float fAngle = GetForwardDirAngle();
	_UpdateForBuddyDebug( fCurrentTime, fDeltaTime );
	UpdateForBuddyController(fCurrentTime, fDeltaTime);
	//更新状态
	if ( m_pkSMController == NULL )
	{
		m_pkSMController = SM_ServerControllerFactory::GetSingletonPtr()->RequestController(SCT_SERVER_BUDDY);
	}
	if( NULL != m_pkSMController)
		m_pkSMController->Update(this, fCurrentTime, fDeltaTime);
	LC_PlayerBase::Update(fCurrentTime, fDeltaTime);
	UpdateAllBuddyInstance(fCurrentTime, fDeltaTime);
	if(NULL != m_pAssignedBuddyInstance)
		m_pAssignedBuddyInstance->Update(fCurrentTime, fDeltaTime);
	GetPKRecorder()->Update((int)fCurrentTime);
	//更新技能状态


	m_kSkillStateMap->Update(fCurrentTime);
	m_kControllerSkillStateMap->Update(fCurrentTime);

	_updatePlayerRecover(fCurrentTime);

	TickOwnerMP(fCurrentTime);

	UpdateFlyCountDown(fCurrentTime, fDeltaTime);

	CheckAnswerActivityTime();

	if(IsMainController())
	{
		UpdateACTSubInfo(fCurrentTime);
		UpdateACTSubInfo_Plus(fCurrentTime);
		UpdateTimeLimitedActivity();
		CheckSevenDayTrialFinished();
		CheckInvestmentsFinished();
		_updateNewVIPReward(fCurrentTime, fDeltaTime);

		CheckInvestmentCardFinished();
		UpdataInvestmentCardStartTime();
		CheckCanAssignNextBiographyTask();

		GetDropTimesAsset().CheckRecover(this);
		GetStarShipTimesAsset().CheckRecover(this);

		CheckResetYiZhongQinXiDamage();

		CheckUpdateSubBInfo();

		CancelBestGuildTaskDailyTask();

		UpdateRegularBossGroupInfo();

		GetTaskMap()->Update(fCurrentTime, m_nUpdateTimes);

		CheckRefreshRewardTask();

		//检测vip是否可以升级到下一级
		UpdateNewVipLevel();

		GetYuanZhengPointAsset().CheckRecover(this);

		CheckAddVIPDropItem();

		GetOpenAbilityAsset().OnCoolDownTime();

		UpdateGuildMemberInfo(true, false);
	}

	int tilte = m_kTitleAsset.UpdatePeriodSystemTitleList(uNowTimeStamp);
	if (tilte > 0)
	{
		if (m_kTitleAsset.GetCurrentTitleType() == TNT_SYSTEM_TITLE && m_kTitleAsset.GetCurrentTitle() == tilte)
		{
			m_kTitleAsset.SetCurrentTitle(TNT_NONE_TITLE, -1);
			SetCharTitle("");
			SetChangeTitleFlag(true);
		}
		RemoveSystemTitle(tilte, uNowTimeStamp);
	}

	GetSubordinateAsset().Update(uNowTimeStamp);
	GetOpenAbilityAsset().Update(uNowTimeStamp);
	GetFashionBagAsset().Update(uNowTimeStamp);
	GetSkillBookAsset().Update(uNowTimeStamp);

	//更新坐标信息
	//UpdateWorldLocationAssetData();


	UpdateChangeServerCDTime(fCurrentTime);
	UpdateVehicleSpeedUP(fCurrentTime);

	UpdateBot( fDeltaTime, fCurrentTime );

	if (GetLoadDataFromDBFlag())
	{
		_updateDaily();
		_updateAntiWallow(fCurrentTime);
		UpdateOpenBag(fCurrentTime, fDeltaTime);
		_updatePairSitRecover(fCurrentTime);
	}
	_updateCrossServerCheck(uNowTimeStamp);

	UpdateStateCDTime(fCurrentTime, fDeltaTime);

	UpdateBuddyAutoRespawnTimer(fCurrentTime, fDeltaTime);


	if(IsMainController())
	{
		GetRotaryTableAsset().UpdateRotaryTableReward(this);
	}
}
//----------------------------------------------------------
int LC_ServerPlayer::OnTitleChanged( int32_t nNewTitle )
{
	NotifyTitleLevelToTask();

	BuddyChain_CalcCount();

	AchievementEvent kEvent;
	kEvent.SetNum(nNewTitle);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_CONTROLLER_TITLE, kEvent);

	return true;
}
void LC_ServerPlayer::UpdateSync(float fCurrentTime, float fDeltaTime)
{
	if (!IsInGame() || (!IsInstance() && !IsProxy()))
	{
		return;
	}
	if ( !IsMainController() )
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if (pOwner == NULL)
			return ;
		return pOwner->UpdateSync(fCurrentTime, fDeltaTime);
	}

	//SyncActiviteBuddyProperty();	
	//注意：防止登录、转服时的时序问题导致地图为空
	for (int32_t i = ASSET_TIMER_IMM; i < ASSET_TIMER_MAX; ++i)
	{
		if (!m_kUpdateAssetTimers[i].IsExpired())
		{
			continue;
		}

		switch (i)
		{
		case ASSET_TIMER_IMM: //0.3f
			{
				//判断是否需要同步参数
				if (GetDirtyFlag(DIRTY_FLAG_ATTRIBUTE))
				{
					UT_SERVER_PROFILE(kProfile, "SyncAttributeToClient", 0.001f);
					SetDirtyFlag(DIRTY_FLAG_ATTRIBUTE, false);

					MG_RLT_NetPlayerAttribute rltMsg;
					PackNetPlayerAttribute(rltMsg);
					BroadCastToArea(rltMsg.GetMessageID(), &rltMsg);
					SetDirtyFlag(DIRTY_FLAG_SCORE, true);
				}

				//判断是否需要同步属性
				if (GetDirtyFlag(DIRTY_FLAG_PROPERTY) || GetDirtyFlag(DIRTY_FLAG_CONTROLLER_PROPERTY))
				{
					UT_SERVER_PROFILE(kProfile, "SyncPropertyToClient", 0.001f);
					SyncControllerPropertyToClient();

					SetDirtyFlag(DIRTY_FLAG_PROPERTY, false);
					SetDirtyFlag(DIRTY_FLAG_CONTROLLER_PROPERTY, false);
					
					SyncActiviteBuddyProperty();
					SetDirtyFlag(DIRTY_FLAG_SCORE, true);
				}
			}
			break;
		case ASSET_TIMER_FAST: //0.5f
			{
				//判断是否需要同步物品
				{
					UT_SERVER_PROFILE(kProfile, "CheckAndSyncPackInfo", 0.001f);
					CheckAndSyncPackInfo(fCurrentTime);
				}

				//判断是否需要同步技能CD
				if (GetDirtyFlag(DIRTY_FLAG_SKILL_CD))
				{
					UT_SERVER_PROFILE(kProfile, "SyncSkillAssetToClient", 0.001f);
					SyncSkillAssetToClient();

					SetDirtyFlag(DIRTY_FLAG_SKILL_CD, false);
				}

				//判断是否需要同步技能CD修改
				if (GetDirtyFlag(DIRTY_FLAG_SKILL_CD_MODIFY))
				{
					UT_SERVER_PROFILE(kProfile, "SyncSkillCDModifyToClient", 0.001f);
					SyncSkillCDModifyToClient();
					SetDirtyFlag(DIRTY_FLAG_SKILL_CD_MODIFY, false);
				}

				//判断是否需要同步物品CD
				if (GetDirtyFlag(DIRTY_FLAG_ITEM_CD))
				{
					UT_SERVER_PROFILE(kProfile, "SyncItemCDToClient", 0.001f);
					SyncItemCDToClient();

					SetDirtyFlag(DIRTY_FLAG_ITEM_CD, false);
				}

				LC_ActorStateMap* pkStateMap = GetStateMap();
				LC_ActorStateMap* pkControllerStateMap = GetControllerStateMap();
				if (NULL!=pkStateMap && NULL!=pkControllerStateMap)
				{
					UT_SERVER_PROFILE(kProfile, "SyncSkillStatesToClient", 0.001f);
					if (pkStateMap->GetDirtyInfo() || pkControllerStateMap->GetDirtyInfo())
					{
						SyncSkillStatesToClient(SSC_MAX_COUNT);
					}
				}

				// 金钱同步
				if (GetDirtyFlag(DIRTY_FLAG_BIND_CASH) || GetDirtyFlag(DIRTY_FLAG_UNBIND_CASH))
				{
					UT_SERVER_PROFILE(kProfile, "SyncCashToClient", 0.001f);
					SyncCashToClient();
					SetDirtyFlag(DIRTY_FLAG_BIND_CASH, false);
					SetDirtyFlag(DIRTY_FLAG_UNBIND_CASH, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_BIND_YUANBAO) || GetDirtyFlag(DIRTY_FLAG_UNBIND_YUANBAO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncYuanBaoToClient", 0.001f);
					SyncYuanBaoToClient();
					SetDirtyFlag(DIRTY_FLAG_BIND_YUANBAO, false);
					SetDirtyFlag(DIRTY_FLAG_UNBIND_YUANBAO, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_PENTACLE))
				{
					SetDirtyFlag(DIRTY_FLAG_PENTACLE, false);
					SyncPentacleToClient();
				}

				if (GetDirtyFlag(DIRTY_FLAG_CUSTOM_CASH))
				{
					SetDirtyFlag(DIRTY_FLAG_CUSTOM_CASH, false);
					SyncCustomCashToClient();
				}

				//判断是否需要广播交易
				if (GetDirtyFlag(DIRTY_FLAG_TRADEPACK))
				{
					UT_SERVER_PROFILE(kProfile, "SyncTradePackToClient", 0.001f);
					SyncTradePackToClient();
					SetDirtyFlag(DIRTY_FLAG_TRADEPACK, false);
				}

				//判断是否需要同步PK数据
				if (GetDirtyFlag(DIRTY_FLAG_PK_MODEL))
				{
					UT_SERVER_PROFILE(kProfile, "SyncPKStateToClient", 0.001f);
					GetMessageDirtyFlag().GetBroadCastFlag().SetProperty();
					SyncPKStateToClient();
					SetDirtyFlag(DIRTY_FLAG_PK_MODEL, false);
				}

				//判定是否需要同步战斗状态数据
				if (GetDirtyFlag(DIRTY_FLAG_FIGHT_STATE))
				{
					UT_SERVER_PROFILE(kProfile, "SyncFightStateToClient", 0.001f);
					SyncFightStateToClient();
					SetDirtyFlag(DIRTY_FLAG_FIGHT_STATE, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_CHESTS_IN_FOV))
				{
					UT_SERVER_PROFILE(kProfile, "SyncPlaceHolderInfoInFOVToClient", 0.001f);
					SyncPlaceHolderInfoInFOVToClient(fCurrentTime);
					SetDirtyFlag(DIRTY_FLAG_CHESTS_IN_FOV, false);
				}

				//SyncSubordinateInfo改为0.3f同步
				if (GetDirtyFlag(DIRTY_FLAG_SUBORDINATE_INFO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncSubordinateInfo", 0.001f);
					bool bDirty = false;
					SyncSubordinateInfo(bDirty);
					if (!bDirty)
					{
						SetDirtyFlag(DIRTY_FLAG_SUBORDINATE_INFO, false);
					}
				}

				//从2.1改成0.5
				if (GetDirtyFlag(DIRIY_FLAG_TITLE_NAME))
				{
					UT_SERVER_PROFILE(kProfile, "SyncTitleNameInfoToClient", 0.001f);
					SyncTitleNameInfoToClient();
					SetDirtyFlag(DIRIY_FLAG_TITLE_NAME, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_SHORTCUT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncPlayerShortcutBarToClient", 0.001f);
					SyncPlayerShortcutBarToClient();
					SetDirtyFlag(DIRTY_FLAG_SHORTCUT, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_ASSIGN_TASK))
				{
					UT_SERVER_PROFILE(kProfile, "SyncAssignTaskInfo", 0.001f);
					SyncAssignTaskInfo();
					SetDirtyFlag(DIRTY_FLAG_ASSIGN_TASK, false);
				}

				//从ASSET_TIMER_MEDIUM移过来的
				if (GetDirtyFlag(DIRTY_FLAG_COMMON_STAT_INFO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncCommonStatInfo", 0.001f);
					bool bDirty = false;
					SyncCommonStatInfo(bDirty);
					if (!bDirty)
					{
						SetDirtyFlag(DIRTY_FLAG_COMMON_STAT_INFO, false);
					}
				}

				//从ASSET_TIMER_MEDIUM移过来的
				if (m_kACTScheduleAsset.GetDirtyFlag())
				{
					UT_SERVER_PROFILE(kProfile, "SyncACTScheduleInfo", 0.001f);	
					bool bDirty = false;
					SyncACTScheduleInfo(bDirty);
					if (!bDirty)
					{
						m_kACTScheduleAsset.SetDirtyFlag(false);
					}
				}
			}
			break;
		case ASSET_TIMER_MEDIUM://0.8f
			{
				if (GetIsSyncTutorialInfo())
				{
					UT_SERVER_PROFILE(kProfile, "SyncTutorialInfo", 0.001f);
					SyncTutorialInfo();
					SetIsSyncTutorialInfo(false);
				}

				//同步快捷键数据
				if (GetIsSyncShortcutKeyInfo())
				{
					UT_SERVER_PROFILE(kProfile, "SyncShortcutKeyInfo", 0.001f);
					SyncShortcutKeyInfo();
					SetIsSyncShortcutKeyInfo(false);
				}

				//判断是否需要同步Society
				if (GetDirtyFlag(DIRTY_FLAG_SOCIETY))
				{
					UT_SERVER_PROFILE(kProfile, "SyncSocietyToClient", 0.001f);
					SyncSocietyToClient();
					SetDirtyFlag(DIRTY_FLAG_SOCIETY, false);
					SetDirtyFlag(DIRTY_FLAG_SCORE, true);
				}


				//判断是否需要同步进行中任务数据
				if (GetDirtyFlag(DIRTY_FLAG_TASK_TYPE_DATA))
				{
					UT_SERVER_PROFILE(kProfile, "SyncTaskTypeDataToClient", 0.001f);
					SyncTaskTypeDataToClient();
					SetDirtyFlag(DIRTY_FLAG_TASK_TYPE_DATA, false);
				}

				//判断是否需要同步进行中任务数据
				if (GetDirtyFlag(DIRTY_FLAG_PROCESSINGTASK))
				{
					UT_SERVER_PROFILE(kProfile, "SyncProcessingTaskMapToClient", 0.001f);
					SyncProcessingTaskMapToClient();
					SetDirtyFlag(DIRTY_FLAG_PROCESSINGTASK, false);
				}

				//判断是否需要同步完成任务数据
				if (GetDirtyFlag(DIRTY_FLAG_FINISHEDTASK))
				{
					UT_SERVER_PROFILE(kProfile, "SyncFinishedTaskMapToClient", 0.001f);
					SyncFinishedTaskMapToClient();
					SetDirtyFlag(DIRTY_FLAG_FINISHEDTASK, false);
				}

				//判断是否需要同步任务失败数据
				if (GetDirtyFlag(DIRTY_FLAG_FAIL_TASK))
				{
					UT_SERVER_PROFILE(kProfile, "SyncFailTaskMapToClient", 0.001f);
					SyncFailTaskMapToClient();
					SetDirtyFlag(DIRTY_FLAG_FAIL_TASK, false);
				}

				//判断是否需要同步技能数据
				if (GetDirtyFlag(DIRTY_FLAG_SKILLASSET))
				{
					UT_SERVER_PROFILE(kProfile, "BuildSkillCoolDownMap", 0.001f);
					//重新生成CD表
					BuildSkillCoolDownMap();
					BuildTransformSkillCoolDownMap();

					SyncSkillAssetToClient();
					SetDirtyFlag(DIRTY_FLAG_SKILLASSET, false);
				}

				//同步传送点数据
				if (GetDirtyFlag(DIRTY_FLAG_TRANSPORT_ASSET))
				{
					UT_SERVER_PROFILE(kProfile, "SyncTransportInfo", 0.001f);
					SyncTransportInfo();
					SetDirtyFlag(DIRTY_FLAG_TRANSPORT_ASSET, false);
				}
				//同步副本数据
				if (GetDirtyFlag(DIRTY_FLAG_RAID_ASSET))
				{
					UT_SERVER_PROFILE(kProfile, "SyncRaidInfo", 0.001f);
					SyncRaidInfo();
					SetDirtyFlag(DIRTY_FLAG_RAID_ASSET, false);
				}
				//同步传送门数据
				if (GetDirtyFlag(DIRTY_FLAG_PORTAL_ASSET))
				{
					UT_SERVER_PROFILE(kProfile, "SyncPortal", 0.001f);
					SyncPortal();
					SetDirtyFlag(DIRTY_FLAG_PORTAL_ASSET, false);
				}

				{
					UT_SERVER_PROFILE(kProfile, "SyncOpenBag", 0.001f);
					LC_OpenBagAsset& kOpenBagAsset = GetOpenBagAssert();
					if (kOpenBagAsset.GetDirtyFlag())
					{
						SyncOpenBag();
						kOpenBagAsset.SetDirtyFlag(false);
					}
				}

				//同步行会战
				if (GetDirtyFlag(DIRTY_FLAG_GUILDWAR_ASSET))
				{
					UT_SERVER_PROFILE(kProfile, "SyncGuildWarInfo", 0.001f);
					if (GetGuildWarAssert()->NeedSync())
					{
						SyncGuildWarInfo();
						SetDirtyFlag(DIRTY_FLAG_GUILDWAR_ASSET, false);
					}
				}

				//同步竞技场
				if (GetDirtyFlag(DIRTY_FLAG_ARENA_BATTLE_ASSET))
				{
					UT_SERVER_PROFILE(kProfile, "SyncArenaBattleToClient", 0.001f);
					SyncArenaBattleToClient();
					SetDirtyFlag(DIRTY_FLAG_ARENA_BATTLE_ASSET, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_RANK_ASSERT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncRankAssertToClient", 0.001f);
					SyncRankAssertToClient();
					SetDirtyFlag(DIRTY_FLAG_RANK_ASSERT, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_DOMAIN_ASSERT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncDomainAssertToClient", 0.001f);
					SyncDomainAssertToClient();
					SetDirtyFlag(DIRTY_FLAG_DOMAIN_ASSERT, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_CROSSREALMTEAM_ASSERT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncCrossRealmTeamInfo", 0.001f);
					SyncCrossRealmTeamInfo();
					SetDirtyFlag(DIRTY_FLAG_CROSSREALMTEAM_ASSERT, false);
				}

				//操作屏蔽列表
				if (GetDirtyFlag(DIRIY_FLAG_ACTION_FORBID))
				{
					UT_SERVER_PROFILE(kProfile, "SyncActionForbidInfoToClient", 0.001f);
					SyncActionForbidInfoToClient();
					SetDirtyFlag(DIRIY_FLAG_ACTION_FORBID, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_GAMESTORY_ASSERT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncGameStoryAsset", 0.001f);
					SyncGameStoryAsset();
					LC_GameStory_Manager* pkGameStoryMgr = SERVER_GET_GAMESTORY_MANAGER;
					if (pkGameStoryMgr)
					{
						GameStory::GSLogicIDSet storyIDs;
						GetGameStoryAsset().GetDirtyStoryIDs(storyIDs);

						//如果列表为空，就暂定为同步所有
						if (!storyIDs.empty())
						{
							pkGameStoryMgr->NotifyPlayerGameStoryContent(this, &storyIDs);
						}
					}
					SetDirtyFlag(DIRTY_FLAG_GAMESTORY_ASSERT, false);

					LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
					LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
					pkGameEvent->SetEventType(GLET_ADD_GAMESTORY_TRIALS);
					pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
					pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,	(int)GetGameStoryAsset().GetScoreDelta(GS_SCR_TP_TRIALS));
					SendGameEvent(pkGameEvent);
					pkEventManager->FreeGameEvent(pkGameEvent);

					GetGameStoryAsset().SetScoreDelta(GS_SCR_TP_TRIALS,0);
				}

				if (GetDirtyFlag(DIRTY_FLAG_VIP_ASSERT))
				{
					UT_SERVER_PROFILE(kProfile, "SyncVIPInfo", 0.001f);
					SyncVIPInfo();
					SetDirtyFlag(DIRTY_FLAG_VIP_ASSERT, false);
				}

				if (GetDirtyFlag(DIRTY_FLAG_OPEN_ABILITY_INFO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncOpenAbilityInfo", 0.001f);
					SetDirtyFlag(DIRTY_FLAG_OPEN_ABILITY_INFO, false);
					SyncOpenAbilityInfo();
				}


				if (GetDirtyFlag(DIRTY_FLAG_TREASURE_CHESTS_INFO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncTreasureChestsInfo", 0.001f);
					SetDirtyFlag(DIRTY_FLAG_TREASURE_CHESTS_INFO, false);
					SyncTreasureChestsInfo();
				}


				LC_CommonShopManager* pShopManager = LC_ServerShopManager::GetSingletonPtr();
				bool bGlobalShopDirty = (pShopManager != NULL && pShopManager->ShopAssetDirtyTime() != m_tGlobalShopAssetDirty);
				bool bSelfShopDirty = GetDirtyFlag(DIRTY_FLAG_COMMON_SHOP_INFO);
				if (bSelfShopDirty == true || bGlobalShopDirty == true)
				{
					UT_SERVER_PROFILE(kProfile, "SyncCommonShopInfo", 0.001f);
					SyncCommonShopInfo(bSelfShopDirty, bGlobalShopDirty);
					if (bGlobalShopDirty == true)
					{
						m_tGlobalShopAssetDirty = pShopManager->ShopAssetDirtyTime();
					}
					if (bSelfShopDirty == true)
					{
						SetDirtyFlag(DIRTY_FLAG_COMMON_SHOP_INFO, false);
					}
				}

				//同步AI
				if (GetDirtyFlag(DIRTY_FLAG_AI_CONTROL))
				{
					UT_SERVER_PROFILE(kProfile, "SyncAIcontrol", 0.001f);
					SyncAIcontrol();
					SetDirtyFlag(DIRTY_FLAG_AI_CONTROL, false);
				}

				//同步位置
				if (GetAIControl())
				{
					UT_SERVER_PROFILE(kProfile, "GetAIControlNotify", 0.001f);
					if (GetAIControlNotify())
					{
						SyncAIControlLocation();
						SetAIControlNotify(false);
					}
				}


				//同步位置
				if (GetDirtyFlag(DIRTY_FLAG_FASHION))
				{
					UT_SERVER_PROFILE(kProfile, "SyncFashionInfo", 0.001f);						
					SyncFashionInfo();
					SetDirtyFlag(DIRTY_FLAG_FASHION, false);
				}

				if (m_kSecretTreasureAsset.GetDirtyFlag())
				{
					UT_SERVER_PROFILE(kProfile, "SyncSecretTreasureInfo", 0.001f);						
					SyncSecretTreasureInfo();
					m_kSecretTreasureAsset.SetDirtyFlag(false);
				}

				if (m_kArenaAsset.GetDirtyFlag())
				{
					UT_SERVER_PROFILE(kProfile, "SyncArenaInfoToClient", 0.001f);
					SyncArenaInfoToClient();
					m_kArenaAsset.SetDirtyFlag(false);
					if (IsListening())
					{
						GfxWriteFmtLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "SyncArenaInfoToClient", GetID(), GetInstance());
					}
				}
			}
			break;
		case ASSET_TIMER_SLOW: //1.3f
			{
				//操作队列
				if (GetDirtyFlag(DIRTY_FLAG_ACTOR_OPERATION))
				{
					UT_SERVER_PROFILE(kProfile, "SyncActorOperationAssetToClient", 0.001f);
					SyncActorOperationAssetToClient();
					SetDirtyFlag(DIRTY_FLAG_ACTOR_OPERATION, false);
				}
			}
			break;
		case ASSET_TIMER_LAZY: //2.1f
			{
				//handle friend dync info
				LC_SocietyAsset* pkSocietyAsset = GetSocietyAsset();
				{
					UT_SERVER_PROFILE(kProfile, "SyncSocietyDynamicInfo", 0.001f);
					if (!pkSocietyAsset->GetDirtyIDs().empty())
					{
						SyncSocietyDynamicInfo();
					}
				}

				if (GetDirtyFlag(DIRTY_FLAG_GM_INFO))
				{
					UT_SERVER_PROFILE(kProfile, "SyncGMInfo", 0.001f);
					SetDirtyFlag(DIRTY_FLAG_GM_INFO, false);
					SyncGMInfo();
				}
				if (GetGameServerApp()->CheckBulletinUpdate(m_iBulletinTime))
				{
					UT_SERVER_PROFILE(kProfile, "SyncUpdateBulletin", 0.001f);
					SyncUpdateBulletin();
				}
				if (CheckAllianceDirty())
				{
					UT_SERVER_PROFILE(kProfile, "SyncUpdateAllianceInfo", 0.001f);
					SyncAllianceUnitInfo();
				}
			}
			break;
		default:
			break;
		}
	}
}
//----------------------------------------------------------
int32_t LC_ServerPlayer::GetScheduleKey()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return 0;

	if (!IsMainController())
		return pOwner->GetScheduleKey();

	return m_nGameStoryTimerId;
}

void LC_ServerPlayer::SetScheduleKey( int32_t nTimerId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
		return pOwner->SetScheduleKey(nTimerId);

	m_nGameStoryTimerId = nTimerId;
}


int32_t LC_ServerPlayer::GetReuseCount()
{
	return m_nReuseCounter;
}

void LC_ServerPlayer::ReUse()
{
	// 如果是指挥官(主控)先释放，
	m_pOwnerPlayer_Cache = NULL;
	m_nOwnerPlayerId = 0;
	ResetBuddy();
	m_nReuseCounter++;
	LC_PlayerBase::ReUse();
	m_GuildRobInfo.ReUse();
	// just for debug
	//m_bDenyBuddyDead = true;
	_uninitStateMap();

	m_CombatEventData.ReUse();

	m_nMoveActionMode = PLAYER_DEFAULT_MOVE_ACTION_MODE;
	memset(  &m_PreLoad_Lite, 0, sizeof(Protocol::PS_CharBaseInfoLite) );
	m_PreLoad_BaseData.clear();
	m_PreLoad_FullData.clear();
	m_PreLoad_Pack.clear();
	m_PreLoad_Development.clear();
	m_PreLoad_Hero.clear();
	m_PreLoad_PlayerBase.clear();
	m_PreLoad_Offline.clear();

	m_nAttackFlag = false;

	m_kMouseLocation		=	UT_Vec3Int(0, 0, 0);

	m_nTreasureMapID = 0;
	m_nTreasurePos.clear();

	m_bSendGuildPresentInfoFlag = false;
	m_nShowGuildPresentName = true;
	m_bSaveFlag = false;
	m_nDamageRankReward.clear();
	ReuseHuanJingData();

	m_nEnterServerMode = eEnterServerMode_Normal;
	m_nCharDataVersion = 0;
	m_nDailyActivity = 0;
	m_nDailyActivityRewardID.clear();
	m_nFinishMainTaskID = 0;
	m_fixMainTaskBug = true;
	m_nFinishGameStoryMapID.clear();
	m_nActivateStarVeinID.clear();
	m_nStarVeinGoalID.clear();
	m_nCheckBiography = true;

	m_nUpdateTimes = 0;

	m_RecomputerControllerScore = false;

	m_bGuildRewardFlag = true;
	m_bGuildRewardIsVaild = false;
	m_bLoginBuff = false;
	m_nNewVipLevel = 0;
	m_bNewVipState = false;
	m_nVipRewardRecord.clear();
	m_nSevenDayTrailFlag = true;
	m_nTest.clear();
	m_nFDFlag = 0;
	m_firstDailyChargeRewards.clear();
	m_collectionActivationIDMap.clear();
	m_collectionAchievementIDSet.clear();
	m_nHolyDeedRecords.clear();
	m_collectionRewardSet.clear();
	m_biographytRewardPartSet.clear();
	m_biographySet.clear();
	m_nAssignBiographySet.clear();
	m_nFinishBiographyPartSet.clear();
	m_nNextAssignBiographyPartSet.clear();
	m_nShareCDTimeRecord.clear();

	m_bACTSubSave = false;
	m_bACTSubSave_Plus = false;

	m_pPKRecorder_Cache = NULL;
	m_pTaskMap_Cache = NULL;
	m_nActiveServer_Cache  = -1;
	m_bLogicCombatFlag_Cache = false;

	m_lEXP = 0;

	m_dwUserID = 0;
	m_iHeartBeatCount = 0;

	//m_lHPFromDB = 0;
	//m_lMPFromDB = 0;
	m_nGameStoryTimerId;
	m_bIsSyncTutorialInfo = true;
	m_bIsSyncShortcutKeyInfo = true;

	m_bLoadDataFromLoginFlag = false;
	m_bLoadDataFromDB		= false;
	m_bLoadDataSuccess = false;
	m_ulDBSaveMaskFlag		= 0;

	m_bRelieveBeforeEnterMapTag = false;

	m_iLastOfflineTime = 0;

	m_bDecompositionInit = false;
	m_bDecompositionController = GetGlobalSetting.DecompositionController;
	m_nControllerItemlevel = GetGlobalSetting.ControllerItemlevel;
	m_nControllerItemGrade = GetGlobalSetting.ControllerItemGrade;
	m_bDecompositionVehicle = GetGlobalSetting.DecompositionVehicle;
	m_nVehicleItemLevel = GetGlobalSetting.VehicleItemLevel;
	m_nVehicleItemGrade = GetGlobalSetting.VehicleItemGrade;
	m_bDecompositionDevaeye = GetGlobalSetting.DecompositionDevaeye;
	m_nDevaeyeItemLevel = GetGlobalSetting.DevaeyeItemLevel;
	m_nDevaeyeItemGrade = GetGlobalSetting.DevaeyeItemGrade;
	m_bDecompositionWing = GetGlobalSetting.DecompositionWing;
	m_nWingItemLevel = GetGlobalSetting.WingItemLevel;
	m_nWingItemGrade = GetGlobalSetting.WingItemGrade;

	m_bAutoDecomposition = false;

	m_nFirstChargeTime = 0;
	m_nFirstChargeRewardState.clear();

	m_nUsedVIPExtraRewardTimes = 0;

	m_isOffline = false;
	m_offlingTime = 0;

	m_nProfilePictureID = 0;
	m_nProfilePictureRecord.clear();

	m_nSubSkillID.clear();

	m_nNewVipDropTime = 0;
	m_nVIPDropItemInfo.clear();

	m_nCurrentCommanderTitleFrameID = 1;
	m_nCommanderTitleFrameIDRecord.clear();
	m_nCommanderTitleFrameIDRecord.insert(std::make_pair(m_nCurrentCommanderTitleFrameID, true));

	m_nGuildFightScore.clear();
	m_nBestGuildActivityEndTime.clear();
	m_nAssignBestGuildTaskEndTime.clear();
	m_nStoryAssignTaskTime.clear();
	m_nPlayerLastRankIndex.clear();
	m_nPlayerCurrentRankIndex.clear();

	m_nChainFlag = 0;
	m_nEquipSuitLevel = 0;

	m_nRegularBossGroupID = 0;
	m_nRegularBossGroupCDTime = 0;

	m_BestGuildFinishedAchievement1.clear();
	m_BestGuildFinishedAchievement2.clear();
	m_nBestGuildTaskID1.clear();
	m_nBestGuildTaskID2.clear();
	m_nBestGuildCounter = 0;
	m_nBestGuildRewardFlag = false;

	m_nSettleAccountPoint = 0;

	m_nGuildFightScore.clear();
	m_nSubBInfo.clear();
	m_nSendSubInfo.clear();
	m_nRankGroupID.clear();

	m_clientLoading = false;
	m_loadTime = 0;

	m_nNewAchievementStarNum = 0;
	m_nNewAchievementRewardRecord.clear();

	m_serverViewState = SERVER_STATE_INVALID;
	SetRegisterTaskFlag(false);
	if (m_pkTaskMap)
		m_pkTaskMap->Clear();

	m_fLastSyncMoveTime	= -999999.0f;
	m_fLastServerSetLocationTime = 0.0f;
	m_fLastPickItemTime = 0.0f;

	m_lAccumulateMoveDistance = 0;

	m_fFinalDamageRate = 1.00f;
	m_nLastMapResId = 0;
	RecountTime();
	m_bInitGame = false;
	m_kWorldLocationAsset.Reset();

	m_bFollowedByGM		= false;

	m_fChangeServerCDTime = 0;

	m_fLastUpdateChangeServerTime = 0.0f;

	m_fLastHeartBeatTime = 0.0f;

	m_fLastCheckEquipEnduranceTime = 0.0f;

	m_lVIPLevel			 = 0;
	m_uiLoginIP			 = 0;
	m_kUserName			 = "";
	m_kUserName_utf8	 = "";
	m_uiClientIP	= 0;
	m_ulClientMAC	= 0;

	m_iDBUpdateTick = 0;

	m_bAddShapeShiftForbidAction = false;

	m_normalQuit = false;

	m_fCurrentHookTime = 0.0f;
	m_fCurrentHookUpdateTime = 0.0f;
	m_fTotalHookTime = 0.0f;
	m_fDeleteHookItemTime = 0.0f;
	m_fCurrentHookEfficiency = 1.0f;
	m_uiGetAddHookTimeItemDay = 0;
	m_fCurrentHookTotalTime = 0.0f;

	m_bHookForbid = false;
	m_fCalcExpTime = 0.0f;
	m_fCalcTotalTime = 0.0f;

	m_uiAuctionBuyID = 0;
	m_kAuctionBuyPrice.clear();


	m_iLastUpdateItemLogTime = 0;

	m_fFightStateBeginTime = 0.0f;
	m_fFightOutBeginTime = 0.0f;
	m_bGetGuildData = false;

	m_lAccountLoginTime = 0;

	m_lSurvivalTime = 0;
	m_fSurvivalStartTime = 0;
	m_fSpawnTime = 0;

	m_fLastPositiveActiveTime = 0.0;
	m_fLastExecuteSkillTime = 0.0;
	m_fLastIdleTime = 0;
	m_fLastTalkTime = 0;
	m_iPlayerEnterTeamPlatformTimes = 0;

	AutoEnterBornRaid = false;

	m_Adult = false;
	m_anitWallowOnlineTime = 0;
	m_SummonFinishHandle = NULL;
	m_AnswerResHandle = NULL;

	m_UpdateUserInfoTimeStamp = 0;
	m_updateToGroupFlag = false;
	m_AIControlNotify = false;
	ClearDirtyFlag();
	ClearDirtyFlagRevisionID();
	m_auction_packtype = -1;
	m_auction_index = -1;

	m_nTaskRankIndex = -1;
	m_nSendOSSLoginTime = 0;

	m_nTaskHonorPoints = 0;

	m_nAssignEscortTaskTime = 0;
	m_nEscortTimes = 0;
	m_nRobbingTimes = 0;

	m_nYiZhongQinXiState = false;
	m_nYiZhongQinXiEndTime = 0;

	m_bUpdataRedis = false;
	m_nAnswerActivityEndTime = 0;
	m_nCommanderTitle = 0;
	m_nFirstKillBossRewardRecord.clear();
	m_nKillBossRecord.clear();
	m_nAnswerRecord.clear();
	m_nAnswerAccPoint = ANSWER_NOT_JOIN;
	m_nAnswerGuildAccPoint = 0;
	m_nAnswerRewardRecord.clear();

	m_nSevenDayEndTime1 = 0;
	m_nSevenDayEndTime2 = 0;

	m_nFirstDayLoginRewardTime = 0;

	m_nSTRewardRecord.clear();

	m_nCollectBossJP = 0;

	m_nDailyFlag = false;
	m_nMainTaskFinishCount = 0;
	m_nRefreshRewardTaskTimes = 0;
	m_nAcceptRewardTaskTimes = 0;
	m_nRewardTaskEndTime = 0;
	m_nMainTaskReachRewardRecord.clear();

	m_nChapterRewardRecord.clear();
	m_nChapterRaidStarNum.clear();
	m_nTotalRaidStarNum = 0;

	m_nYiJiTuXiStageRewardRecord.clear();
	m_nYiJiTuXiEndTime = 0;
	m_nYiJiTuXiSendFlag = false;

	m_nYiJiXunBaoStageRewardRecord.clear();
	m_nYiJiXunBaoEndTime = 0;
	m_nYiJiXunBaoSendFlag = false;

	m_nPetIslandsStageRewardRecord.clear();
	m_nPetIslandsEndTime = 0;
	m_nPetIslandsSendFlag = false;

	m_nResetAllCommonStatID.clear();

	m_bKillNPCExpFlag = false;

	m_nTimeLimitedRecord.clear();
	m_ShopTimes.clear();
	m_ShopStartTime.clear();
	m_nUnbindYuanbaoShopItemInfo.clear();
	m_nGuildShopItemInfo.clear();
	m_nMoneyCourageShopItemInfo.clear();
	m_nBossJPShopItemInfo.clear();
	m_nLimitShopItemInfo.clear();
	m_nInvestmentCardRecord.clear();
	m_nInvestmentCardFreeRewardID.clear();
	m_nInvestmentCardHighRewardID.clear();
	m_nInvestmentCardStartTime.clear();

	m_CloseFlyFlagTime = 0;
	m_CloseFlyFlagBeginTime = 0;
	m_LastJumpBeginTime = 0;
	m_LastJumpEndTime = 0;
	m_VigorStamp = 0;
	m_JumpDodgePoint = 0;
	m_JumpDodgeTimer.SetTimer(JUMP_DODGE_RECOVER_INTVAL);
	m_MPRecoverTimer.SetTimer(MP_RECOVER_INTVAL);
	m_dailyCleanMap.clear();
	m_flowerSendCnt.clear();
	m_rewardGainMap.clear();
	m_SubSystemAttributeMap.clear();

	m_AIControlStand = false;
	m_dailyCleanStramp = 0;

	m_nDebugCode = 10;
	m_nDebugCodeFlag = false;
	m_nUpdateResult = true;
	//弹射起步
	m_RunSpeedUpDirty = false;
	m_fRecvMoveTick = 0.0f;
	m_tGlobalShopAssetDirty = 0;

	m_lastLcLockedID	= 0;

	//activity
	m_kSecretTreasureAsset.Clear();
	m_kACTScheduleAsset.Clear();

	m_kResourceAlert.Clear();
	m_nGoalAsset.Clear();
	m_nKillControllerAccountDailyCount = 0;

	m_nGameStoryJoinTimes.clear();
	m_nJoinTimeStamp = 0;
	m_kBoneSoulSkill.clear();
	m_kStarsRuneAsset.Clear();
	m_kBoneSoulAsset.Clear();
	m_kMeltAsset.Clear();

	m_nIsRobot = false;

	m_nPlaceHolderLogicID.clear();

	m_ControllerPlayerRespawnData.m_DeadTime = 0;
	m_ControllerPlayerRespawnData.m_CurRespawnTime = 5;
	m_ControllerPlayerRespawnData.m_TimeStamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	m_bLotteryStat = false;

	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		m_nSkillBookSlotDataInfo[i].clear();
	}

	m_PetInstanceMgr.ReUse();
	GetBuddySchemeMgr().Clear();
	m_BuddyChain.Init();
	m_CombatRecorderMgr.ReUse();
	m_NewVIPReward.ReUse();
	m_nDataStatus = 0;

	m_nResourceRetrieveMgr.ReUse();

	m_QuickRaidAsset.Clear();

	m_showCoreArrMap.Clear();
	// 普攻cd
	memset(&m_NormalAttackCD, 0, sizeof(m_NormalAttackCD));

	m_n360MicroSignInAssert.Reuse();

	m_nCommanderSubEquipPack_Vehicle.Init(LC_SUB_TP_VEHICLE, GetGlobalSetting.MountPackSize);
	m_nCommanderSubEquipPack_DevaEye.Init(LC_SUB_TP_DEVA_EYE, GetGlobalSetting.PetPackSize);
	m_nCommanderSubEquipPack_Muhun.Init(LC_SUB_TP_MUHUN, GetGlobalSetting.WingPackSize);
	m_RuneData.Init();
	m_BuddyEquipData.Init();
}
//----------------------------------------------------------
void LC_ServerPlayer::UpdateWithServerTime(int lServerTime)
{
	//注意：防止登录、转服时的时序问题导致地图为空
	if (NULL == m_pkMap)
	{
		return;
	}

	GetPKRecorder()->Update(lServerTime);

	//更新战斗状态
	m_kHatredList.Update((float)lServerTime, 6.0f);
	//通知客户端战斗状态改变
	bool bPVPFightState = m_kHatredList.GetPlayerHatredCount() > 0 ? true : false;
	bool bPVEFightState = m_kHatredList.GetNPCHatredCount() > 0 ? true : false;
	SetFightState(bPVPFightState, bPVEFightState);

	if (!IsInstance())
	{
		return;
	}

	//逻辑区域
	if (m_kUpdateLogicAreaInfo.IsExpired())
	{
		UpdateLogicAreaInfo();
	}

	if (m_DBUpdateTimer.IsExpired())
	{
		UpdateToDBServer();
	}


	if (m_kUpdateCashOPTimer.IsExpired())
	{
		UpdateCashOP();
	}

#if PRISON_OPEN
	LC_ServerPrisonManager* pkPrisonMgr = NULL;
	pkPrisonMgr = SERVER_GET_PRISON_MANAGER();
	if (pkPrisonMgr)
	{
		pkPrisonMgr->ImprisonPlayer(this);
	}
#endif

	if (lServerTime - m_fLastOSSPosTime > 5.0f)
	{
		ClearAccumulateMoveDistance();
		m_fLastOSSPosTime = (float)lServerTime;
	}
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::ResetLogicAreaID(LC_LogicAreaInfo* pkAreaInfo)
{
	int iLogicAreaID = pkAreaInfo ? pkAreaInfo->lLogicAreaID : 0;
	int lPreLogicAreaType = -1;
	int lNewLogicAreaType = -1;
	if (m_lCurrentLogicAreaID != iLogicAreaID)
	{
		int lPreLogicAreaID = m_lCurrentLogicAreaID;
		m_lCurrentLogicAreaID = iLogicAreaID;

		CF_LogicAreaFunc::DataEntry* pkNewLogicAreaFunc = CSVHelper::GetLogicAreaFuncData(pkAreaInfo ? pkAreaInfo->lLogicAreaFuncID : 0);
		if (pkNewLogicAreaFunc)
		{
			if (NULL == m_pkLogicAreaFunc || m_pkLogicAreaFunc->_bTeam != pkNewLogicAreaFunc->_bTeam)
			{
				if (pkNewLogicAreaFunc->_bTeam)
				{
					m_kActionForbid.RemoveActionForbid(LAFT_GROUP, LAF_GROUP_MAX_COUNT);
				}
				else if (!pkNewLogicAreaFunc->_bTeam)
				{
					m_kActionForbid.AddActionForbid(LAFT_GROUP, LAF_GROUP_MAX_COUNT);
				}
			}

			if (NULL == m_pkLogicAreaFunc || m_pkLogicAreaFunc->_bTrade != pkNewLogicAreaFunc->_bTrade)
			{
				if (pkNewLogicAreaFunc->_bTrade)
				{
					m_kActionForbid.RemoveActionForbid(LAFT_TRADE, LAF_TRADE_MAX_COUNT);
				}
				else
				{
					m_kActionForbid.AddActionForbid(LAFT_TRADE, LAF_TRADE_MAX_COUNT);
				}
			}

			if (NULL == m_pkLogicAreaFunc || m_pkLogicAreaFunc->_bSignUp != pkNewLogicAreaFunc->_bSignUp)
			{
				if (pkNewLogicAreaFunc->_bSignUp)
				{
					m_kActionForbid.RemoveActionForbid(LAFT_ARENA, LAF_ARENA_MAX_COUNT);
					m_kActionForbid.RemoveActionForbid(LAFT_TEAMPLATFORM, LAF_TEAMPLATFORM_MAX_COUNT);
				}
				else
				{
					m_kActionForbid.AddActionForbid(LAFT_ARENA, LAF_ARENA_MAX_COUNT);
					m_kActionForbid.AddActionForbid(LAFT_TEAMPLATFORM, LAF_TEAMPLATFORM_MAX_COUNT);
				}
			}

			//区域不允许骑乘
			if (!pkNewLogicAreaFunc->_bRide && GetRiderCharType() > 0)
			{
				//驱散所有可能的骑乘状态
				DeactiveSkillState(3, 99, 0, 0);
			}

			lNewLogicAreaType = pkNewLogicAreaFunc->_lAreaType;

			if ( m_pkLogicAreaFunc )
				lPreLogicAreaType = m_pkLogicAreaFunc->_lAreaType;
		}

		m_pkLogicAreaFunc = pkNewLogicAreaFunc;
		LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
		GameStory::LC_StoryLogic_Manager* pkStroyLogicMgr = SERVER_GET_STORYLOGIC_MANAGER;
		LC_ServerMapLogic_Place* pkMapLogic = pkWorldManager->GetMapLogic(GetMapLogicID());
		if (pkMapLogic != NULL)
		{
			pkMapLogic->PlayerChangeLogicArea(this, lPreLogicAreaID, iLogicAreaID, lPreLogicAreaType, lNewLogicAreaType);
			//game
			pkStroyLogicMgr->PlayerLogicAreaChanged(this, pkMapLogic, lPreLogicAreaID);
		}
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::UpdateLogicAreaInfo()
{
	if (!GetLoadDataFromDBFlag())
	{
		//return;
	}
	LC_LogicMapManager* pkLogicAreaManager = (LC_LogicMapManager*)LC_LogicMapManager::GetSingletonPtr();
	LC_LogicAreaInfo* kAreaInfo = pkLogicAreaManager->QueryAreaInfo(m_kCurrentLocation, GetMapResID());
	if (kAreaInfo == NULL)
	{
		return;
	}
	ResetLogicAreaID(kAreaInfo);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::UpdateWorldLocationAssetData(bool nChangeMap)
{
	if (!IsInstance())
	{
		return;
	}
	LC_WorldLocationAssetEntry* pkTemporaryEntry = m_kWorldLocationAsset.GetWorldLocationAssetEntryByIndex(WLT_TEMPORARY);
	LC_WorldLocationAssetEntry* pkPermanentEntry = m_kWorldLocationAsset.GetWorldLocationAssetEntryByIndex(WLT_PERMANENT);
	LC_WorldLocationAssetEntry* pkFrontierEntry = m_kWorldLocationAsset.GetWorldLocationAssetEntryByIndex(WLT_FRONTIER);

	int32_t lCurrentMapLogicType = GetMapLogicType();
	//int32_t lMapResID = GetMapResID();

	//MT_HOOK_MAP  MT_NORMAL  MT_NEWBEE都属于永久坐标数据 WLT_PERMANENT
	CF_WorldMapList::DataEntry* pData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if ( pData == NULL )
		return;
	int32_t lMapResID = GetMapResID();
	int32_t lMapLogicID = GetMapLogicID();
	int32_t lMapLogicType = GetMapLogicType();

	LC_ServerPlayer* pCurBuddy = NULL;
	if(nChangeMap)//主控坐标 切换地图是应去下标为0的 buddy
	{
		pCurBuddy = GetNormalCurrentActivateBuddy();
	}
	else
	{
		pCurBuddy = GetCurrentActivateBuddy();
	}
	if ( pCurBuddy == NULL )
		return;
	const Utility::UT_Vec3Int& rCurPos = pCurBuddy->GetCurrentLocation();
	if ( rCurPos.x == 1 || rCurPos.y == 1 )
		return;
	if (
		IS_COMMON_MAP(lCurrentMapLogicType)
		|| MT_HOOK_MAP==lCurrentMapLogicType 
		|| (MT_WATCHTOWER==lCurrentMapLogicType&& GetMapResID()==GetGlobalSetting.BestGuildMapID)
		)
	{
		pkPermanentEntry->SetValid(true);
		pkPermanentEntry->SetMapLogicID(lMapLogicID);
		pkPermanentEntry->SetMapLogicType(lMapLogicType);
		pkPermanentEntry->SetMapResID(lMapResID);
		pkPermanentEntry->SetLocation(rCurPos);

		if (UT_ServerHelper::IsInCross(this) && LC_Helper::IsAllianceMap(lMapResID))
		{
			pkFrontierEntry->SetValid(true);
			pkFrontierEntry->SetMapLogicID(lMapLogicID);
			pkFrontierEntry->SetMapLogicType(lMapLogicType);
			pkFrontierEntry->SetMapResID(lMapResID);
			pkFrontierEntry->SetLocation(rCurPos);
		}
		pkTemporaryEntry->SetValid(false);
	}
	else
	{
		pkTemporaryEntry->SetValid(true);
		pkTemporaryEntry->SetMapLogicID(lMapLogicID);
		pkTemporaryEntry->SetMapLogicType(lMapLogicType);
		pkTemporaryEntry->SetMapResID(lMapResID);
		pkTemporaryEntry->SetLocation(rCurPos);
	}
	
}
//------------------------------------------------------------------------
void LC_ServerPlayer::ClearTemporaryLocationAssetData()
{
	LC_WorldLocationAssetEntry* pkTemporaryEntry = m_kWorldLocationAsset.GetWorldLocationAssetEntryByIndex(WLT_TEMPORARY);
	pkTemporaryEntry->SetValid(false);
	pkTemporaryEntry->SetMapLogicID(0);
	pkTemporaryEntry->SetMapLogicType(0);
	pkTemporaryEntry->SetMapResID(0);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::UpdateVehicleSpeedUP(float fDelta)
{
	LC_TaskTypeData* kData = GetTaskMap()->GetTypeData(STT_GAMESTORY);
	if ( kData && !kData->m_kInTaskMap.empty() ) 
	{
		return ;
	}

	if (m_RunSpeedUpDirty)
	{
		m_RunSpeedUpDirty = false;

		if (GetPKRecorder()->GetFightState() || GetRiderCharType() == 0 || !GetSyncPlayerMove())
		{
			ResetRunTime(0.0f);
			DeactiveSkillState(VEHICLE_RUN_SPEEDUP_ID);
			SetRunMoveTick(0.0f);
		}
		else if (GetSyncPlayerMove())
			ResetRunTime(VEHICLE_RUN_SPEEDUP_T);
	}

	if (GetRunMoveTick() > 0 && GET_PROCESS_TIME - GetRunMoveTick() > 1.0f)
	{
		ResetRunTime(0.0f);
		DeactiveSkillState(VEHICLE_RUN_SPEEDUP_ID);
		SetRunMoveTick(0.0f);
	}

	AccumulateRunTime(fDelta);
	if (IsDown())
	{
		ResetRunTime(0.0f);
		//【去掉】坐骑5秒内未到达目的地，加一个加速buff
		//ActiveSkillState(VEHICLE_RUN_SPEEDUP_ID, 0, 0);
	}
}
//------------------------------------------------------------------------

void LC_ServerPlayer::SetForceLocalRelive( bool bInput )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;
	if ( !IsMainController() )
		return pOwner->SetForceLocalRelive(bInput);
	m_bForceLocalRelive = bInput;
}

bool LC_ServerPlayer::GetForceLocalRelive()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;
	if ( !IsMainController() )
		return pOwner->GetForceLocalRelive();

	return m_bForceLocalRelive;
}

bool LC_ServerPlayer::GetBuddyReliveFlag()
{
	return m_bBuddyRelive;
}

bool LC_ServerPlayer::GetOwnerReliveFlag_Recover()
{
	return m_bReliveFlag_Recover;
}

void LC_ServerPlayer::SetOwnerReliveFlag_Recover(bool bFlag)
{
	m_bReliveFlag_Recover = bFlag;
}

void LC_ServerPlayer::TrySwitchCurrentBuddy( object_id_type nPlayerId )
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;
	LC_ServerPlayer* pDeadPlayer = m_pOwnerPlayer->GetCurrentActivateBuddy();
	if ( pDeadPlayer == NULL )
		return;
	if ( pDeadPlayer->GetID() != nPlayerId )
		return;
	SwitchCurrentBuddy();
}

void LC_ServerPlayer::SetDead(bool bIsDead)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(bIsDead == m_bIsDead)
	{
		return;
	}

	LC_ActorBase::SetDead(bIsDead);

	if (m_bIsDead)
	{
		m_kSkillStateMap->ClearStatesOnDead();
	}
	if (m_bIsDead)
	{
		SyncDead();
		GetPKRecorder()->SetInEvilState(false);
		TrySwitchCurrentBuddy(m_iID);
		// Move to syncDead, avoid the fucking invalid message order

	}
	if (bIsDead && (GetDenyDead() || GetDenyBuddyDead()) == false)
	{
		if (LC_Helper::isInArena(this) == false)
		{
			CostItemEndurance(true, 0, true);
		}

		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (NULL == pkGameEvent)
		{
			return;
		}
		pkGameEvent->SetEventType(GLET_PLAYER_DIE);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
		pkGameEvent->SetEventParam(EP_DIE_PLAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_DIE_MAP_ID, GetMapResID());
		pkEventManager->InsertGameEvent(pkGameEvent);
	}
}

void LC_ServerPlayer::SyncDead( bool bSyncOnly)
{
	if (GetDead())
	{
		MG_RLT_PlayerDead rltMsg;
		LC_ServerWorldManager* pkServerWorldMgr = SERVER_GET_WORLD_MANAGER();
		LC_ServerMapLogic_Place* mapLogic = pkServerWorldMgr->GetMapLogic(GetMapLogicID());
		if (mapLogic != NULL)
		{
			mapLogic->GetRespawnTime(GetID(), rltMsg.m_CurRespawnTime, rltMsg.m_SafeRespawnTime);
		}

		rltMsg.m_lPlayerID = m_iID;
		SendMsgToClient(MGPT_RLT_PLAYER_DEAD, &rltMsg);
		LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
		if (m_pOwnerPlayer == NULL)
			return;
		if(m_pAssignedBuddyInstance)
			m_pOwnerPlayer->OnBuddyDead(m_iID, m_pAssignedBuddyInstance->GetTemplateID(), bSyncOnly);
		m_pOwnerPlayer->OnOwnerDead(m_iID,rltMsg.m_CurRespawnTime, rltMsg.m_SafeRespawnTime );
		m_pOwnerPlayer->SyncActiviteBuddyProperty();
	}
}
void LC_ServerPlayer::SyncACTActiveRewardInfo(int32_t id, int32_t count)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SyncACTActiveRewardInfo(id, count);
	}

	MG_SyncACTActiveRewardInfo syncMsg;
	syncMsg.m_nID = id;
	syncMsg.m_nCount = count;
	SendMsgToClient(MGPT_SYNC_ACT_ACTIVE_REWARD_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncBossFirstKillInfo(int32_t npcID, BossFirstKillPlayerInfo& info)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncBossFirstKillInfo(npcID, info);
	}

	int size = info.rewardPlayerBornCharType.size();
	if(size!=info.rewardPlayerCommanderTitleID.size() || size!=info.rewardPlayerLevel.size() || size!=info.rewardPlayerName.size() || size!=info.rewardPlayerCommanderTitleFrameID.size())
	{
		return;
	}

	MG_SyncBossFirstKillInfo syncMsg;
	syncMsg.m_nBossID = npcID;
	syncMsg.m_bKillInfo = false;

	syncMsg.m_nKillerInfo.m_nPlayerName = info.killerName;
	syncMsg.m_nKillerInfo.m_nCommanderTitleID = info.killerCommanderTitleID;
	syncMsg.m_nKillerInfo.m_nPlayerLevel = info.killerLevel;
	syncMsg.m_nKillerInfo.m_nBornCharType = info.killerbornCharType;
	syncMsg.m_nKillerInfo.m_nCommanderTitleFrameID = info.KillerCommanderTitleFrameID;

	int num = info.rewardPlayerBornCharType.size();
	for(int i=0; i<num; ++i)
	{
		PS_BossFirstKillPlayerInfo rewardPlayerInfo;
		rewardPlayerInfo.m_nPlayerName = info.rewardPlayerName[i];
		rewardPlayerInfo.m_nPlayerLevel = info.rewardPlayerLevel[i];
		rewardPlayerInfo.m_nCommanderTitleID = info.rewardPlayerCommanderTitleID[i];
		rewardPlayerInfo.m_nBornCharType = info.rewardPlayerBornCharType[i];
		rewardPlayerInfo.m_nCommanderTitleFrameID = info.rewardPlayerCommanderTitleFrameID[i];

		syncMsg.m_nRewardPlayerInfo.push_back(rewardPlayerInfo);
	}

	SendMsgToClient(MGPT_SYNC_BOSS_FIRST_KILL_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncAllBuddyRuneLevelnfo()
{
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)\
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
		{
			continue;
		}

		pkBuddy->SyncBuddyRuneStarLevelInfo();
	}
}
void LC_ServerPlayer::SyncACTActiveRewardInfoB(int32_t id, int32_t count)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncACTActiveRewardInfoB(id, count);
	}

	MG_SyncACTActiveRewardInfoB syncMsg;
	syncMsg.m_nID = id;
	syncMsg.m_nCount = count;
	SendMsgToClient(MGPT_SYNC_ACT_ACTIVE_REWARD_INFO_B, &syncMsg);
}
//-----------------------------------------------------------
void LC_ServerPlayer::SetIsShowFashion(bool bIsShowFashion)
{
	if (GetIsShowFashion() != bIsShowFashion)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetEquip();
	}

	m_bIsShowFashion = bIsShowFashion;
}
//-----------------------------------------------------------
int LC_ServerPlayer::CheckEnterMap_Task( int32_t nMapResId )
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
		return pOwnerPlayer->CheckEnterMap_Task(nMapResId);

	// Check Task status.
	LC_TaskMap* pTaskMap = GetTaskMap();
	if ( pTaskMap == NULL )
		return false;

	CF_WorldMapList::DataEntry* pNewMap = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(nMapResId);
	if (pNewMap == NULL)
		return false;

	int32_t nTaskId = pNewMap->_iPresentTaskLimit;
	if (nTaskId == INVALID_TASK_ID)
		return true;

	int nTaskState = pTaskMap->GetTaskState(nTaskId);
	if (nTaskState != NT_PROCESSING  )
		return false;

	return true;
}

int LC_ServerPlayer::GetControllerLevel()
{
	if (!IsMainController())
		return 0;
	return m_lLevel;
}

int LC_ServerPlayer::GetLevel()
{
	return LC_ActorBase::m_lLevel;
}

const LC_BackPackEntry* LC_ServerPlayer::GetItemEntryByItemID(int32_t itemID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return NULL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetItemEntryByItemID(itemID);
	}

	LC_PackAsset* pkPackAsset = GetPackAsset();
	if(NULL == pkPackAsset)
	{
		return NULL;
	}

	const LC_BackPackEntry* pkItemEntry = NULL;
	{
		//基础槽
		LC_BasicPack& pkBasicSlot = pkPackAsset->GetBasicPack();
		for(int i = 0; i < pkBasicSlot.GetCapacity(); i++)
		{
			pkItemEntry = &(pkBasicSlot.m_aData[i]);
			if(pkItemEntry->GetBackPackValueByType(LPSFET_VALID) && pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID)==itemID)
			{
				return pkItemEntry;
			}
		}
	}

	{
		//buddy宝具槽
		pkItemEntry = GetRuneDataFromBuddyRune(itemID);
		if(NULL != pkItemEntry)
		{
			return pkItemEntry;
		}
	}

	{
		//仓库里的装备
		LC_WarehousePack& pkWarehouseSlot = pkPackAsset->GetWarehousePack();
		for(int i = 0; i < pkWarehouseSlot.GetCapacity(); i++)
		{
			pkItemEntry = &(pkWarehouseSlot.m_aData[i]);
			if(pkItemEntry->GetBackPackValueByType(LPSFET_VALID) && pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID)==itemID)
			{
				return pkItemEntry;
			}
		}
	}

	return pkItemEntry;
}
void LC_ServerPlayer::SetPlayerBaseLevel(int lLevel)
{
	LC_ActorBase::SetLevel(lLevel);
}
void LC_ServerPlayer::SetAllPlayerBaseLevel(int lLevel)
{
	// 等级同步给 其他两个小伙伴(PlayerBase)
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResult = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResult)
			continue;
		pResult->SetPlayerBaseLevel(lLevel);
	}
}

void LC_ServerPlayer::SetLevel(int lLevel, bool bInit)
{
	int PreLevel = GetLevel();
	if (PreLevel == lLevel)
	{
		return;
	}

	CF_LevelUp* pkCSVLevelUp = CF_LevelUp::GetSingletonPtr();
	int max_level = pkCSVLevelUp->GetCurrentMaxID();
	const CF_LevelUp::DataEntry* pkOwnerData = pkCSVLevelUp->GetEntryPtr(lLevel);
	if(lLevel > max_level || NULL==pkOwnerData)
		return;

	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
	m_dataChangeFlag.GetBroadCastFlag().SetControllerProperty();

	GetSubordinateAsset()._disapplyReg(this);
	GetGreatKungFuAsset()._disapplyReg(this);
	GetVIPAsset()._disapplyReg(this);

	LC_ActorBase::SetLevel(lLevel);
	oss_360_log_level_up(lLevel, this);
	//限时活动事件
	TimeLimitEvent actEvent;
	actEvent.controllerLevel = lLevel;
	TimeLimitInfoEvent(actEvent);

	//玩家第一次登陆时候 或者 在游戏中升等级
	if(m_nCharDataVersion==0 || false==bInit)
	{
		AchievementEvent kEvent;
		kEvent.SetNum(lLevel);
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_LEVEL, kEvent);

		BuddyChain_CalcCount();
		UpdateRankInfoToRedis(Sub_Reward_Type_CommanderLevel);

		NotifyControllerLevel();
	}

	GetVIPAsset()._applyReg(this);
	GetGreatKungFuAsset()._applyReg(this);
	GetSubordinateAsset()._applyReg(this);

	SetDirtyFlag(DIRTY_FLAG_SCORE, true);

	GetOpenAbilityAsset().OnCharLevelUp();

	if (PreLevel < USER_RETURN_GIFTS_LEVEL && lLevel >= USER_RETURN_GIFTS_LEVEL && m_userGiftReturn == 0)
	{
		_autoRecharge();
	}

	//用于更新排行榜
	if (GetLoadDataFromDBFlag())
	{
		UpdateRankUserValueByRankType(Rank_Type_Level);
		SetCharInfoDirty();
	}

	if (PreLevel>0)
	{
		SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
		if (lLevel>PLAYER_SYNC_DB_LEVEL)
		{
			AsyncUpdateToDBServer();
		}
	}

	if(PreLevel>0)
	{
		LC_ThirdPlatformReport::GetSingletonPtr()->OnCharLevelUp(this);
	}
	OnRefreshPlayerLevel(bInit);

}

void LC_ServerPlayer::SetRobot()
{
	if(!m_nIsRobot)
	{
		m_nIsRobot = true;
	}
}

bool LC_ServerPlayer::IsRobot()
{
	return m_nIsRobot;
}

int LC_ServerPlayer::CheckEnterPlanesMap(int iDstMapLogicID, int lDstMapResID)
{
	return true;
}



//------------------------------------------------------------------------
void LC_ServerPlayer::PostEnterMap(int iMapLogicID, int lMapResID, int lMapLogicType)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer)
		return;
	if(!IsMainController())
		return pOwnerPlayer->PostEnterMap(iMapLogicID, lMapResID, lMapLogicType);
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResult = pOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResult)
			continue;
		pResult->ClearCombatStatusAsBuddy();
	}
	GetWorldLocationAsset()->SetForceLocation(false);
}

void LC_ServerPlayer::TransferBattlePlaybackMap(int32_t mapResId)
{
	if(!IsMainController())
	{
		return;
	}

	MG_Message errorMsg;
	errorMsg.m_iMessageID = RE_FAIL;
	CF_WorldMapList::DataEntry* pkData = CF_WorldMapList::GetSingletonPtr()->GetEntryPtr(mapResId);
	if (pkData==NULL || pkData->_iMapLogicType!=MT_ARENA_PLAYFIGHT)
	{
		SendMsgToClient(MGPT_MESSAGE, &errorMsg);
		return;
	}

	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* pkLogic = (LC_ServerMapLogic_Place*)pkWorldManager->CreateServerMapLogic(0, mapResId, pkData->_iMapLogicType);
	if (pkLogic == NULL)
	{
		SendMsgToClient(MGPT_MESSAGE, &errorMsg);
		return;
	}

	errorMsg.m_iMessageID = pkWorldManager->RequestChangePlayerLocation(this, LMIOT_TRANSFER, pkLogic->GetMapLogicID(), mapResId, UT_Vec3Int());
	if(RE_SUCCESS != errorMsg.m_iMessageID)
	{
		SendMsgToClient(MGPT_MESSAGE, &errorMsg);
	}
}

ResultType LC_ServerPlayer::TransferMap(int transferType, int mapID, int index, int serverID, bool tribuMap, int8_t lineNum)
{	
	const unique_id_impl& playerInstance = GetInstance();
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap pkOwnerPlayer == NULL error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
		return RE_FAIL;
	}
	if(!IsMainController())
	{
		return pkOwnerPlayer->TransferMap(transferType, mapID, index, serverID, tribuMap, lineNum);
	}
	LC_ServerPlayerEnterLeaveManager* enterLeaveManager = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
	CF_WorldMapList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapID);
	if(NULL == pkData)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap pkData == NULL error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
		return RE_FAIL;
	}

	LC_MapBase* pCurMap = GetMap();
	if(NULL == pCurMap)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap pCurMap == NULL error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
		return RE_FAIL;
	}
	int globalLineNum = pCurMap->GetGlobalLineNum();
	int curMapResID = pCurMap->GetMapResID();
	if(globalLineNum == lineNum 
		&& curMapResID == mapID 
		&& TT_TRANSPORT_RAID_MAP != transferType)
	{
		MG_RLT_Jumper rltMsg;
		rltMsg.m_iResult = RE_CHANGE_SERVER_FAIL_SAME_SERVER;
		rltMsg.m_uiCharID = GetInstance();
		SendMsgToClient(MGPT_GC_RLT_JUMPER, &rltMsg);

		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap pCurMap == NULL error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,globalLineNum:%d,curMapResID:%d ",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID(),globalLineNum,curMapResID);
		return RE_FAIL;
	}

	CF_EndlessTower::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_EndlessTower>(pkData->_iStoryID);
	if(NULL != pkEntry && !checkEnterEndLessTower(pkEntry))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap checkEnterEndLessTower error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,storyid:%d",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID(),pkData->_iStoryID);
		return RE_PRE_ENDLESSTOWER_NOTPASS;
	}

	CF_BossInvade::DataEntry* pkBossData = SafeGetCSVFileDataEntryPtr<CF_BossInvade>(pkData->_iStoryID);
	if(NULL != pkBossData && !GetYiZhongQinXiState())
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap GetYiZhongQinXiState error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d,storyid:%d",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID(),pkData->_iStoryID);
		return RE_FAIL;
	}

	ResultType res = CheckCanEnter(mapID);
	if(RE_SUCCESS != res)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap CheckCanEnter res:%d, transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d",
			res, transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
		return res;
	}

	int32_t nTargetServer = 0;
	if(serverID > 0)
		nTargetServer= GSNodeNetwork::Instance().getEntryIdByMergeId(serverID);		
	if(nTargetServer > 0 && nTargetServer == UT_ServerHelper::GetServerId())
		nTargetServer = 0;

	if(nTargetServer == 0)
		res = enterLeaveManager->TransferToServerByType(this, mapID, transferType, index, tribuMap, lineNum);
	else
		res = enterLeaveManager->RequstCrossChangeLocation(this, nTargetServer, mapID, transferType, index);

	if(RE_SUCCESS == res)
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, " TransferMap RE_SUCCESS ,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
	else
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " TransferMap RE_SUCCESS != res error,transferType:%d,mapID:%d,index:%d,serverID:%d,tribuMap:%d,lineNum:%d,cid:%d,citizenship:%d,uid:%d",transferType,mapID,index,serverID,tribuMap,(int32_t)lineNum,playerInstance.detail(),playerInstance.catagory(),GetUserID());
	return res;
}

void	LC_ServerPlayer::ChangeMap(int iMapLogicID, int lMapResID, int lMapLogicType, const Utility::UT_Vec3Int& rkLocation, bool bAsBuddy)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_ERROR_FILELINE, "ChangeMap-serverid:%d, id:%d, mapResID:%d, mapLogicID:%d, x:%d, y:%d r1", 
			GetGameServerID(), GetID(), lMapResID, iMapLogicID, rkLocation.x, rkLocation.y);
		return;
	}

	const unique_id_impl& playerInstance = GetInstance();
	CF_WorldMapList::DataEntry* pNewMap = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(lMapResID);
	if (pNewMap == NULL)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_ERROR_FILELINE, "ChangeMap-serverid:%d, id:%d, mapResID:%d, mapLogicID:%d, x:%d, y:%d c_id:%d, c_citizenship:%d, c_uid:%d r2", 
			GetGameServerID(), GetID(), lMapResID, iMapLogicID, rkLocation.x, rkLocation.y, playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return;
	}

	uint32_t nSrcResGroup = pNewMap->_iResourceGroup;
	uint32_t nDstResGroup = pNewMap->_iResourceGroup;
	GameLogic::LC_WorldLocationAsset* pOwnerLocationAsset = pkOwnerPlayer->GetWorldLocationAsset();

	CF_WorldMapList::DataEntry* pCurMap = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if (pCurMap)
	{
		nSrcResGroup = pCurMap->_iResourceGroup;
	}
	//切换坐标前，强制打断技能
	ForceFinishCurrentSkill();
	UpdateDirtyFlag(DIRTY_FLAG_PROPERTY);
	int lCurrentMapLogicID = GetMapLogicID();
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
#if 1
	if (m_nOrigMapLogicType != -1 && !( m_nOrigMapLogicType < MT_TRANSCRIPTION_BEGIN && lMapLogicType < MT_TRANSCRIPTION_BEGIN))
	{
		m_bSwitchLogicMap = true;
	}
	else
	{
		m_bSwitchLogicMap = false;
	}
#endif
	m_nOrigMapLogicType = lMapLogicType;
	if (lCurrentMapLogicID != iMapLogicID)
	{
		if ( lCurrentMapLogicID != -1 && GetMapResID() != lMapResID )
		{
			// OnLeaveScene
			PreLeaveMap(GetMapResID(), lMapResID);
		}
		// Recover buddy scheme goes here.
		ResetLogicAreaID(0);
		pkWorldManager->RemoveObjectFromMap(this);
	}

	//设置场地PK属性
	SetPlaceCanPK(pNewMap->_CanPK);

	OnRltTransferChangePkMode(GetMapResID(), lMapResID);

	oss_360_log_map( GetLevel(), GetMapResID(), lMapResID, this );
	bool bSoloDulePlay = false;

	bSoloDulePlay = pkOwnerPlayer->GetSoloDulePlay();

	Utility::UT_Vec3Int loc = rkLocation;
	if ( !IsCurrentActivateBuddy() && !bSoloDulePlay )
	{
		//UT_PathFindHelp::GenRandomPosInCircle2(lMapResID, rkLocation,GetGlobalSetting.nMaxBuddyFollowDistance,loc);
	}
	if (nSrcResGroup == nDstResGroup && pCurMap && lMapResID != GetMapResID() )
	{
		if ( !pOwnerLocationAsset->GetForceLocation() || nSrcResGroup != lMapResID )
		{
			loc = GetTargetLocation();
		}
		if ( lMapResID != nSrcResGroup )
			SetForceLocalRelive( true );
		else
			SetForceLocalRelive( false );
	}
	else
	{
		SetForceLocalRelive( false );
	}
	SetCurrentLocation(loc);
	SetTargetLocation(loc);
	SetLastMoveCheckLocation(loc);	
	SetLastServerSetLocationTime(GET_PROCESS_TIME);
	SetMapResID(lMapResID);
	SetMapLogicType(lMapLogicType);

	if (lCurrentMapLogicID != iMapLogicID)
	{
		if(false == pkWorldManager->AddObjectToMap(iMapLogicID, this))
		{
			Utility::UT_Vec3Int* p_currentLocation = GetCurrentLocationPtr();
			// not need check p_currentLocation is NULL
			if (false == UT_ServerHelper::GetRandomLocationXYZ(*p_currentLocation,lMapResID,GetCitizenship()))
			{
				GfxWriteLog(LOG_ERROR_FILELINE, LOG_ERROR_FILELINE, "ChangeMap-serverid:%d, id:%d, mapResID:%d, mapLogicID:%d, x:%d, y:%d c_id:%d, c_citizenship:%d, c_uid:%d, cx:%d, cy:%d r3", 
					GetGameServerID(), GetID(), lMapResID, iMapLogicID, rkLocation.x, rkLocation.y, playerInstance.detail(), playerInstance.catagory(), GetUserID(), p_currentLocation->x, p_currentLocation->y);
				return;
			}
			if(false == pkWorldManager->AddObjectToMap(iMapLogicID, this))
			{
				GfxWriteLog(LOG_ERROR_FILELINE, LOG_ERROR_FILELINE, "ChangeMap-serverid:%d, id:%d, mapResID:%d, mapLogicID:%d, x:%d, y:%d c_id:%d, c_citizenship:%d, c_uid:%d, cx:%d, cy:%d r4", 
					GetGameServerID(), GetID(), lMapResID, iMapLogicID, rkLocation.x, rkLocation.y, playerInstance.detail(), playerInstance.catagory(), GetUserID(), p_currentLocation->x, p_currentLocation->y);
				return;
			}
		}

		//不同地图间切换，需要修改loading状态
		ClientLoading();
	}

	if (IS_PLAYER_ID(GetID()))
		SyncBuddyData_Activate();

	SyncLocationInfo();
	UpdateWorldLocationAssetData(true);
	int premap = GetMapRaodmap();
	if (lMapResID != premap)
	{
		MapRoadmapManager* inst = SafeGetSingleton<MapRoadmapManager>();
		CF_MapCategory::DataEntry* roadmap = inst->GetRoadmap(lMapResID);
		if (roadmap != NULL && roadmap->_lMapClassicID != 0)
		{
			CF_MapCategory::DataEntry* preroadmap = inst->GetRoadmap(premap);
			if (preroadmap == NULL || preroadmap->_lID < roadmap->_lID)
			{
				SetMapRaodmap(roadmap->_lMaprResID);
			}
		}
	}

	//更新组队信息
	LC_ServerPlayerGroupManager* pkPlayerGroupManager = (LC_ServerPlayerGroupManager*)SERVER_GET_PLAYER_GROUP_MANAGER();
	LC_ServerPlayerGroup* group = pkPlayerGroupManager->GetPlayerGroup(m_Instance);
	if (group != NULL)
	{
		LC_PlayerGroupEntry* entry = group->FindGroupEntryInMemberListByPlayerID(GetID());
		if (entry != NULL)
		{
			pkPlayerGroupManager->UpdatePlayerState(m_Instance, entry->GetState());
		}
	}
	m_dataChangeFlag.GetUniCastFlag().SetSysnAll();

	UpdateLogicAreaInfo();
	SetLockedTargetID(INVALID_ACTOR_ID);
	if (bAsBuddy == false)
	{
		//int nOffsetX[MAX_ACTIVE_BUDDY_NUM] = { 0, 1, 0 };
		//int nOffsetY[MAX_ACTIVE_BUDDY_NUM] = { 1, 0, -1 };
		for (int i = 1; i < MAX_ACTIVE_BUDDY_NUM ; i++)
		{
			Utility::UT_Vec3Int pos;
			pos = m_kCurrentLocation;
			//ModifyOffsetLocationByIndex(i, pos);
			//修复坐标--每次切换地图都需要修复坐标（Q不是主控也是需要修复坐标的）--可能还是存在站位bug的
			if ( m_nCurrentBuddyIndex == 0 || GetSoloDulePlay() )
			{
				ModifyOffsetLocationByIndex(i, pos);
				//	//pos.x += GetGlobalSetting.nInitPosOffset * nOffsetX[i] ;
				//	//pos.y += GetGlobalSetting.nInitPosOffset * nOffsetY[i];
			}
			LC_ServerPlayer* pResult = pkOwnerPlayer->GetActivateBuddyByIndex(i);
			IF_A_NA_PLAYER(pResult)
				continue;
			pResult->ChangeMap( iMapLogicID, lMapResID, lMapLogicType, pos, true);
		}

		for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
		{
			LC_ServerPlayer* pResult =  pkOwnerPlayer->GetActivateBuddyByIndex(i);
			IF_A_NA_PLAYER(pResult)
				continue;
			pResult->SyncEnterFov();
		}
	}
	return;
}
//----------------------------------------------------------------------------
static inline bool IS_ANTIWALLOW_RELATED(int32_t sys_func_type)
{
	switch (sys_func_type)
	{
	case SYS_FUNC_TP_SIT:
	case SYS_FUNC_TP_FARM:
	case SYS_FUNC_TP_PICKUP:
	case SYS_FUNC_TP_TASK_FINISH:
	case SYS_FUNC_TP_TASK_LIVENESS:
	case SYS_FUNC_TP_RAID_SETTLE:
	case SYS_FUNC_TP_PROMOTE:
	case SYS_FUNC_TP_STORY_REWARD:
	case SYS_FUNC_TP_CMN_STAT_REWARD:
	case SYS_FUNC_TP_CMN_STAT_REPLEVY:
	case SYS_FUNC_TP_OFFLINE:
		return true;
		break;
	default:
		break;
	}
	return false;
}
bool LC_ServerPlayer::AddEXP(attr_value_type lExp, int32_t eSrcType, uint64_t lSrcTypeID, bool bIgnoreEXPRate,int nLogCode,const vector<int> &Params)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;
	if(!IsMainController())
	{
		return m_pOwnerPlayer->AddEXP(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}

	if (!IsInstance())
	{
		return false;
	}

	attr_value_type real_exp = lExp;

	//有些经验获得的途径是不计入加成的
	switch (eSrcType)
	{
	case SYS_FUNC_TP_FARM:
		{
			real_exp = Utility::Round2Int64(real_exp *  LC_Helper::GetAttributeRate(this, ATT_EXP_RATE));
		}
		break;
	default:
		bIgnoreEXPRate = true;
		break;
	}

	if (IS_ANTIWALLOW_RELATED(eSrcType))
	{
		real_exp = Utility::Round2Int64(real_exp * GetAntiWallowStateQuotiety());
	}
	if (real_exp <= 0)
	{
		if (lExp > 0)
		{
			if (WALLOW == GetAntiWallowState())
			{
				real_exp = 0;
			}
			else
			{
				real_exp = 1;
			}
		}
		else
		{
			real_exp = 0;
		}
	}
	if (real_exp > 0)
	{
		SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);

		if(nLogCode)
			RecordCashOperateLog(this, nLogCode, GET_OPERATE, CT_USER_EXP, real_exp,(int)GetEXP(), Params);
		
		AddEXP(real_exp);
		m_kResourceAlert.AddResource(SPEC_ITEM_TID_EXP, eSrcType, real_exp);

		if (IS_PROFIT_STAT_RELATED(eSrcType))
		{
			//profit stat
			CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
			if (pkMapEntry && pkMapEntry->_ProfitStat > 0)
			{
				GetCommonStatAsset().OnGotExp(real_exp, eSrcType);
			}
		}
	}

	UpdateDirtyFlag(DIRTY_FLAG_CONTROLLER_PROPERTY);
	return true;
}
bool LC_ServerPlayer::AddEXP(attr_value_type lExp)
{
	if(lExp <= 0)
	{
		return false;
	}

	attr_value_type newExp = GetEXP()+lExp;
	int totalLevel = 0;
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();

	if (IS_PLAYER_ID(m_iID) || IS_PLAYER_CLONE_ID(m_iID))
	{		
		attr_value_type lNeedLevelUpExp = LC_Helper::GetLevelUpExp(GetLevel() + 1);
		while(newExp >= lNeedLevelUpExp)
		{
			totalLevel += 1;
			newExp -= lNeedLevelUpExp;
		}

		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_EXP_CHANGED);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
			pkGameEvent->SetEventParam(EP_EXP_CHANGED_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_EXP_CHANGED_EXP_VALUE, lNeedLevelUpExp);
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	SetLevel(GetLevel()+totalLevel);
	SetEXP(newExp);

	return true;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::ReduceEXP(attr_value_type lExp, int32_t eSrcType)
{
	if (lExp<=0 || lExp<GetEXP())
	{
		return false;
	}

	SetEXP(GetEXP() - lExp);
	return true;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::ReduceSP(attr_value_type lValue, int32_t eSrcType)
{
	if (!IsInstance())
	{
		return false;
	}

	if (lValue <= 0)
	{
		return false;
	}
	SetSkillLevelupPoints(GetSkillLevelupPoints() - lValue);
	SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
	return true;
}

void LC_ServerPlayer::AddSkillLevelupPoints(attr_value_type Value, int32_t eSrcType, uint64_t lSrcTypeID, bool AntiWallow)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;
	if(!IsMainController())
	{
		return m_pOwnerPlayer->AddSkillLevelupPoints(Value, eSrcType, lSrcTypeID, AntiWallow);
	}

	if (AntiWallow)
	{
		float rate = GetAntiWallowStateQuotiety();
		Value = (attr_value_type)(Value * rate);
	}
	if (Value <= 0)
	{
		return;
	}
	SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
	LC_PlayerBase::AddSkillLevelupPoints(Value, eSrcType, lSrcTypeID);
	m_kResourceAlert.AddResource(SPEC_ITEM_TID_SP, eSrcType, Value);
	SK_SkillEventManagerBase* pkEventManager = ENGINE_GET_SKILL_EVENT_MANAGER();
	SK_SkillEvent* pkEvent = pkEventManager->AllocEvent();
	if (NULL != pkEvent)
	{
		pkEvent->SetEventType(SETE_RECOVER);
		pkEvent->SetSrcActorID(GetID());
		pkEvent->SetDstActorID(GetID());
		pkEvent->SetLogicID(0);
		pkEvent->SetParam(SK_RecoverEvent::SEP_ITEM_ID, 0);
		pkEvent->SetParam(SK_RecoverEvent::SEP_RECOVER_TYPE, SK_RecoverEvent::SRT_SP);
		pkEvent->SetParam(SK_RecoverEvent::SEP_RECOVER_BASE, Value);
		pkEventManager->AddEvent(pkEvent);

		if (IS_PROFIT_STAT_RELATED(eSrcType))
		{
			//profit stat
			CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
			if (pkMapEntry && pkMapEntry->_ProfitStat > 0)
			{
				GetCommonStatAsset().OnGotSP(Value, eSrcType);
			}
		}
	}
}

int32_t LC_ServerPlayer::GetUpdateResult()
{
	return m_nUpdateResult;
}

void LC_ServerPlayer::SetDebugCode( int nInput )
{
	m_nDebugCodeFlag = true;
	m_nDebugCode = nInput;
}

void LC_ServerPlayer::AddLotteryConsumeUnBindYuanBao(int num)
{
	if(num <= 0)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddLotteryConsumeUnBindYuanBao(num);
	}

	m_nLotteryConsumeUnBindYuanBaoCount += num;
	SyncLotteryConsumeUnBindYuanBao();
}

int32_t LC_ServerPlayer::GetLotteryConsumeUnBindYuanBao()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetLotteryConsumeUnBindYuanBao();
	}

	return m_nLotteryConsumeUnBindYuanBaoCount;
}
void LC_ServerPlayer::SyncLotteryConsumeUnBindYuanBao()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncLotteryConsumeUnBindYuanBao();
	}

	MG_SyncLotteryConsumeUnBindYuanBao msg;
	msg.m_nLotteryConsumeUnBindYuanBaoCount = GetLotteryConsumeUnBindYuanBao();
	SendMsgToClient(MGPT_SYNCLOTTERY_CONSUMEUNBINDYUANBAO, &msg);
}
void LC_ServerPlayer::NoticeAddAccount(int32_t eSrcType, MoneyType llCash, int32_t param)
{
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "NoticeAddAccount playerID:%d, playerName:%s, goalID:%d, value:%d, storyID:%d\n", GetID(), GetOwnerCharName().c_str(), eSrcType, llCash, param);

	if(eSrcType > 0)
	{
		AddGoalAccountByID(eSrcType, llCash);
	}

	bool tag = UT_ServerHelper::CheckStoryIsActive(param);
	if(false == tag)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "NoticeAddAccount-CheckStoryIsActive-error playerID:%d, playerName:%s, storyID:%d\n", GetID(), GetOwnerCharName().c_str(), param);
	}

	//活动是否开启
	if(0!=param && false!=tag)
	{
		std::vector<uint64_t> vecId;
		vecId.push_back(GetInstance());
		UT_ServerHelper::ReqPlayerOfflineToDb(OfflinePlayerFromDBType::OPFDT_GUILD_FIGHT_OP_SCORE,vecId,param,llCash,0,0,0);
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "NoticeAddAccount-add playerID:%d, playerName:%s, storyID:%d, value:%d\n", GetID(), GetOwnerCharName().c_str(), param, llCash);
	}
}

bool LC_ServerPlayer::Charge(int32_t chargeMoney, int32_t reason,const std::string& strOrderId)
{
	if(chargeMoney <= 0)
	{
		return false;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->Charge(chargeMoney, reason,strOrderId);
	}

	//每日首充
	OpenFDeposit();

	static Activity::ACT_ScheduleDataManager* pkACTDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	pkACTDataMgr->NewOnCharge(this, CT_CASH_REALMONEY, chargeMoney);
	
	//兑换货币
	CF_Charge::DataEntryMapExternIterator kIter = CF_Charge::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_Charge::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		MoneyType money = pkEntry->_rate * chargeMoney;
		AddCash(money, (CashType)pkEntry->_cashType, reason, chargeMoney);
		if(pkEntry->_mainMoney)
			oss_360_log_recharge( money,chargeMoney,GetCashNumByCashType((CashType)pkEntry->_cashType), strOrderId.c_str(), "", this );
	}
	
	return true;
}

bool LC_ServerPlayer::AddCash(MoneyType llCash, CashType eCashType, int32_t eSrcType, uint64_t lSrcTypeID, int32_t param, bool AntiWallow, MoneyType* pllDelta,int nLogCode,const vector<int> &Params)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->AddCash(llCash, eCashType, eSrcType, lSrcTypeID, param, AntiWallow, pllDelta);
	}

	if (llCash <= 0 || eCashType < CT_VIP_CREDIT || eCashType >= CT_CASH_COUNT)
	{
		return false;
	}

	if(eCashType == CT_VIP_CREDIT)
	{
		LC_CashOPCluster* pkCashOPCluster = GetCommonShopAsset().GetCashOPCluster(eCashType);
		if (pkCashOPCluster)
		{
			LC_CashOPRecord* pkCashOPRecord = pkCashOPCluster->GetOPRecord(CS_OP_TP_DEPOSIT);
			if (pkCashOPRecord)
			{
				pkCashOPRecord->RegOP(eSrcType, llCash);
				return AddCredit(llCash, eCashType, eSrcType);
			}
		}
		return false;
	}

	//CT_VIP_CREDIT不走下面的逻辑
	if (!IS_ANTIWALLOW_RELATED(eSrcType))
	{
		AntiWallow = false;
	}

	MoneyType llCurrentMoney = GetCashNumByCashType(eCashType);
	if (llCurrentMoney >= MAX_CHAR_MONEY)
	{
		return false;
	}

	if(CT_SKYARENA_POINT == eCashType)
	{
		CheckSkyRankNewSeanson();
		if(GetSkyArenaHonorValue() + llCash >= GetSkyArenaGradeLimitPoint())
		{
			UT_ServerHelper::NotifyServerErrorCode(this, RE_SKYARENA_SOLO_HONOR_LIMIT);
			llCash = GetSkyArenaGradeLimitPoint() - GetSkyArenaHonorValue();
			if(llCash <= 0)
			{
				return false;
			}
			
		}
		
		AddSkyArenaHonorValue(llCash);
		
	}

	if(eCashType==CT_UNBIND_CASH && AntiWallow)
	{
		float rate = GetAntiWallowStateQuotiety();
		llCash = (MoneyType)(llCash * rate);
	}

	//增加数值型资源埋点日志
	RecordCashOperateLog(this, nLogCode, GET_OPERATE,eCashType, llCash,(int)llCurrentMoney, Params);

	SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
	MoneyType llResultMoney = UT_MathBase::MinInt64(llCurrentMoney + llCash, MAX_CHAR_MONEY);
	SetCash(llResultMoney, eCashType);

	MoneyType llDelta = llResultMoney - llCurrentMoney;
	if(pllDelta != NULL)
	{
		*pllDelta = llDelta;
	}

	//通知成就系统
	AchievementEvent kEvent;
	kEvent.SetConditionInfo(eCashType);
	kEvent.SetNum(llCash);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ADD_CASH, kEvent);	

	int32_t iTypeID = GetSpecialItemTypeID(eCashType);
	if (eCashType == CT_UNBIND_CASH && eSrcType == SYS_FUNC_TP_PICKUP)
	{
		LC_ResourceRecord& kMoneyCache = GetOssResourceCache(iTypeID, eSrcType);
		kMoneyCache.AddCount((uint64_t)llDelta);
		if (kMoneyCache.GetCount() > OSS_CACHE_PICKUP_MONEY)
		{
			oss_role_moneyflow(this, llCurrentMoney, llResultMoney, kMoneyCache.GetCount(), eCashType, eSrcType, 0, lSrcTypeID);
			kMoneyCache.ResetCount();
		}
	}
	else
	{
		oss_role_moneyflow(this, llCurrentMoney, llResultMoney, llDelta, eCashType, eSrcType, 0, lSrcTypeID);
	}

	if (llDelta > 0)
	{
		m_kResourceAlert.AddResource(iTypeID, eSrcType, (uint64_t)llDelta);
	}

	//通知客户端
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_ADD_CASH);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
		pkGameEvent->SetEventParam(EP_ADD_CASH_PlAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_ADD_CASH_COUNT, (int32_t)llDelta);
		pkGameEvent->SetEventParam(EP_ADD_CASH_TYPE, eCashType);
		pkGameEvent->SetEventParam(EP_ADD_CASH_SRC_TYPE, eSrcType);
		pkGameEvent->SetEventParam(EP_ADD_CASH_MAP_ID, GetMapResID());
		pkEventManager->InsertGameEvent(pkGameEvent);
	}

	LC_GameEvent* pkGameEvent1 = pkEventManager->AllocGameEvent();
	if (pkGameEvent1)
	{
		pkGameEvent1->SetEventType(GLET_TOTAL_ADD_CASH);
		pkGameEvent1->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
		pkGameEvent1->SetEventParam(EP_TOTAL_ADD_CASH_PlAYER_ID, GetID());
		pkGameEvent1->SetEventParam(EP_TOTAL_ADD_CASH_COUNT, llResultMoney);
		pkGameEvent1->SetEventParam(EP_TOTAL_ADD_CASH_TYPE, eCashType);
		pkGameEvent1->SetEventParam(EP_TOTAL_ADD_CASH_SRC_TYPE, eSrcType);
		pkGameEvent1->SetEventParam(EP_TOTAL_ADD_CASH_MAP_ID, GetMapResID());
		pkEventManager->InsertGameEvent(pkGameEvent1);
	}

	switch(eCashType)
	{
	case CT_UNBIND_CASH:
		{
			if (IS_PROFIT_STAT_RELATED(eSrcType))
			{
				CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
				if (pkMapEntry && pkMapEntry->_ProfitStat > 0)
				{
					GetCommonStatAsset().OnGotCash(llDelta, eSrcType);
				}
			}
			oss_360_log_gold(llDelta, eSrcType, llResultMoney, 0, this );
		}
		break;
	case CT_UNBIND_YUANBAO:
		{
			if(eSrcType==SYS_FUNC_TP_CHARGE)
			{
				GetCommonStatAsset().OnRecharge((uint32_t)llDelta, this);
				GetGameServerApp()->GetDailyDataReport().OnRecharge(GetInstance(), eSrcType, llCash);
				{
					static Activity::ACT_ScheduleDataManager* pkACTDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
					//pkACTDataMgr->OnCharge(this, (uint32_t)llDelta);
					pkACTDataMgr->NewOnCharge(this, CT_UNBIND_YUANBAO, (uint32_t)llDelta);
				}
				if (IS_CHARGE_STATISTICAL(eSrcType))
				{
					static GameServerApp* pkApp = GetGameServerApp();
					std::string sKey = pkApp->GetRedisServerPredix(GetActiveServer()) + PLATFORM_BONUS_POOL_KEY;
					MoneyType iBonus = GET_RECHARGE_BONUS(llDelta);
					ASYNC_REDIS_REQUEST_NCB(pkApp->GetRedisChannel(), &redispp::Connection::incrBy, sKey, (int)iBonus);
					AddRechargeRecord(llDelta);
				}			
				LC_ThirdPlatformReport::GetSingletonPtr()->OnCharRecharge(this);
				SetLastRechargeTime(GET_CURRENT_TIMESTAMP_IN_SECONDS());
			}
			else
			{
				yb_income(this, (int32_t)llDelta, Utility::Int2String(eSrcType).c_str());
			}
			oss_360_log_yb_income(llDelta, llResultMoney, eSrcType, m_pOwnerPlayer);
			AsyncUpdateToDBServer();
		}
		break;
	case CT_PENTACLE:
		{
			if(IS_RECHARGE_RELATED(eSrcType))
			{
				static Activity::ACT_ScheduleDataManager* pkACTDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
				pkACTDataMgr->NewOnCharge(this, CT_PENTACLE, (uint32_t)llDelta);
			}
			oss_360_log_giftmoney_income(llDelta,  llResultMoney, eSrcType, this );
		}
		break;
	case CT_ACCOUNT_POINT:
		{
			NoticeAddAccount(eSrcType, llCash, param);
		}
		break;
	case CT_CASH_TYPE_29:
		{
			//积分上榜
			if(UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Monkey))
			{
				MoneyType llCurrentMoney = GetCashType29().GetMoney();
				UpdatePointToRedis(CT_CASH_TYPE_29, llCurrentMoney);
			}
		}
		break;
	default:
		break;
	}

	OnCharge( eCashType, llDelta );
	return true;
}

//----------------------------------------------------------------------------
bool LC_ServerPlayer::ReduceCash(MoneyType llCash, CashType eCashType, int32_t eSrcType, uint64_t lSrcTypeID, int nLogCode ,const vector<int> &Params)
{
	//节日货币不允许调ReduceCash接口
	if(eCashType == CT_CASH_TYPE_37)
	{
		return true;
	}

	if (llCash == 0)
	{
		return true;
	}

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->ReduceCash(llCash, eCashType, eSrcType, lSrcTypeID);
	}

	if (llCash<0 || eCashType < CT_BIND_CASH || eCashType >= CT_CASH_COUNT)
	{
		return false;
	}

	bool bSuccessReduce = false;
	MoneyType llMoneyReduce1 = 0;
	MoneyType llMoneyReduce2 = 0;
	CashType  eMoneyReduceType1 = eCashType;
	CashType  eMoneyReduceType2 = eCashType;
	MoneyType llMoneyReduceBefore = 0, llMoneyReduceAfter = 0;

	LC_Money* pkMoney = NULL;
	GetCashByCashType(eCashType, &pkMoney);
	if(NULL == pkMoney)
	{
		return false;
	}

	llMoneyReduceBefore = pkMoney->GetMoney();
	if (llMoneyReduceBefore >= llCash)
	{
		if(eCashType != CT_CASH_TYPE_28)
		{			
			pkMoney->SetMoney(llMoneyReduceBefore - llCash);
		}
		llMoneyReduce1 = llCash;
		bSuccessReduce = true;
	}
	llMoneyReduceAfter = pkMoney->GetMoney();

	switch (eCashType)
	{
	case CT_BIND_CASH:
		{
			LC_Money* pkMoney2 = NULL;
			GetCashByCashType(CT_UNBIND_CASH, &pkMoney2);
			if(NULL != pkMoney)
			{
				if (!bSuccessReduce && (llMoneyReduceAfter + pkMoney2->GetMoney()) >= llCash)
				{
					llMoneyReduce1 = llMoneyReduceAfter;
					MoneyType llReduceUnBindCash = llCash - llMoneyReduceAfter;
					llMoneyReduce2 = llReduceUnBindCash;
					eMoneyReduceType2 = CT_UNBIND_CASH;
					pkMoney->SetMoney(0);
					pkMoney2->SetMoney(pkMoney2->GetMoney() - llReduceUnBindCash);
					bSuccessReduce = true;
				};
			}
		}
		break;
	case CT_UNBIND_CASH:
		{
			if (bSuccessReduce)
			{
				MG_Rlt_ReduceCash msg;
				msg.m_iConsumeCashNum = llMoneyReduce1;
				msg.m_iCode = RE_USE_CASH_SUCCESS;
				SendMsgToClient(MGPT_RLT_REDUCE_CASH, &msg);
			}
		}
		break;
	case CT_BIND_YUANBAO:
		{
			if (bSuccessReduce)
			{
				oss_role_comsume(this, eSrcType, 0 , llCash, 0, 0, 0, 0, "");
			}
		}
		break;
	case CT_UNBIND_YUANBAO:
		{
			if (bSuccessReduce)
			{
				if (IS_CONSUME_RELATED(eSrcType))
				{
					GetVIPAsset().AddCreditConsume((int32_t)llCash);
					GetCommonStatAsset().OnCreditConsume((uint32_t)llCash);
					GetGameServerApp()->GetDailyDataReport().OnYBConsume(llCash);
					{
						static Activity::ACT_ScheduleDataManager* pkACTDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
						pkACTDataMgr->OnConsume(this, (uint32_t)llCash);
					}
				}
				oss_role_comsume(this, eSrcType, llCash , 0, 0, 0, 0, 0, "");
				oss_360_log_yb_expend( llCash, GetUnBindYuanBao().GetMoney(), eSrcType, 0, this );
			}
		}
		break;
	case CT_PENTACLE:
		{
			if (bSuccessReduce)
			{
				oss_360_log_giftmoney_expend(llCash,  llMoneyReduceAfter, eSrcType, this );
			}
		}break;
	case CT_GUILD_MONEY:
		{
			//消耗数值型资源埋点日志
			RecordCashOperateLog(this, nLogCode, CONSUME_OPERATE,CT_GUILD_MONEY, llCash,-1, Params);
			DelGuildMoney(llCash, eSrcType, lSrcTypeID);
		}
		break;
	case CT_CASH_TYPE_28:
		{
			GetYuanZhengPointAsset().ReduceTimes(this, llCash);
		}
		break;
	}

	if (!bSuccessReduce)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "[%d]Reduce Cash Error[%lld][%d][%d][%lld]", GetID(), llCash, eCashType, eSrcType, lSrcTypeID);
		return false;
	}

	AchievementEvent kEvent;
	kEvent.SetConditionInfo(eCashType);
	kEvent.SetNum(llCash);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_CONSUME_CASH, kEvent);

	SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
	//消耗数值型资源埋点日志
	RecordCashOperateLog(this, nLogCode, CONSUME_OPERATE,eCashType, llCash,llMoneyReduceBefore, Params);

	oss_role_moneyflow(this, llMoneyReduceBefore, llMoneyReduceAfter, -llCash, eCashType, eSrcType, 1, lSrcTypeID);
	LC_CashOPCluster* pkCashOPCluster = GetCommonShopAsset().GetCashOPCluster(eCashType);
	if (pkCashOPCluster)
	{
		LC_CashOPRecord* pkCashOPRecord = pkCashOPCluster->GetOPRecord(CS_OP_TP_CONSUME);
		if (pkCashOPRecord)
		{
			pkCashOPRecord->RegOP(eSrcType, - llCash);
		}
	}

	//通知客户端
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	if (llMoneyReduce1 > 0)
	{
		LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_REDUCE_CASH);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_PlAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_COUNT,	(int)llMoneyReduce1);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_TYPE,		eMoneyReduceType1);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_SRC_TYPE,	eSrcType);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_MAP_ID,	GetMapResID());
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	if (llMoneyReduce2 > 0)
	{
		LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_REDUCE_CASH);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_PlAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_COUNT,	(int)llMoneyReduce2);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_TYPE,		eMoneyReduceType2);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_SRC_TYPE,	eSrcType);
			pkGameEvent->SetEventParam(EP_REDUCE_CASH_MAP_ID,	GetMapResID());
			SendGameEvent(pkGameEvent);
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	OnReduce(eCashType, llCash);
	return true;
}

bool LC_ServerPlayer::SetCash(MoneyType llCash, CashType eCashType)
{
	if (!IsInstance())
	{
		return false;
	}
	if (llCash <= 0)
	{
		return false;
	}
	if (eCashType < CT_BIND_CASH || eCashType >= CT_CASH_COUNT)
	{
		return false;
	}
	MoneyType llResultMoney = llCash;

	LC_Money* pkMoney = NULL;
	GetCashByCashType(eCashType, &pkMoney);
	if(NULL == pkMoney)
	{
		return false;
	}

	MoneyType llCurrentMoney = pkMoney->GetMoney();
	MoneyType llMaxMoney = MAX_CHAR_MONEY;
	if (llCurrentMoney == llMaxMoney)
	{
		return false;
	}

	if (llResultMoney > llMaxMoney)
	{
		llResultMoney = llMaxMoney;
	}

	switch (eCashType)
	{
	case CT_BIND_CASH:
		{
			UpdateDirtyFlag(DIRTY_FLAG_BIND_CASH);
		}
		break;
	case CT_UNBIND_CASH:
		{
			UpdateDirtyFlag(DIRTY_FLAG_UNBIND_CASH);
		}
		break;
	case CT_BIND_YUANBAO:
		{
			UpdateDirtyFlag(DIRTY_FLAG_BIND_YUANBAO);
		}
		break;
	case CT_UNBIND_YUANBAO:
		{
			UpdateDirtyFlag(DIRTY_FLAG_UNBIND_YUANBAO);
		}
		break;
	case CT_WAREHOUSE_UNBIND_CASH:
		{
			m_kPackAsset.UpdateDirtyFlag(PACK_TYPE_WAREHOUSE);
		}
		break;
	case CT_PENTACLE:
		{
			UpdateDirtyFlag(DIRTY_FLAG_PENTACLE);
		}
		break;
	default:
		{
			UpdateDirtyFlag(DIRTY_FLAG_CUSTOM_CASH);
		}
		break;
	}

	pkMoney->SetMoney(llResultMoney);
	return true;
}

void LC_ServerPlayer::ResetCash(CashType eCashType)
{
	if (eCashType < CT_BIND_CASH || eCashType >= CT_CASH_COUNT)
	{
		return;
	}

	LC_Money* pkMoney = NULL;
	GetCashByCashType(eCashType, &pkMoney);
	if(NULL == pkMoney)
	{
		return;
	}

	pkMoney->SetMoney(0);

	switch (eCashType)
	{
	case CT_BIND_CASH:
		{
			UpdateDirtyFlag(DIRTY_FLAG_BIND_CASH);
		}
		break;
	case CT_UNBIND_CASH:
		{
			UpdateDirtyFlag(DIRTY_FLAG_UNBIND_CASH);
		}
		break;
	case CT_BIND_YUANBAO:
		{
			UpdateDirtyFlag(DIRTY_FLAG_BIND_YUANBAO);
		}
		break;
	case CT_UNBIND_YUANBAO:
		{
			UpdateDirtyFlag(DIRTY_FLAG_UNBIND_YUANBAO);
		}
		break;
	case CT_WAREHOUSE_UNBIND_CASH:
		{
			m_kPackAsset.UpdateDirtyFlag(PACK_TYPE_WAREHOUSE);
		}
		break;
	case CT_PENTACLE:
		{
			UpdateDirtyFlag(DIRTY_FLAG_PENTACLE);
		}
		break;
	default:
		{
			UpdateDirtyFlag(DIRTY_FLAG_CUSTOM_CASH);
		}
		break;
	}
}

ResultType LC_ServerPlayer::GetYiJiTuXiRankInfo(int minIndex, int maxIndex, MG_RLT_YiJiTuXiRankInfo& msg)
{
	ResultType res = RE_FAIL;
	if(minIndex > maxIndex)
	{
		return res;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetYiJiTuXiRankInfo(minIndex, maxIndex, msg);
	}

	mem::vector<uint64_t> allPlayers;
	UT_ServerHelper::RedisRank_ReadSimpleRange(UT_REDIS_KEY_MONEYPOINT_YIJITUXI, allPlayers);

	unique_id_type mySelfID = GetInstance();
	if(allPlayers.size() <= 0)
	{
		msg.m_nTotalCount = 0;
		msg.m_nMyselfInfo.m_nRankIndex = SPECIES_RANK_NONE;
		msg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();		
		msg.m_nMyselfInfo.m_nValue = 0;
		return RE_SUCCESS;
	}

	msg.m_nTotalCount = allPlayers.size();

	bool tag = false;
	for(int i=0; i<allPlayers.size(); ++i)
	{
		if(allPlayers[i] == mySelfID)
		{
			mem::vector<uint64_t> key;
			key.push_back(mySelfID);

			std::string data;
			UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_MONEYPOINT_YIJITUXI_PLAYER_INFO, key, data, false);

			AnswerInfo info;
			std::string errorMsg;
			if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
			{
				break;
			}

			tag = true;
			msg.m_nMyselfInfo.m_nRankIndex = i;
			msg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();
			msg.m_nMyselfInfo.m_nValue = info.accountPoint;

			break;
		}
	}

	if(!tag)
	{
		msg.m_nMyselfInfo.m_nRankIndex = SPECIES_RANK_NONE;
		msg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();
		msg.m_nMyselfInfo.m_nValue = 0;
	}

	maxIndex = maxIndex > allPlayers.size()-1 ? allPlayers.size()-1 : maxIndex;
	for(int i=minIndex; i<=maxIndex; ++i)
	{
		mem::vector<uint64_t> key;
		key.push_back(allPlayers[i]);

		std::string data;
		UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_MONEYPOINT_YIJITUXI_PLAYER_INFO, key, data, false);

		AnswerInfo info;
		std::string errorMsg;
		if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
		{
			continue;
		}

		PS_PlayerInfo playerInfo;
		playerInfo.m_nRankIndex = i;
		playerInfo.m_nCharName = info.charName;
		playerInfo.m_nValue = info.accountPoint;
		msg.m_nPlayerInfo.push_back(playerInfo);
	}
	return RE_SUCCESS;
}

void LC_ServerPlayer::UpdatePointToRedis(CashType cashType, MoneyType cashValue)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdatePointToRedis(cashType, cashValue);
	}

	//更新redis中的积分
	const char* pkSpace1 = NULL;
	const char* pkSpace2 = NULL;
	switch(cashType)
	{
	case CT_CASH_TYPE_29:
		{
			pkSpace1 = UT_REDIS_KEY_MONEYPOINT_YIJITUXI;
			pkSpace2 = UT_REDIS_KEY_MONEYPOINT_YIJITUXI_PLAYER_INFO;
		}
		break;
	default:
		return;
	}


	uint32_t currentTime  = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	uint32_t inputTime = LC_Helper::TimeStampReverse(currentTime);
	uint64_t value = LC_Helper::EncodeScore(cashValue, inputTime);
	UT_ServerHelper::RedisRank_WriteElement(pkSpace1, GetInstance(), value);

	AnswerInfo info;
	info.charName = GetOwnerCharName().c_str();
	info.accountPoint = cashValue;
	std::stringstream ss;
	boost::ajson::save_to_buff(info, ss);
	std::string data = ss.str().c_str();

	mem::vector<uint64_t> key;
	key.push_back(GetInstance());

	UT_ServerHelper::RedisSetData_String(pkSpace2, key, data, false, true);
}

void LC_ServerPlayer::SetSendGuildPresentInfoFlag(bool flag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetSendGuildPresentInfoFlag(flag);
	}

	if(m_bSendGuildPresentInfoFlag == flag)
	{
		return;
	}

	m_bSendGuildPresentInfoFlag = flag;
}

bool LC_ServerPlayer::GetSendGuildPresentInfoFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return true;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetSendGuildPresentInfoFlag();
	}

	return m_bSendGuildPresentInfoFlag;
}

void LC_ServerPlayer::SetGuildPresentFlag(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetGuildPresentFlag(tag);
	}

	bool flag = GetGuildPresentFlag();
	if(flag == tag)
	{
		return;
	}

	m_nShowGuildPresentName = tag;

	SyncGuildPresentFlag();
}

bool LC_ServerPlayer::GetGuildPresentFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return true;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetGuildPresentFlag();
	}

	return m_nShowGuildPresentName;
}

void LC_ServerPlayer::SyncGuildPresentFlag()
{
	MG_SyncGuildPresentFlag msg;
	msg.m_nShowGuildPresentName = GetGuildPresentFlag();
	SendMsgToClient(MGPT_SYNCGUILDPRESENTFLAG, &msg);
}

ResultType LC_ServerPlayer::GetGuildPresentReward(const std::set<uint16_t>& idSet, std::map<uint16_t,string>& rewardInfo)
{
	if(idSet.size()<1 || idSet.size() > GetGlobalSetting.ClientMaxPresentNum)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetGuildPresentReward idSet_size:%d, id:%d", idSet.size(), GetID());
		return RE_FAIL;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetGuildPresentReward r1, id:%d", GetID());
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetGuildPresentReward(idSet, rewardInfo);
	}

	rewardInfo.clear();
	const unique_id_impl& instance = GetInstance();

	uint64_t guildID = GetGuildID();
	if(INVALID_GUILD_ID == guildID)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetGuildPresentReward, c_cid:%d, c_citizenship:%d, c_uid:%d, guild=0 r3",	instance.detail(), instance.catagory(), GetUserID());
		return RE_GUILDPRESENT_ERROR_1;
	}

	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	LC_ServerGuildInfo* pkGuild = pkGuildManager->GetGuildInfoByID(guildID);
	if(NULL == pkGuild)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetGuildPresentReward, c_cid:%d, c_citizenship:%d, c_uid:%d, guild=0 r4", instance.detail(), instance.catagory(), GetUserID());
		return RE_GUILDPRESENT_ERROR_3;
	}

	std::set<uint16_t> rewardIDSet;

	ResultType res = RE_SUCCESS;
	mem::map<int32_t, int32_t> itemReward;
	vector<int> nParams;
	nParams.clear();
	for(std::set<uint16_t>::const_iterator it=idSet.begin(); it!=idSet.end(); ++it)
	{
		uint16_t id = *it; 
		Utility::UT_SIMDataList item;
		int32_t nItemID = 0;
		res = pkGuild->CheckGuildPresentRewardVaild(id, GetInstance(), nItemID);
		if(RE_SUCCESS != res)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckGuildPresentRewardVaild error:%d! presentID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, itemID:%d", 
				res, id, instance.detail(), instance.catagory(), GetUserID(), nItemID);
			res = rewardIDSet.empty() ? res : RE_GUILDPRESENT_ERROR_14;
			break;
		}

		res = UT_ServerHelper::GetDisassembleItem(this, nItemID, item, itemReward);
		if(RE_SUCCESS != res)
		{
			res = rewardIDSet.empty() ? res : RE_GUILDPRESENT_ERROR_14;
			GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_ERROR, "GetGuildPresentReward c_cid:%d, c_citizenship:%d, c_uid:%d r5", instance.detail(), instance.catagory(), GetUserID());
			break;
		}

		int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, GUILD_OPERATE, OPERATE_LOGTYPE6);
		StringType mailTitle;
		StringType mailDesc; 
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, item, this, SYS_FUNC_TP_GUILDPRESENT_REWARD, guildID, mailTitle, mailDesc, false,false,false,nLogCode,nParams);
		if(RE_SUCCESS == res)
		{
			StringType str;
			FormatDataIFs2String(item, str);
			rewardInfo[id] = TPSTR2STDSTR(str);	

			rewardIDSet.insert(id);
			pkGuild->ModifyGuildPresentRewardInvaild(id, GetInstance());
		}
		else if(RE_ITEM_PACKAGE_FULL == res)
		{
			res = RE_GUILDPRESENT_ERROR_14;
			break;
		}
	}

	if(!rewardIDSet.empty())
	{
		MG_GG_REQ_GetGuildPresentReward msg;
		msg.m_nGuildID = guildID;
		msg.m_nIDSet = rewardIDSet;
		msg.m_nCharID = GetInstance();
		SendMsgToSociety(MGPT_GG_REQ_GETGUILDPRESENTREWARD, &msg);

		NoticeAddItemGameEvent(PACK_TYPE_BASIC, itemReward, SYS_FUNC_TP_GUILDPRESENT_REWARD);
		SyncBackPackToClient(PACK_TYPE_BASIC);
	}

	return res;
}

ResultType LC_ServerPlayer::GetGuildCrystalReward(std::vector<uint32_t>& ids)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetGuildCrystalReward(ids);
	}

	if(0 == ids.size())
	{
		return RE_GUILDPRESENT_ERROR_13;
	}

	uint64_t guildID = GetGuildID();
	if(INVALID_GUILD_ID == guildID)
	{
		return RE_GUILDPRESENT_ERROR_8;
	}

	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	if(NULL == pkGuildManager)
	{
		return RE_GUILDPRESENT_ERROR_9;
	}

	LC_ServerGuildInfo* pkGuild = pkGuildManager->GetGuildInfoByID(guildID);
	if(NULL == pkGuild)
	{
		return RE_GUILDPRESENT_ERROR_10;
	}

	StringType reward;
	ResultType res = pkGuild->CheckGuildCrystalRewardVaild(ids, GetInstance(), reward);
	vector<int> nParams;
	nParams.clear();
	//for(int i = 0; i < ids.size(); i++)
	//{
	//	nParams.push_back(ids[i]);
	//}
	if(RE_SUCCESS == res)
	{
		UT_SIMDataList kItems;
		ParseFmtString2DataIFs(reward, kItems);

		StringType mailTitle;
		StringType mailDesc;
		int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, GUILD_OPERATE, OPERATE_LOGTYPE5);
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_GUILDCRYSTAL_REWARD, ids[0], mailTitle, mailDesc, false, false,false, nLogCode, nParams);
		if(RE_SUCCESS == res)
		{
			MG_GG_REQ_GetGuildCrystalReward msg;
			msg.m_nGuildID = guildID;
			msg.m_nID = ids;
			msg.m_nCharID = GetInstance();
			SendMsgToSociety(MGPT_GG_REQ_GETGUILDCRYSTALREWARD, &msg);
		}
	}

	return res;
}

void LC_ServerPlayer::AddGuildPresentExp(int32_t expType, int num)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddGuildPresentExp(expType, num);
	}

	if(num <= 0)
	{
		return;
	}

	uint64_t guildID = GetGuildID();
	if(INVALID_GUILD_ID == guildID)
	{
		return;
	}

	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	if(NULL == pkGuildManager)
	{
		return;
	}

	LC_ServerGuildInfo* pkGuild = pkGuildManager->GetGuildInfoByID(guildID);
	if(NULL == pkGuild)
	{
		return;
	}

	MG_GG_REQ_AddGuildCrystalExp msg;
	msg.m_nEntryNodeID = GetGameServerEntryID();
	msg.m_nGuildID = guildID;
	msg.m_nExpType  = expType;
	msg.m_nNum = num;
	SendMsgToSociety(MGPT_GG_REQ_ADDGUILDCRYSTALEXP, &msg);
}

ResultType LC_ServerPlayer::GetTreasurePos(int& nMapID, int& x, int& y, int& z)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetTreasurePos(nMapID, x, y, z);
	}

	//是否有已随机的坐标
	if(0!=m_nTreasurePos.x && 0!=m_nTreasurePos.y && 0!=m_nTreasurePos.z && 0!=m_nTreasureMapID)
	{
		x = m_nTreasurePos.x;
		y = m_nTreasurePos.y;
		z = m_nTreasurePos.z;
		nMapID = m_nTreasureMapID;
		return RE_SUCCESS;
	}

	bool tag = false;
	//道具是否足够
	for(int i=0; i<GetGlobalSetting.vecTreasureItem.size(); ++i)
	{
		ResultType res = TryDeleteItem(GetGlobalSetting.vecTreasureItem[i], 1);
		if(RE_SUCCESS == res)
		{
			tag = true;
			break;
		}
	}

	if(false == tag)
	{
		return RE_TREASURE_ERROR_1;
	}

	//随机坐标
	mem::map<int, mem::vector<UT_Vec3Int> > MapVec;
	UT_ServerHelper::GetTreasureMapVec(GetControllerLevel(), MapVec);

	if(true == MapVec.empty())
	{
		return RE_TREASURE_ERROR_2;
	}

	mem::vector<int> vaildMap;
	vaildMap.reserve(MapVec.size());

	for(mem::map<int, mem::vector<UT_Vec3Int> >::iterator it=MapVec.begin(); it!=MapVec.end(); ++it)
	{
		if(RE_SUCCESS == CheckCanEnter(it->first))
		{
			vaildMap.push_back(it->first);
		}
	}

	if(true == vaildMap.empty())
	{
		return RE_TREASURE_ERROR_3;
	}

	std::random_shuffle(vaildMap.begin(), vaildMap.end());
	int mapID = vaildMap[0];

	mem::map<int, mem::vector<UT_Vec3Int> >::iterator findIt = MapVec.find(mapID);
	if(findIt == MapVec.end())
	{
		return RE_TREASURE_ERROR_4;
	}

	if(true == findIt->second.empty())
	{
		return RE_TREASURE_ERROR_5;
	}

	std::random_shuffle(findIt->second.begin(), findIt->second.end());

	UT_Vec3Int pos = findIt->second[0];
	m_nTreasureMapID = mapID;
	m_nTreasurePos.x = pos.x;
	m_nTreasurePos.y = pos.y;
	m_nTreasurePos.z = pos.z;

	nMapID = mapID;
	x = pos.x;
	y = pos.y;
	z = pos.z;
	return RE_SUCCESS;
}

void LC_ServerPlayer::SyncTreasurePos()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncTreasurePos();
	}

	MG_RLT_GetTreasurePos rltMsg;
	rltMsg.m_nResult = RE_SUCCESS;
	rltMsg.m_nMapID = m_nTreasureMapID;
	rltMsg.m_nX = m_nTreasurePos.x;
	rltMsg.m_nY = m_nTreasurePos.y;
	rltMsg.m_nZ = m_nTreasurePos.z;
	SendMsgToClient(MGPT_RLT_GETTREASUREPOS, &rltMsg);
}

int LC_ServerPlayer::RandomTreasureEvent(int itemID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RandomTreasureEvent(itemID);
	}

	const unique_id_impl& instance = GetInstance();
	//检测道具是否够用
	if(RE_SUCCESS != TryDeleteItem(itemID, 1))
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "RandomTreasureEvent error1! c_cid:%d, c_citizenship:%d, c_uid:%d, itemID:%d",
			 instance.detail(), instance.catagory(), GetUserID(), itemID);
		return 0;
	}

	mem::map<int, int> eventID2Weight;
	int32_t totalWeight = 0;
	CF_TreasureEvent::DataEntryMapExternIterator kIt = CF_TreasureEvent::GetSingletonPtr()->GetIterator();
	for(; kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_TreasureEvent::DataEntry* pkData = kIt.PeekNextValuePtr();
		if(pkData->_itemID == itemID && (0==pkData->_iScheduleID || UT_ServerHelper::CheckActivityVaild(pkData->_iScheduleID)))
		{
			ResultType res = RE_SUCCESS;
			if(pkData->_achievementID != 0)
			{
				res = CheckAchievementCanFinish(pkData->_achievementID);
			}
			
			if(RE_SUCCESS==res || RE_ACHIEVEMENT_REWARD_HAS_RECEIVED==res)
			{
				totalWeight += pkData->_weight;
				eventID2Weight.insert(std::make_pair(pkData->_id, pkData->_weight));
			}
		}
	}

	int32_t random = UT_MathBase::RandInRangeInt(1, totalWeight);
	int num = 0;
	int eventIndex = 0;
	for(mem::map<int, int>::iterator it=eventID2Weight.begin(); it!=eventID2Weight.end(); ++it)
	{
		num += it->second;
		if(num >= random)
		{
			eventIndex = it->first;
			break;
		}
	}

	if(0 == eventIndex)
	{
		UT_ServerHelper::NotifyServerErrorCode(this, RE_TREASURE_ERROR_6);
	}

	return eventIndex;
}

int LC_ServerPlayer::GetTreasureEventType(int eventIndex)
{
	CF_TreasureEvent::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TreasureEvent>(eventIndex);
	if(NULL == pkData)
	{
		return 0;
	}
	return pkData->_iType;
}

int LC_ServerPlayer::CastTreasureEvent_AddItem(int eventIndex)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CastTreasureEvent_AddItem(eventIndex);
	}

	const unique_id_impl& instance = GetInstance();
	CF_TreasureEvent::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TreasureEvent>(eventIndex);
	if(NULL == pkData)
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_AddItem error1! c_cid:%d, c_citizenship:%d, c_uid:%d, eventIndex:%d",
			instance.detail(), instance.catagory(), GetUserID(), eventIndex);
		return 0;
	}

	//检测道具是否够用
	if(RE_SUCCESS != TryDeleteItem(pkData->_itemID, 1))
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_AddItem error2! c_cid:%d, c_citizenship:%d, c_uid:%d, itemID:%d",
			instance.detail(), instance.catagory(), GetUserID(), pkData->_itemID);
		return 0;
	}

	int playerLevel = GetControllerLevel();

	mem::vector<int64_t> levelRange;
	LC_Helper::SpliteString2VecInt(TPSTR2STDSTR(pkData->_playerLevel), levelRange, ";");

	int index = 0;
	for(int i=0; i<levelRange.size(); ++i)
	{
		if(levelRange[i] >= playerLevel)
		{
			index = i;
			break;
		}
	}

	mem::vector<StringType> ItemInfo;
	char str2 = '|';
	LC_Helper::SpliteString2MultiString(pkData->_iParam1, ItemInfo, str2);

	//配表不对
	if(index >= ItemInfo.size())
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_AddItem error3! c_cid:%d, c_citizenship:%d, c_uid:%d, eventIndex:%d, index:%d, itemSize:%d",
			instance.detail(), instance.catagory(), GetUserID(), eventIndex, index, ItemInfo.size());
		return 0;
	}

	MG_SyncReward msg;
	msg.m_nType = RewardType_Treasure;
	msg.m_nReward = TPSTR2STDSTR(ItemInfo[index]);

	UT_SIMDataList kItems;
	ParseFmtString2DataIFs(ItemInfo[index], kItems);

	StringType mailTitle;
	StringType mailDesc;
	int nLogCode  = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WABAO_OPERATE, OPERATE_LOGTYPE1);
	msg.m_nResult = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, pkOwnerPlayer, SYS_FUNC_TP_TREASUREREWARD, eventIndex, mailTitle, mailDesc, false, true, false, nLogCode);
	if(RE_SUCCESS == msg.m_nResult)
	{
		//删除道具
		int nLogCode  = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WABAO_OPERATE, OPERATE_LOGTYPE1);
		DeleteItem(pkData->_itemID, 1, nLogCode);

		LC_ItemFactoryBase* pkItemFactory = LC_ItemFactoryBase::GetSingletonPtr();
		if(NULL != pkItemFactory)
		{
			mem::set<int32_t> items;
			for(UT_SIMDataList::iterator it=kItems.begin(); it!=kItems.end(); ++it)
			{
				int itemID = it->IID();
				LC_ItemBase* pkItem = pkItemFactory->RequestItem(itemID);
				if(NULL!=pkItem && pkItem->GetGrade()>=GetGlobalSetting.TreasureItemNoticeGrade)
				{
					items.insert(itemID);
				}
			}

			if(!items.empty())
			{
				UT_ServerHelper::_GameNoticeFmort noticeFmort;
				noticeFmort.SetChannelType(PROMPT_CHANNEL_SYSTEM_TIP);
				noticeFmort.SetMsgID(36);
				noticeFmort.AddString(GetOwnerCharName());
				noticeFmort.AddItemNames(items);
				UT_ServerHelper::BrocastNoticeMsg(noticeFmort);
			}

			LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
			{
				LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
				if (NULL != pkGameEvent)
				{
					pkGameEvent->SetEventType(GLET_TREASURE_TIMES);
					pkGameEvent->SetEventParam(EP_TREASURE_TIMES_PLAYER_ID, GetID());
					pkGameEvent->SetEventParam(EP_TREASURE_TIMES_MAPID, GetMapResID());
					pkGameEventManager->InsertGameEvent(pkGameEvent);
				}
			}

			AchievementEvent kEvent;
			kEvent.SetNum(1);
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_TREASURE_COUNT, kEvent);
		}
	}
	else if(RE_ITEM_PACKAGE_FULL == msg.m_nResult )
	{
		msg.m_nResult = RE_TREASURE_ERROR_7;
	}
	else
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_AddItem error3! c_cid:%d, c_citizenship:%d, c_uid:%d, res:%d, index:%d",
			instance.detail(), instance.catagory(), GetUserID(), msg.m_nResult, index);
	}

	SendMsgToClient(MGPT_SYNCREWARD, &msg);
	return msg.m_nResult==RE_SUCCESS ? 1 : 0;
}

int LC_ServerPlayer::CastTreasureEvent_SwapnNPC(int eventIndex)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CastTreasureEvent_SwapnNPC(eventIndex);
	}

	const unique_id_impl& instance = GetInstance();
	CF_TreasureEvent::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TreasureEvent>(eventIndex);
	if(NULL == pkData)
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_SwapnNPC error1! c_cid:%d, c_citizenship:%d, c_uid:%d, eventIndex:%d",
			instance.detail(), instance.catagory(), GetUserID(), eventIndex);
		return 0;
	}

	//检测道具是否够用
	if(RE_SUCCESS != TryDeleteItem(pkData->_itemID, 1))
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_SwapnNPC error2! c_cid:%d, c_citizenship:%d, c_uid:%d, itemID:%d",
			instance.detail(), instance.catagory(), GetUserID(), pkData->_itemID);
		return 0;
	}

	int playerLevel = GetControllerLevel();
	int npcID = 0;
	for(Utility::UT_SIMDataList::iterator it=pkData->_iParam2.begin(); it!=pkData->_iParam2.end(); ++it)
	{
		if(it->IID() >= playerLevel)
		{
			npcID = it->ParamA();
			break;
		}
	}

	bool tag = UT_ServerHelper::SpawnNPC(this, npcID);
	if(false == tag)
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_SwapnNPC error3! c_cid:%d, c_citizenship:%d, c_uid:%d, npcID:%d",
			instance.detail(), instance.catagory(), GetUserID(), npcID);
		return 0;
	}
	
	//删除道具
	int nLogCode  = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WABAO_OPERATE, OPERATE_LOGTYPE1);
	DeleteItem(pkData->_itemID, 1, nLogCode);

	UT_ServerHelper::_GameNoticeFmort noticeFmort;
	noticeFmort.SetMsgID(37);
	noticeFmort.AddString(GetOwnerCharName());
	noticeFmort.AddCharType(npcID);
	UT_ServerHelper::BrocastNoticeMsg(noticeFmort);

	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_TREASURE_TIMES);
			pkGameEvent->SetEventParam(EP_TREASURE_TIMES_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_TREASURE_TIMES_MAPID, GetMapResID());
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	AchievementEvent kEvent;
	kEvent.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_TREASURE_COUNT, kEvent);

	return 1;
}

int LC_ServerPlayer::CastTreasureEvent_TransferMap(int eventIndex)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CastTreasureEvent_TransferMap(eventIndex);
	}

	const unique_id_impl& instance = GetInstance();
	CF_TreasureEvent::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TreasureEvent>(eventIndex);
	if(NULL == pkData)
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_TransferMap error1! c_cid:%d, c_citizenship:%d, c_uid:%d, eventIndex:%d",
			instance.detail(), instance.catagory(), GetUserID(), eventIndex);
		return 0;
	}

	//检测道具是否够用
	if(RE_SUCCESS != TryDeleteItem(pkData->_itemID, 1))
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_TransferMap error2! c_cid:%d, c_citizenship:%d, c_uid:%d, itemID:%d",
			instance.detail(), instance.catagory(), GetUserID(), pkData->_itemID);
		return 0;
	}

	int playerLevel = GetControllerLevel();
	int mapID = 0;
	for(Utility::UT_SIMDataList::iterator it=pkData->_iParam3.begin(); it!=pkData->_iParam3.end(); ++it)
	{
		if(it->IID() >= playerLevel)
		{
			mapID = it->ParamA();
			break;
		}
	}

	ResultType res = TransferMap(TT_TRANSPORT_RAID_MAP, mapID, 0, GetGameServerID(), false, 0);
	if(RE_SUCCESS == res)
	{
		//删除道具
		int nLogCode  = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, WABAO_OPERATE, OPERATE_LOGTYPE1);
		DeleteItem(pkData->_itemID, 1, nLogCode);

		UT_ServerHelper::_GameNoticeFmort noticeFmort;
		noticeFmort.SetMsgID(45);
		noticeFmort.AddString(GetOwnerCharName());
		UT_ServerHelper::BrocastNoticeMsg(noticeFmort);

		LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
		{
			LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
			if (NULL != pkGameEvent)
			{
				pkGameEvent->SetEventType(GLET_TREASURE_TIMES);
				pkGameEvent->SetEventParam(EP_TREASURE_TIMES_PLAYER_ID, GetID());
				pkGameEvent->SetEventParam(EP_TREASURE_TIMES_MAPID, GetMapResID());
				pkGameEventManager->InsertGameEvent(pkGameEvent);
			}
		}

		AchievementEvent kEvent;
		kEvent.SetNum(1);
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_TREASURE_COUNT, kEvent);
	}
	else
	{
		GfxWriteLog( LOG_ERROR_FILELINE , LOG_SWITCH_ERROR, "CastTreasureEvent_TransferMap error2! c_cid:%d, c_citizenship:%d, c_uid:%d, mapID:%d, res:%d",
			instance.detail(), instance.catagory(), GetUserID(), mapID, res);
	}

	return RE_SUCCESS==res ? 1 : 0;
}

void LC_ServerPlayer::ResetTreasurePos()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetTreasurePos();
	}

	m_nTreasureMapID = 0;
	m_nTreasurePos.clear();
	SyncTreasurePos();
}

int32_t LC_ServerPlayer::UpdateGuildMapBossDamage(mem::vector<uint64_t>& params, uint64_t deltaData, uint64_t& totalDamage)
{
	uint64_t nScore = 0;
	int32_t index = -1;

	UT_ServerHelper::RedisRank_ReadDamage(UT_REDIS_KEY_GUILDMAPBOSS_DAMAGE_RANK, params, GetInstance(), nScore, index);
	totalDamage = nScore+deltaData;

	if(deltaData == 0)
	{
		totalDamage = nScore;
		return index;
	}

	UT_ServerHelper::RedisRank_WriteDamage(UT_REDIS_KEY_GUILDMAPBOSS_DAMAGE_RANK, params, GetInstance(), totalDamage);
	UT_ServerHelper::RedisRank_ReadDamage(UT_REDIS_KEY_GUILDMAPBOSS_DAMAGE_RANK, params, GetInstance(), nScore, index);

	GuildMapDamagePlayerInfo info;
	info.charID = GetInstance();
	info.playerName = GetOwnerCharName().c_str();
	info.playerLevel = GetCommanderLevel();
	info.pictureID = GetProfilePictureID();
	info.titleFrameID = GetCurrentCommanderTitleFrameID();
	info.damageData = nScore;

	std::stringstream ss;
	boost::ajson::save_to_buff(info, ss);
	std::string data = ss.str().c_str();

	mem::vector<uint64_t> key;
	key.push_back(GetInstance());
	UT_ServerHelper::RedisSetData_DamageString(UT_REDIS_KEY_GUILDMAPBOSS_PLAYER_INFO, params, key, data, false, true);

	return index;
}

ResultType LC_ServerPlayer::GetGuildMapBossRank(MG_RLT_GetGuildMapBossRank& rltMsg)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return RE_FAIL;
	if ( !IsMainController() )
		return pOwner->GetGuildMapBossRank(rltMsg);

	mem::vector<uint64_t> params;
	params.reserve(2);
	params.push_back(GetGuildID());
	params.push_back(rltMsg.m_nMapID);

	mem::vector<uint64_t> allPlayers;
	UT_ServerHelper::RedisRank_ReadSimpleDamageRange(UT_REDIS_KEY_GUILDMAPBOSS_DAMAGE_RANK, params, allPlayers);

	unique_id_type mySelfID = GetInstance();
	if(allPlayers.size() <= 0)
	{
		rltMsg.m_nTotalCount = 0;
		rltMsg.m_nMyselfInfo.m_nCharID = GetInstance();
		rltMsg.m_nMyselfInfo.m_nRankIndex = SPECIES_RANK_NONE;
		rltMsg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();		
		rltMsg.m_nMyselfInfo.m_nDamageData = 0;
		rltMsg.m_nMyselfInfo.m_nLevel = GetControllerLevel();
		rltMsg.m_nMyselfInfo.m_nPictureID = GetProfilePictureID();
		rltMsg.m_nMyselfInfo.m_nTitleFrameID = GetCurrentCommanderTitleFrameID();
		return RE_SUCCESS;
	}

	rltMsg.m_nTotalCount = allPlayers.size();

	bool tag = false;
	for(int i=0; i<allPlayers.size(); ++i)
	{
		if(allPlayers[i] == mySelfID)
		{
			mem::vector<uint64_t> key;
			key.push_back(mySelfID);

			std::string data;
			UT_ServerHelper::RedisGetData_DamageString(UT_REDIS_KEY_GUILDMAPBOSS_PLAYER_INFO, params, key, data);

			GuildMapDamagePlayerInfo info;
			std::string errorMsg;
			if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
			{
				break;
			}

			tag = true;

			rltMsg.m_nMyselfInfo.m_nCharID = mySelfID;
			rltMsg.m_nMyselfInfo.m_nRankIndex = i;
			rltMsg.m_nMyselfInfo.m_nCharName = info.playerName;
			rltMsg.m_nMyselfInfo.m_nDamageData = info.damageData;
			rltMsg.m_nMyselfInfo.m_nLevel = info.playerLevel;
			rltMsg.m_nMyselfInfo.m_nPictureID = info.pictureID;
			rltMsg.m_nMyselfInfo.m_nTitleFrameID = info.titleFrameID;
			break;
		}
	}

	if(!tag)
	{
		rltMsg.m_nMyselfInfo.m_nCharID = mySelfID;
		rltMsg.m_nMyselfInfo.m_nRankIndex = SPECIES_RANK_NONE;
		rltMsg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();		
		rltMsg.m_nMyselfInfo.m_nDamageData = 0;
		rltMsg.m_nMyselfInfo.m_nLevel = GetControllerLevel();
		rltMsg.m_nMyselfInfo.m_nPictureID = GetProfilePictureID();
		rltMsg.m_nMyselfInfo.m_nTitleFrameID = GetCurrentCommanderTitleFrameID();
	}

	rltMsg.m_nMaxIndex = rltMsg.m_nMaxIndex > allPlayers.size()-1 ? allPlayers.size()-1 : rltMsg.m_nMaxIndex;
	for(int i=rltMsg.m_nMinIndex; i<=rltMsg.m_nMaxIndex; ++i)
	{
		uint64_t charID =allPlayers[i];

		mem::vector<uint64_t> key;
		key.push_back(charID);

		std::string data;
		UT_ServerHelper::RedisGetData_DamageString(UT_REDIS_KEY_GUILDMAPBOSS_PLAYER_INFO, params, key, data);

		GuildMapDamagePlayerInfo info;
		std::string errorMsg;
		if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
		{
			continue;
		}

		PS_GuildMapBossPlayerInfo dataInfo;
		dataInfo.m_nCharID = charID;
		dataInfo.m_nRankIndex = i;
		dataInfo.m_nCharName = info.playerName;
		dataInfo.m_nDamageData = info.damageData;
		dataInfo.m_nLevel = info.playerLevel;
		dataInfo.m_nPictureID = info.pictureID;
		dataInfo.m_nTitleFrameID = info.titleFrameID;
		rltMsg.m_nPlayerInfo.push_back(dataInfo);
	}
	return RE_SUCCESS;
}

void LC_ServerPlayer::SyncGameRestartNotice()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncGameRestartNotice();

	ResultType res = UT_ServerHelper::CheckGetRestartReward(this);
	if(res == RE_GAMERESTART_ERROR_2 || res==RE_GAMERESTART_ERROR_3)
	{
		MG_SyncGameRestartNotice msg;
		msg.m_nNoticeID = 1;
		msg.m_nTag = (res==RE_GAMERESTART_ERROR_2) ? true : false;
		SendMsgToClient(MGPT_SYNCGAMERESTARTNOTICE, &msg);
	}
}

ResultType LC_ServerPlayer::GetGameRestartReward(int id)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return RE_FAIL;
	if ( !IsMainController() )
		return pOwner->GetGameRestartReward(id);


	CF_GameRestartNotice::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_GameRestartNotice>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	ResultType res = UT_ServerHelper::CheckGetRestartReward(this);
	if(res != RE_GAMERESTART_ERROR_2)
	{
		return res;
	}
	//公告奖励--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(id);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, NOTICE_OPERATE, OPERATE_LOGTYPE1);
	StringType mailTitle;
	StringType mailDesc;
	res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_reward, this, SYS_FUNC_TP_GETGAMERESTARTREWARD, id, mailTitle, mailDesc, false,false,false,nLogCode, nParams);
	if(RE_SUCCESS == res)
	{
		UT_ServerHelper::UpdatePlayerRestartRewardState(GetInstance(), true);
	}

	return res;
}

bool LC_ServerPlayer::AddCredit(int64_t iCredit, CashType eCashType, int32_t reason)
{
	if (iCredit == 0)
	{
		return false;
	}

	if(IS_RECHARGE_RELATED(reason))
	{
		LC_VIPAsset& kVipAsset = GetVIPAsset();
		int32_t iPreLevel = kVipAsset.GetVIPLevel();
		int32_t iPostLevel = kVipAsset.SetCredit(kVipAsset.GetCredit() + iCredit);
		if (iPreLevel != iPostLevel)
		{
			GetOpenAbilityAsset().OnVIPLevelChanged();
			LC_ServerPlayer* player = GetOwnerPlayer();
			if(player)
			{
				oss_360_log_vip_privilege(iPostLevel-iPreLevel, player);
				MG_Notify_VIPLevel_Change msg;
				msg.m_nOldVIPLevel = iPreLevel;
				msg.m_nCurrentVIPLevel = iPostLevel;
				player->GetCommanderAttrMgr().RefreshVipAttributeMap(player, false);
				player->SendMsgToClient(MG_NOTIFY_VIPLEVEL_CHANGE, &msg);
			}
		}
		return true;
	}

	return false;
}

//----------------------------------------------------------------------------
bool LC_ServerPlayer::AddGuildMoney(MoneyType delta, int32_t iSrcType, uint64_t iSrcID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->AddGuildMoney(delta, iSrcType, iSrcID);
	}

	MoneyType iPreVal = m_GuildMoney;
	if (!LC_PlayerBase::AddGuildMoney(delta, iSrcType, iSrcID))
	{
		return false;
	}
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	pkGameEvent->SetEventType(GLET_ADD_GUILDMONEY);
	pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
	pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,	(int)delta);
	SendGameEvent(pkGameEvent);
	pkEventManager->FreeGameEvent(pkGameEvent);

	AchievementEvent kEvent;
	kEvent.SetNum(delta);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_GUILDMONEY, kEvent);
	oss_role_moneyflow(this, iPreVal, m_GuildMoney, -delta, CT_GUILD_MONEY, iSrcType, 0, iSrcID);
	return true;
}
//------------------------------------------------------------------------------
bool LC_ServerPlayer::DelGuildMoney(MoneyType delta, int32_t iSrcType, int32_t iSrcID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;
	if(!IsMainController())
	{
		return m_pOwnerPlayer->DelGuildMoney(delta, iSrcType, iSrcID);
	}

	MoneyType iPreVal = m_GuildMoney;
	if (!LC_PlayerBase::DelGuildMoney(delta, iSrcType, iSrcID))
	{
		return false;
	}
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	pkGameEvent->SetEventType(GLET_DEL_GUILDMONEY);
	pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
	pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,	(int)delta);
	SendGameEvent(pkGameEvent);
	pkEventManager->FreeGameEvent(pkGameEvent);
	oss_role_moneyflow(this, iPreVal, m_GuildMoney, delta, CT_GUILD_MONEY, iSrcType, 1, iSrcID);
	return true;
}
bool LC_ServerPlayer::CheckGuildMoney(MoneyType delta)
{
	MoneyType money = GetGuildMoney();
	return money >= delta;
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetTotalGuildMoney(MoneyType point)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetTotalGuildMoney(point);
	}

	LC_PlayerBase::SetTotalGuildMoney(point);
}

MoneyType LC_ServerPlayer::GetTotalGuildMoney()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetTotalGuildMoney();
	}

	return LC_PlayerBase::GetTotalGuildMoney();
}

void LC_ServerPlayer::SetGuildMoney(MoneyType point)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetGuildMoney(point);
	}

	LC_PlayerBase::SetGuildMoney(point);
}

MoneyType LC_ServerPlayer::GetGuildMoney()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetGuildMoney();
	}

	return LC_PlayerBase::GetGuildMoney();
}
void LC_ServerPlayer::AddGuildPresent(int32_t itemID, int8_t way)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddGuildPresent(itemID, way);
	}

	uint64_t guildID = GetGuildID();
	if(INVALID_GUILD_ID == guildID)
	{
		return;
	}

	MG_GG_AddGuildPresent msg;
	msg.m_nGuildID = guildID;
	msg.m_nItemID = itemID;
	msg.m_nPresentType = way;
	msg.m_nCharName = GetGuildPresentFlag() ? GetOwnerCharName().c_str() : "";
	msg.m_nVaildTime = GetGlobalSetting.GuildPresentVaildTime;

	SendMsgToSociety(MGPT_GG_ADDGUILDPRESENT, &msg);
}
//-----------------------------------------------------------------------------
bool LC_ServerPlayer::IsGuildAutoAdd()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->IsGuildAutoAdd();
	}

	return LC_PlayerBase::IsGuildAutoAdd();
}

void LC_ServerPlayer::SetGuildAutoAdd(bool autoadd)
{
	/*
	if(!IsMainController() && NULL!=m_pOwnerPlayer)
	{
	return m_pOwnerPlayer->SetGuildAutoAdd(autoadd);
	}
	*/

	return LC_PlayerBase::SetGuildAutoAdd(autoadd);
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::AddCouragePoint(int64_t delta, int32_t iSrcType, uint64_t iSrcID, int nLogCode, const vector<int> &Params)
{
	bool res = AddCash(delta, CT_COURAGE, iSrcType, iSrcID, 0, true, NULL, nLogCode, Params);
	if(res)
	{
		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		pkGameEvent->SetEventType(GLET_ADD_COURAGEPOINT);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
		pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,(int)delta);
		SendGameEvent(pkGameEvent);
		pkEventManager->FreeGameEvent(pkGameEvent);
	}
	//oss_role_moneyflow(this, iPreVal, m_CouragePoint, delta, CT_COURAGE, iSrcType, 0, iSrcID);
	return res;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::DelCouragePoint(int64_t delta, int32_t iSrcType, uint64_t iSrcID, int nLogCode, const vector<int> &Params)
{
	int64_t iPreVal = m_CouragePoint;
	if (!LC_PlayerBase::DelCouragePoint(delta, iSrcType, iSrcID))
	{
		return false;
	}
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	pkGameEvent->SetEventType(GLET_DEL_COURAGEPOINT);
	pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
	pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,	(int)delta);
	SendGameEvent(pkGameEvent);
	pkEventManager->FreeGameEvent(pkGameEvent);
	oss_role_moneyflow(this, iPreVal, m_CouragePoint, -delta, CT_COURAGE, iSrcType, 1, iSrcID);
	return true;
}

bool LC_ServerPlayer::CheckCouragePoint(int64_t delta)
{
	int64_t point = GetCouragePoint();
	return point>=delta;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::AddHonor(int64_t delta, int32_t iSrcType, uint64_t iSrcID)
{
	int64_t iPreVal = GetHonor();
	if (!LC_PlayerBase::AddHonor(delta, iSrcType, iSrcID))
	{
		return false;
	}
	oss_role_moneyflow(this, iPreVal, GetHonor(), delta, CT_HONOR, iSrcType, 0, iSrcID);
	return true;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::DelHonor(int64_t delta, int32_t iSrcType, uint64_t iSrcID)
{
	int64_t iPreVal = GetHonor();
	if (!LC_PlayerBase::DelHonor(delta, iSrcType, iSrcID))
	{
		return false;
	}
	oss_role_moneyflow(this, iPreVal, GetHonor(), -delta, CT_HONOR, iSrcType, 1, iSrcID);
	return true;
}

bool LC_ServerPlayer::CheckHonor(int64_t delta)
{
	int64_t honor = GetHonor();
	return honor>=delta;
}

void LC_ServerPlayer::RegisterCombatEventData( COMBAT_EVENT_TYPE eEventType, COMBAT_EVENT_KEY_TYPE nKey, COMBAT_EVENT_VALUE_TYPE nValue )
{
	m_CombatEventData.Register(eEventType, nKey, nValue);
}

void LC_ServerPlayer::UnregisterCombatEventData( COMBAT_EVENT_TYPE eEventType, COMBAT_EVENT_KEY_TYPE nKey )
{
	m_CombatEventData.Unregister(eEventType, nKey);
}

void LC_ServerPlayer::ModifyCombatEventData( COMBAT_EVENT_TYPE eEventType, COMBAT_EVENT_KEY_TYPE nKey, COMBAT_EVENT_VALUE_TYPE nDeltaValue )
{
	m_CombatEventData.Modify(eEventType, nKey, nDeltaValue);
}

bool LC_ServerPlayer::GetCombatEventData( COMBAT_EVENT_TYPE eEventType, COMBAT_EVENT_KEY_TYPE nKey, COMBAT_EVENT_VALUE_TYPE& nValue )
{
	return m_CombatEventData.Get(eEventType, nKey, nValue);
}

COMBAT_EVENT_VALUE_TYPE LC_ServerPlayer::GetCombatEventData( COMBAT_EVENT_TYPE eEventType, COMBAT_EVENT_KEY_TYPE nKey )
{
	return m_CombatEventData.Get(eEventType, nKey);
}

//----------------------------------------------------------------------------
bool LC_ServerPlayer::Respawn(attr_value_type lHP, int lMP)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!GetDead())
	{
		return false;
	}
	//玩家死亡复活后插入一个事件，副本中要对这个事件进行处理
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_PLAYER_RESPAWN);
		pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1, GetID());
		pkGameEvent->SetEventParam(EVENT_BASE_PARAM_2, GetMapLogicID());
		pkEventManager->InsertGameEvent(pkGameEvent);
	}
	SetSkillRespawnSourcePlayerID(0);
	SetSkillFlag(SK_SKILL_RESPAWN, false);
	bool bResult = LC_PlayerBase::Respawn(lHP, lMP);
	if (bResult)
	{
		m_pOwnerPlayer->OnBuddyRelive(m_iID);
	}

	ClearCombatStatusAsBuddy();
	return bResult;
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::AsyncUpdateToDBServer(void)
{
	SetDBSaveMaskFlag(LPDST_CHAR_BASE_INFO, true);
	m_DBUpdateTimer.ForceExpired();
}
void LC_ServerPlayer::UpdateToDBServer(bool isleave,ResultType nReason)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if( NULL == pkOwnerPlayer)
		return;
	if (pkOwnerPlayer->GetEnterServerMode() == ENTER_SERVER_MODE::eEnterServerMode_SwitchNode|| !IsInstance()|| false == m_bLoadDataFromDB || false == IsInGame()/*|| false ==  GetSaveFlag()*/)
		return;
	SaveCharPB(isleave,nReason);
	SetSaveFlag(false);
}
//----------------------------------------------------------
void LC_ServerPlayer::SetSession(NW_ServerSession* pkSession)
{
	m_pkSession = pkSession;
	if(pkSession)
		m_nSessionId = GameLogic::LC_Helper::generate_unique_id(0, GetGameServerID());
}
//----------------------------------------------------------
NW_ServerSession* LC_ServerPlayer::GetSession()
{
	return m_pkSession;
}

uint64_t LC_ServerPlayer::GetSessionId()
{
	return m_nSessionId;
}
//------------------------------------------------------------------------
void LC_ServerPlayer::Send(char* pMsg, uint16_t wSize)
{
	if (m_pkSession)
	{
		m_pkSession->Send(pMsg, wSize);
	}
}

void LC_ServerPlayer::SetUserName(const StringType& rkName)
{
	m_kUserName = rkName;
	m_kUserName_utf8 = CodeConvert::MbsToUtf8(m_kUserName);
}

const StringType& LC_ServerPlayer::GetUserName()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return gs_strNullStr;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetUserName();
	}
	return m_kUserName;
}

const StringType& LC_ServerPlayer::GetUserName_utf8()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return gs_strNullStr;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetUserName_utf8();
	}
	return m_kUserName_utf8;
}

void LC_ServerPlayer::SetCharName(const StringType& rkCharName)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetCharName(rkCharName);
	}

	LC_ActorBase::SetCharName(rkCharName);
	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
}

const StringType& 	LC_ServerPlayer::GetOwnerCharName()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return gs_strNullStr;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetOwnerCharName();
	}

	if(IsRobot())
	{
		return LC_ActorBase::GetCharName();
	}
	return LC_ActorBase::GetCharName();
}

const StringType& 	LC_ServerPlayer::GetOwnerCharName_utf8()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return gs_strNullStr;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetOwnerCharName_utf8();
	}
	return LC_ActorBase::GetCharName_utf8();
}

ResultType LC_ServerPlayer::HandleBonusItems(int32_t iPackType, const Utility::UT_SIMDataList& items, int32_t iReasonType, uint64_t iReasonDetail, const StringType& title, const StringType& Desc, bool toMail, bool bAutoUse, bool bLotteryLogic)
{
	return UT_ServerHelper::HandleBonusItems(iPackType, items, this, iReasonType, iReasonDetail, title, Desc, toMail, bAutoUse, bLotteryLogic);
}

//------------------------------------------------------------------------
bool LC_ServerPlayer::SendMsgToClient(int32_t iMsgType, MG_BODY* pkMsgBody, LC_ServerPlayer* pOwnerPlayer)
{
	bool res = false;
	if ( pOwnerPlayer == NULL )
		pOwnerPlayer = GetOwnerPlayer();
	if ( pOwnerPlayer == NULL )
	{
		return res;
	}
	NW_ServerSession* pSession = pOwnerPlayer->GetSession();
	user_id_type dwUserId = pOwnerPlayer->GetUserID();
	if (pSession)
	{
		res = SendMsgToClientByGateway(pSession->PeerID(), iMsgType, pkMsgBody, dwUserId, GetInstance());
	}
	else
	{
		res = SendMsgFightTranscribeRecord(0, iMsgType, pkMsgBody, dwUserId, GetInstance());
	}
	if (GetAsAControlee().IsValid())
	{
		res = RouteMsgToClientByGame(GetControlerPeer().ServerID(), GetControlerPeer().GatewayID(), iMsgType, pkMsgBody, GetControlerPeer().UserID(), GetControlerPeer().CharID());
	}

	if(!res)
	{
		GfxWriteFmtLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SendMsgToClient error!", iMsgType, pOwnerPlayer->GetID(), pOwnerPlayer->GetUserID(), pOwnerPlayer->GetInstance());
	}
	return res;
}
//---------------------------------------------------------------------------
bool LC_ServerPlayer::SendMsgToClient(int32_t iMsgType, const char* pMsg, uint16_t nSize)
{
	if (m_pkSession)
	{
		SendMsgToClientByGateway(m_pkSession->PeerID(), iMsgType, pMsg, nSize, GetUserID(), GetInstance());
	}
	
	if (GetAsAControlee().IsValid())
	{
		RouteMsgToClientByGame(GetControlerPeer().ServerID(), GetControlerPeer().GatewayID(), iMsgType, pMsg, nSize, GetControlerPeer().UserID(), GetControlerPeer().CharID());
	}
	return true;
}
//---------------------------------------------------------------------------
bool LC_ServerPlayer::SendNotifyStrToClient(const StringType& msg, PromptChannel msgchannel, PromptLevel msglevel)
{
	MG_NotifyMsg notifymsg;
	notifymsg.m_Type = msgchannel;
	notifymsg.m_MsgLevel = msglevel;
	TPSTR2STDSTR(msg, notifymsg.m_szSystemAnnounce);
	return SendMsgToClient(MGPT_NOTIFY_MSG, &notifymsg);
}
//------------------------------------------------------------------------
bool LC_ServerPlayer::BroadCastToArea(int32_t iMsgType, MG_BODY* pkMsgBody, LC_PlayerOperator* pkFilter)
{
	if (m_pkMap)
	{
		((LC_ServerMap*)m_pkMap)->BroadCastToArea(m_dwSectorIndex, iMsgType, pkMsgBody);
		return true;
	}
	return false;
}
//------------------------------------------------------------------------
bool LC_ServerPlayer::BroadCastTransferToAreaWithoutMe(int meID, int32_t iMsgType, Protocol::MG_BODY* pkMsgBody)
{
	if (m_pkMap)
	{
		LC_SimPlayerFilter kExludeSelf;
		kExludeSelf.SetActor(meID, true);
		((LC_ServerMap*)m_pkMap)->BroadCastToArea(m_dwSectorIndex, iMsgType, pkMsgBody, &kExludeSelf);
		((LC_ServerMap*)m_pkMap)->BroadCastToArea(m_dwOldSectorIndex, iMsgType, pkMsgBody, &kExludeSelf);
		return true;
	}
	return false;
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncGuildRewardState()
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncGuildRewardState();
	MG_SyncGuildRewardState syncMsg;
	syncMsg.m_bGuildRewardIsVaild = GetGuildRewardState();
	SendMsgToClient(MGPT_SYNC_GUILDREWARD_STATE, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncPetInfoToClient()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncPetInfoToClient();	
	m_PetInstanceMgr.SyncAllPetData();
}

void LC_ServerPlayer::SyncBotInfoToClient()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncBotInfoToClient();	
}

void LC_ServerPlayer::SyncNewVIPRewardToClient()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncNewVIPRewardToClient();	

	m_NewVIPReward.SyncToClient();
}

void LC_ServerPlayer::SyncControllerPropertyToClient()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncControllerPropertyToClient();
	}

	MG_SyncPlayerControllerProperty syncMsg;
	syncMsg.m_iEXP = m_lEXP;
	syncMsg.m_iLevel = (uint16_t)m_lLevel;
	syncMsg.m_nMainControllerId = m_iID;
	//GetUserID();
	syncMsg.m_nInstanceId = GetInstanceUniqueID();
	syncMsg.m_iTotalCombatScore = GetControllerCombatScore();
	syncMsg.m_iBornCharType = GetProfilePictureID();
	TPSTR2STDSTR(GetOwnerCharName(), syncMsg.m_cPlayerControllerName);
	syncMsg.m_iCommanderMP = LC_PlayerBase::GetOwnerMP();
	syncMsg.m_iCommanderMaxMP = LC_PlayerBase::GetOwnerMaxMP();
	syncMsg.m_iTaskHonorPoint = GetTaskHonorPoint();
	syncMsg.m_iMainTaskFinishCount = GetMainTaskFinishCount();
	syncMsg.m_nLotteryCount = GetLotteryTotalCount();
	syncMsg.m_nMaxRuneStarLevel = GetRuneTotalStarLevel();
	syncMsg.m_nMaxRuneLevel = GetRuneTotalLevel();
	syncMsg.m_nCommanderTitleID = GetCommanderTitle();
	syncMsg.m_nCommanderTitleFrameID = GetCurrentCommanderTitleFrameID();
	syncMsg.m_CharCreateTime = GetRegTime();
	syncMsg.m_GMLevel = GetGMLevel();

	SendMsgToClient(MGPT_SYNC_PLAYER_CONTROLLER_PROPERTY, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncPropertyToClient(bool bWithoutBuddy)
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}

	LC_ServerPlayer* pkCurrentPlayer = GetCurrentActivateBuddy();
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkCurrentPlayer || NULL==pkOwnerPlayer)
		return;

	MG_SyncPlayerProperty syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	syncMsg.m_lBuddyID = m_nBuddyTemplateId;
	syncMsg.m_lRevisionID = m_DFProperty.GetRevisionID();
	syncMsg.m_lRiderCharType = pkOwnerPlayer->GetRiderCharType();	
	syncMsg.m_iHP = GetHP();
	syncMsg.m_iMP = (uint32_t)GetMP();
	syncMsg.m_iEXP = m_lEXP;
	syncMsg.m_iLevel = (uint16_t)GetBuddyLevel();
	syncMsg.m_llSkillFlag = m_llSkillFlag;
	syncMsg.m_bIsShowFashion = m_bIsShowFashion;
	syncMsg.m_SkillLevelupPoint = m_SkillLevelupPoints;
	syncMsg.m_CurrentSkillLevelupPoint = (int32_t)m_CurrentSitRecoverSkillPoint;
	syncMsg.m_CurrentVipSkillLevelupPoint = (int32_t)m_CurrentSitRecoverVipSkillPoint;
	syncMsg.m_CurrentSitExp = (int32_t)m_CurrentSitRecoverExp;
	syncMsg.m_CurrentSitVipExp = (int32_t)m_CurrentSitRecoverVipExp;
	syncMsg.m_SitRecoverLevel = (uint8_t)m_SitRecoverLevel;
	syncMsg.m_Vigor = (uint16_t)m_Vigor;
	syncMsg.m_iCombatScore = GetCombatScore();

	syncMsg.m_FactionId = GetFactionID();
	syncMsg.m_PairSitRecoverID = GetPairSitRecoverID();
	syncMsg.m_iServerID = pkOwnerPlayer->m_iServerID;
	syncMsg.m_PlaceCanPk = GetPlaceCanPK();
	syncMsg.m_JumpDodgePoint = (uint8_t)m_JumpDodgePoint;

	for(platform_vip_info::const_iterator iter = m_platformvipinfo.begin(); iter != m_platformvipinfo.end(); iter ++)
	{
		const platform_node& rPfNode = iter->second;
		syncMsg.m_Platform[iter->first.c_str()] = rPfNode.format_vip_info();
	}
	SendMsgToClient(MGPT_SYNC_PLAYER_PROPERTY, &syncMsg);

	if (m_pAssignedBuddyInstance && bWithoutBuddy == false)
		m_pAssignedBuddyInstance->SyncBaseData();
	m_dataChangeFlag.GetBroadCastFlag().SetHPMP();
	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncSocietyToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncSocietyToClient();	

	MG_SyncPlayerSociety syncMsg;
	TPSTR2STDSTR(GetCharMood(), syncMsg.m_CharMood);
	syncMsg.m_bLoadFromSocietyFlag = GetbLoadFromSocietyFlag();
	syncMsg.m_uiGuildID = GetGuildID();
	syncMsg.m_GuildMoney = GetGuildMoney();
	TPSTR2STDSTR(GetGuildName(), syncMsg.m_strGuildName);
	syncMsg.m_ActiveServer = GetActiveServer();
	syncMsg.m_GuildGroup = GetGuildGroup();
	syncMsg.m_GuildAutoAdd = IsGuildAutoAdd();
	syncMsg.m_CouragePoint = (int32_t)GetCouragePoint();
	SendMsgToClient(MGPT_SYNC_PLAYER_SOCIETY, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncCashToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncCashToClient();	

	MG_SyncPlayerCash syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	syncMsg.m_llBindCash = GetBindCash().GetMoney();
	syncMsg.m_llUnBindCash = GetUnBindCash().GetMoney();
	SendMsgToClient(MGPT_SYNC_CASH, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncYuanBaoToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncYuanBaoToClient();	

	MG_SyncPlayerYuanBao syncMsg;
	syncMsg.m_lPlayerID = GetID();
	syncMsg.m_llBindYuanBao = GetBindYuanBao().GetMoney();
	syncMsg.m_llUnBindYuanBao = GetUnBindYuanBao().GetMoney();
	SendMsgToClient(MGPT_SYNC_YUANBAO, &syncMsg);
}
void LC_ServerPlayer::SyncRuneCreamToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncRuneCreamToClient();	

	MG_SyncPlayerRuneCream syncMsg;
	syncMsg.m_lRuneCream = GetCashNumByCashType(CT_RUNE_CREAM);
	SendMsgToClient(MGPT_SYNC_RUNE_CREAM, &syncMsg);
}

void LC_ServerPlayer::SyncStarSoulToClient()
{
	if (!IsInstance())
	{
		return;
	}


	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncStarSoulToClient();	

	MG_SyncPlayerStarSoul syncMsg;
	syncMsg.m_lStarSoul = GetStarSoul().GetMoney();
	SendMsgToClient(MGPT_SYNC_STAR_SOUL, &syncMsg);
}

void LC_ServerPlayer::SyncPentacleToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncPentacleToClient();	

	MG_SyncPlayerPentacle syncMsg;
	syncMsg.m_lPentacle = GetPentacle().GetMoney();
	SendMsgToClient(MGPT_SYNC_PENTACLE, &syncMsg);
}

void  LC_ServerPlayer::SyncCustomCashToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncCustomCashToClient();	

	MG_SyncCustomCash syncMsg;
	syncMsg.m_lPlayerID = GetID();
	for (int i = 0; i < CT_CASH_COUNT - CT_JUSTICE_PT; ++i)
	{
		syncMsg.m_kCustomCash[i] = m_kCustomCash[i].GetMoney();
	}
	SendMsgToClient(MGPT_SYNC_CUSTOM_CASH, &syncMsg);
}
//----------------------------------------------------------

//////////////////

void LC_ServerPlayer::SyncCommanderAttributeToClient(uint32_t uSyncType,LC_ActorAttributeMap&SyncAttributeMap, bool login,uint64_t ucombatscore, int32_t reasonType)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncCommanderAttributeToClient(uSyncType,SyncAttributeMap, login, ucombatscore);	
	MG_SyncPlayerAttribute syncMsg;
	msg_define::player_attribute_info& sync_value = syncMsg.m_value;
	sync_value.set_login(login);
	sync_value.set_reasontype(reasonType);
	sync_value.set_id(m_iID);
	sync_value.set_career(m_eCareerType);
	sync_value.set_weapon(m_eWeaponAttribute);
	sync_value.set_flag(m_uiPlayerFlag);
	sync_value.set_buddy(-1);
	sync_value.set_usynctype(uSyncType);
	sync_value.set_ucombatscore(ucombatscore);
	uint64_t score = GetCommanderAttrMgr().GetCommanderCombatScoreByType(CST_ControllerEquip);
	sync_value.set_ucommanderequipscore(score);
	SyncAttributeMap.SetDataToPB(*sync_value.mutable_attrs());
	std::stringstream logStr;
	logStr<<"<uSyncType:"<<uSyncType<<">";
	SyncAttributeMap.PrintAttrMap(logStr.str());
	SendMsgToClient(syncMsg.GetMessageID(), &syncMsg);

}

//----------------------------------------------------------
void LC_ServerPlayer::SyncBackPackToClient(int iPackType, bool bIsAllPack)
{
	if (!IsInstance())
	{
		return;
	}
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncBackPackToClient(iPackType);	
	LC_PackAsset* pkPackAsset = GetPackAsset();
	if (NULL == pkPackAsset)
	{
		return;
	}
	switch (iPackType)
	{
	case PACK_TYPE_BASIC:
		{
			// 基本背包
			MG_RLT_BasicPackData msgBasicPackData;
			pkPackAsset->GetBasicPack().SetToProtocol(msgBasicPackData.m_kPack);
			msgBasicPackData.m_bIsAllPack = bIsAllPack;
			SendMsgToClient(MGPT_SYNC_BASIC_PACK, &msgBasicPackData);
		}
		break;
	case PACK_TYPE_WAREHOUSE:
		{
			// 仓库背包
			MG_RLT_WarehousePackData msgWarehousePackData;
			pkPackAsset->GetWarehousePack().SetToProtocol(msgWarehousePackData.m_kPack);
			msgWarehousePackData.m_bIsAllPack = bIsAllPack;
			SendMsgToClient(MGPT_SYNC_WAREHOUSE_PACK, &msgWarehousePackData);		
		}
		break;
	default:
		break;
	}
}

void LC_ServerPlayer::SyncTradePackToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncTradePackToClient();	

	MG_SyncTradePack syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	syncMsg.m_lTradeTarget = m_kTradeManager.GetTradeTargetID();
	syncMsg.m_iPlayerTradeState = m_kTradeManager.GetTradeState();
	TradePackData* pkTradePackData = m_kTradeManager.GetTradePackData();
	syncMsg.m_bMyTradeLock = pkTradePackData->m_bMyTradeLock;
	syncMsg.m_bTradeTargeTradeLock = pkTradePackData->m_bTradeTargeTradeLock;
	syncMsg.m_kMyTradeCash.insert(pkTradePackData->m_kMyTradeCash.begin(), pkTradePackData->m_kMyTradeCash.end());
	syncMsg.m_kTradeTargetCash.insert(pkTradePackData->m_kTradeTargetCash.begin(), pkTradePackData->m_kTradeTargetCash.end());
	for (int i = 0; i < MAX_TRADE_PACK_SIZE; ++i)
	{
		syncMsg.m_iMyTradeItemType[i]  = pkTradePackData->m_akMyTradePackage[i].m_iItemType;
		syncMsg.m_iMyTradeItemIndex[i] = pkTradePackData->m_akMyTradePackage[i].m_iBackPackIndex;
		pkTradePackData->m_akMyTradePackage[i].m_kEntry.SetToProtocol(syncMsg.m_akMyTradePackage[i]);
		pkTradePackData->m_akTradeTargetPackage[i].SetToProtocol(syncMsg.m_akTradeTargetPackage[i]);
	}
	SendMsgToClient(MGPT_SYNC_TRADE_PACK, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncPKStateToClient()
{
	if (!IsInstance())
	{
		return;
	}
	MG_SyncPKMode syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	syncMsg.m_modeindex = GetPKRecorder()->GetPKMode();
	SendMsgToClient(MGPT_SYNC_PK_STATE, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncFightStateToClient()
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}
	MG_SyncFightState syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	syncMsg.m_bPVPFightState = GetPKRecorder()->GetPVPFightState();
	syncMsg.m_bPVEFightState = GetPKRecorder()->GetPVEFightState();
	SendMsgToClient(MGPT_SYNC_FIGHT_STATE, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncTaskTypeDataToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncTaskTypeDataToClient();	

	LC_TaskMap* pkTaskMap = GetTaskMap();
	if (NULL == pkTaskMap)
	{
		return;
	}
	MG_SyncTaskTypeData syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	pkTaskMap->SetDataToProtoclStruct(syncMsg.m_kTaskTypeDataInfo);
	SendMsgToClient(MGPT_SYNC_TASK_TYPE_DATA, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncAssistInfoSetToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncAssistInfoSetToClient();	

	//同步 辅助系统数据  挂机之类
	MG_Assist_Info_Set_Rlt kRltMsg;
	kRltMsg.m_uiRslt = RE_SUCCESS;
	GetAssistAsset().SetDataToProtocolStruct(kRltMsg.m_AssistInfo);
	SendMsgToClient(MGPT_RLT_SET_ASSIST_INFO, &kRltMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncProcessingTaskMapToClient(bool login)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SyncProcessingTaskMapToClient r1 c_uid:%d", GetUserID());
		return;
	}

	if ( !IsMainController() )
		return pOwner->SyncProcessingTaskMapToClient(login);	

	LC_TaskMap* pkTaskMap = GetTaskMap();
	if (NULL == pkTaskMap)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SyncProcessingTaskMapToClient r2 c_uid:%d", GetUserID());
		return;
	}

	if(login)
	{
		CheckProcessingTaskVaild(pkTaskMap);
	}

	MG_SyncProcessingTaskMap syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	LC_ProcessingTaskEntryMap& kProcessEntryMap = pkTaskMap->GetProcessingTaskEntryMap();
	PS_CharProcessingTaskInfo& psProcessingInfo = syncMsg.m_kCharProcessingTaskInfo;
	LC_ProcessingTaskEntryMap::iterator cit = kProcessEntryMap.begin();
	for (int iIndex = 0; cit != kProcessEntryMap.end() && iIndex < MAX_TASK_PROCESSING_COUNT; ++cit, ++iIndex)
	{
		PS_ProcessingTaskNode psTaskNode;
		cit->second.SetDataToProtoclStruct(psTaskNode);
		psProcessingInfo.m_szProcessingTasks.push_back(psTaskNode);
	}
	pkTaskMap->GetLivenessEntry(STT_DAILY_CHALLENGE).SetDataToProtoclStruct(syncMsg.m_kDailyLiveness);
	SendMsgToClient(MGPT_SYNC_PROCESSING_TASK, &syncMsg);

	int size = kProcessEntryMap.size();
	if(size >= MAX_TASK_PROCESSING_COUNT)
	{
		std::stringstream log;
		for(LC_ProcessingTaskEntryMap::iterator it = kProcessEntryMap.begin(); it != kProcessEntryMap.end(); ++it)
		{
			log << it->first << ", ";
		}
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SyncProcessingTaskMapToClient r3 size:%d, taskID:%s", size, log.str().c_str());
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncFinishedTaskMapToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncFinishedTaskMapToClient();

	LC_TaskMap* pkTaskMap = GetTaskMap();
	if (NULL == pkTaskMap)
	{
		return;
	}
	MG_SyncFinishedTaskMap syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	LC_FinishedTaskRecord* pkFinishedRecord = pkTaskMap->GetFinishedTaskRecord();
	pkFinishedRecord->SetDataToProtoclStruct(syncMsg.m_stCharFinishedTaskRecord);
	SendMsgToClient(MGPT_SYNC_FINISHED_TASK, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncFailTaskMapToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncFailTaskMapToClient();

	LC_TaskMap* pkTaskMap = GetTaskMap();
	if (NULL == pkTaskMap)
	{
		return;
	}
	MG_SyncFailTaskInfo syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	LC_FailTaskEntryMap& kFailEntryMap = pkTaskMap->GetFailTaskEntryMap();
	LC_FailTaskEntryMap::iterator cit = kFailEntryMap.begin();
	PS_FailTaskNode tmpNode;
	for (int iIndex = 0; cit != kFailEntryMap.end() && iIndex < MAX_TASK_FAIL_COUNT; ++cit, ++iIndex)
	{
		tmpNode.m_iTaskID = cit->second.GetTaskID();
		tmpNode.m_iTaskIndex = cit->second.GetTaskIndex();
		syncMsg.m_stCharFailTaskInfo.m_szFailTasks.push_back(tmpNode);
	}
	SendMsgToClient(MGPT_SYNC_FAIL_TASK_INFO, &syncMsg);
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncSkillAssetToClient(bool bForce)
{
	if (m_pAssignedBuddyInstance == NULL)
		return;

	BuildSkillCoolDownMap();
	m_pAssignedBuddyInstance->SyncSkillAsset( bForce );
}

void LC_ServerPlayer::SyncBuddySkillAssetToClient(bool bForce)
{
	for (int i = 1; i < MAX_ACTIVE_BUDDY_NUM ; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
		pResultPlayer->SyncSkillAssetToClient(bForce);
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::SyncSkillStatesToClient(int iStateCategory)
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	MG_SyncSkillStates syncMsg;
	msg_define::skill_state_info& rkvalue = syncMsg.m_value;
	rkvalue.set_id(m_iID);
	float fCurrentTime = GET_PROCESS_TIME;
	LC_ActorStateMap* pControllerSkillStateMap = m_pOwnerPlayer->GetControllerStateMap();
	if (pControllerSkillStateMap == NULL)
		return;
	switch (iStateCategory)
	{
	case SSC_MAX_COUNT:
		{
			if (fCurrentTime - m_kSkillStateMap->GetLastSyncTime() > 30.0)
			{
				m_kSkillStateMap->SetToProtocol(rkvalue, SSC_ALL);
				m_kSkillStateMap->SetLastSyncTime(fCurrentTime);
				pControllerSkillStateMap->SetToProtocol(rkvalue, SSC_ALL);
				pControllerSkillStateMap->SetLastSyncTime(fCurrentTime);
			}
			else	//增量更新
			{
				m_kSkillStateMap->SetToProtocol(rkvalue, SSC_MAX_COUNT);
				pControllerSkillStateMap->SetToProtocol(rkvalue, SSC_MAX_COUNT);
			}
		}
		break;
	case SSC_ALL:
		{
			m_kSkillStateMap->SetToProtocol(rkvalue, SSC_ALL);
			pControllerSkillStateMap->SetToProtocol(rkvalue, SSC_ALL);
		}
		break;
	default:
		{
			return;
		}
		break;
	}

	SendMsgToClient(MGPT_SYNC_SKILL_STATE, &syncMsg);
}
//-------------------------------------------------------
void LC_ServerPlayer::SyncPlayerShortcutBarToClient()
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}

	MG_SyncShortcutBar syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	LC_ShortcutBar* pkShortcutBar = GetShortcutBar();
	if (pkShortcutBar)
	{
		pkShortcutBar->SetDataToProtocolStruct(syncMsg.m_akShortcutSlots);
	}
	SendMsgToClient(MGPT_SYNC_SHORTCUTBAR_INFO, &syncMsg);
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::SyncPlayerForbidListToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncPlayerForbidListToClient();
	MG_RLT_ForbidList syncMsg;
	syncMsg.m_lPlayerID = GetID();
	syncMsg.m_kAllForbidInfo = m_kForbidList.GetAllForbidInfo();
	SendMsgToClient(MGPT_RLT_FORBIDLIST, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncTitleNameInfoToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( NULL == pOwner)
		return ;
	if ( !IsMainController() )
		return pOwner->SyncTitleNameInfoToClient();

	MG_SyncTitleNameInfo syncMsg;
	m_kTitleAsset.SetDataToProtocolStruct(syncMsg);
	syncMsg.m_lPlayerID = m_iID;
	SendMsgToClient(MGPT_SYNC_TITLE_PLAYER_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncAchievementInfoToClient()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncAchievementInfoToClient();
	}

	MG_SyncAchievementInfo syncMsg;
	m_AchievementAsset_New.FillSyncAchievementMsg(syncMsg);
	SendMsgToClient(MGPT_SYNC_ACHIEVEMENT_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncPlaceHolderInfoInFOVToClient(float fCurrentTime)
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncPlaceHolderInfoInFOVToClient(fCurrentTime);

	MG_SyncPlaceHoldersInFOV syncMsg;
	int iPlaceHolderCount = 0;
	for(int i = 0 ; i < PHL_MAX ; i++)
	{
		const CSObjectIdSet& rkIDList = m_kFOVMap.GetPlaceHoldersIDInFOV(i);
		iPlaceHolderCount = _placeHolderMsg(syncMsg, rkIDList, fCurrentTime, iPlaceHolderCount);
	}

	syncMsg.m_lPlaceHolderNum = iPlaceHolderCount;
	SendMsgToClient(MGPT_SYNC_CHEST_IN_FOV, &syncMsg);
}

//------------------------------------------------------------------------
void LC_ServerPlayer::SyncSkillCDModifyToClient()
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}
	MG_SyncSkillCDModify kSyncMsg;
	GetSkillCoolDownMap()->SetCDModifyToProtocol(kSyncMsg.m_kSkillCDModify);
	SendMsgToClient(MGPT_SYNC_SKILL_CD_MODIFY, &kSyncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncItemCDToClient()
{
	if (!IsInstance())
	{
		return;
	}

	MG_SyncItemCD kSyncItemCDMsg;
	PS_ItemCDInfo& rkItemCDInfo = kSyncItemCDMsg.m_kItemCDInfo;
	LC_ItemCoolDownMapBase* cdMap = GetControllerItemCoolDownMap();
	if(cdMap != NULL)
	{
		GetControllerItemCoolDownMap()->SetCDToProtocol(this, rkItemCDInfo);
		SendMsgToClient(MGPT_SYNC_ITEM_CD, &kSyncItemCDMsg);
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncTutorialInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncTutorialInfo();

	MG_SyncTutorialAsset syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	memcpy_s(syncMsg.m_byTutorialData, sizeof(syncMsg.m_byTutorialData), m_kTutorialAsset.GetDataBuff(), sizeof(syncMsg.m_byTutorialData));
	SendMsgToClient(MGPT_SYNC_TUTORIAL_ASSET, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncAssignTaskInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncAssignTaskInfo();
	LC_AssignTaskInfo* pkAssignTaskInfo = m_pkTaskMap->GetAssignTaskInfo();

	MG_RLT_AssignTaskInfo Msg;
	Msg.m_lPlayerID = m_iID;
	pkAssignTaskInfo->SetDataToProtoclStruct(Msg);
	SendMsgToClient(MGPT_RLT_ASSIGN_TASK, &Msg);
}

void LC_ServerPlayer::SyncTaskChapterRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncTaskChapterRecord();

	MG_SyncTaskChapterRecord msg;
	m_pkTaskMap->GetTaskChapterRecord(msg.m_nTaskChapters);
	SendMsgToClient(MGPT_SYNC_TASKCHAPTERRAWARD, &msg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncShapeShiftInfo()
{
	if (!IsInstance() && !IsProxy())
	{
		return;
	}

	MG_RLT_ShapeShiftInfo rltMsg;
	rltMsg.m_lPlayerID			= GetID();
	rltMsg.m_bShapeShift		= GetShapeShiftFlag();
	rltMsg.m_lShapeShiftTypeID	= GetShapeShiftCharTypeID();
	BroadCastToArea(MGPT_RLT_SHAPESHIFT_INFO, &rltMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncTransportInfo()
{
	if (!IsInstance())
	{
		return;
	}
	MG_Transport_Asset syncMsg;
	m_ktransportAssert.SetDataToProtocolStruct(syncMsg.m_kAssetData);
	SendMsgToClient(MGPT_SYNC_TRANSPORT_ASSET, &syncMsg);
}
//-------------------------------------------------------------------------
void LC_ServerPlayer::SyncRaidInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncRaidInfo();

	MG_RaidAsset syncMsg;
	m_kraidAssert.SetDataToProtocolStruct(syncMsg.m_kAssetData);
	SendMsgToClient(MGPT_SYNC_RAID_ASSET, &syncMsg);
}
void LC_ServerPlayer::SyncRaidEnterMapRecord(int mapID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
		return pkOwnerPlayer->SyncRaidEnterMapRecord(mapID);

	MG_SyncRaidEnterMapRecord syncMsg;
	m_kraidAssert.FillEnterMapRecord(syncMsg.m_bFirstEnter, syncMsg.m_EnterMapRecord, mapID);
	SendMsgToClient(MGPT_SYNC_RAIDENTERMAPRECORD, &syncMsg);
}
//-----------------------------------------------------------------------
void LC_ServerPlayer::SyncCrossRealmTeamInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncCrossRealmTeamInfo();

	MG_CrossRealmTeamAssert syncMsg;
	m_rTeamAssert.GetCrossRealmTeamAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_CROSSREALMTEAM, &syncMsg);
}
//-----------------------------------------------------------------------
void LC_ServerPlayer::SyncPortal()
{
	if (!IsInstance())
	{
		return;
	}
	MG_PortalAssert syncMsg;
	m_portalAssert.SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_PORTAL, &syncMsg);
}
//-----------------------------------------------------------------------
void LC_ServerPlayer::SyncOpenBag()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncOpenBag();

	MG_OpenBagAssert syncMsg;
	m_OpenBagAssert.SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_OPENBAG, &syncMsg);
}
//----------------------------------------------------------------------
void LC_ServerPlayer::SyncGuildWarInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncGuildWarInfo();

	MG_GuildWarAssert syncMsg;
	LC_GuildWarAssert* pkAsset = GetGuildWarAssert();
	if (pkAsset)
	{
		pkAsset->SetDataToProtocolStruct(syncMsg);
	}
	SendMsgToClient(MGPT_SYNC_GUILDWAR, &syncMsg);
}
//----------------------------------------------------------------------
void LC_ServerPlayer::SyncSignIn(int type)
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncSignIn(type);

	MG_SyncSignInInfo syncMsg;
	syncMsg.m_nType = type;
	switch(type)
	{
	case SIGNIN_TYPE_1:
		{
			m_signinAssert.SetDataToProtocolStruct(syncMsg);			
		}
		break;		
	case SIGNIN_TYPE_2:
		{
			m_n360MicroSignInAssert.SetDataToProtocolStruct(syncMsg);
		}
		break;
	default:
		return;
	}

	SendMsgToClient(MGPT_SYNC_SIGNIN, &syncMsg);
}
//-----------------------------------------------------------------------
void LC_ServerPlayer::SyncAIcontrol()
{
	if (!IsInstance())
	{
		return;
	}
	MG_AIControl syncMsg;
	syncMsg.m_iscontrol = GetAIControl();
	SendMsgToClient(MGPT_SYNC_AICONTROL, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncShortcutKeyInfo()
{
	if (!IsInstance())
	{
		return;
	}
	LC_ShortcutKeyAsset* pkShortcutKeyAsset = GetShortcutKeyAsset();

	MG_SyncShortcutKeyAsset syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	pkShortcutKeyAsset->SetDataToProtocolStruct(syncMsg.m_kShortcutKeyInfo);
	SendMsgToClient(MGPT_SYNC_SHORTCUT_KEY_ASSET, &syncMsg);
}
//------------------------------------------------------------------------

//------------------------------------------------------------------------
void LC_ServerPlayer::SyncActionForbidInfoToClient()
{
	if (!IsInstance())
	{
		return;
	}
	MG_GC_SyncActionForbidInfo syncMsg;
	syncMsg.m_lPlayerID = m_iID;
	m_kActionForbid.SetDataToProtocolStruct(syncMsg.m_byActionForbidInfo);
	SendMsgToClient(MGPT_SYNC_ACTION_FORBID_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncArenaInfoToClient()
{
	if (!IsInstance())
	{
		return;
	}

	MG_PB<char_data_define::char_global_arena_info> syncMsg;
	m_kArenaAsset.SetDataToPB(syncMsg.m_value);
	SendMsgToClient(MGPT_SYNC_ARENA_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncArenaBattleToClient()
{
	if (!IsInstance())
		return;
	MG_GC_SyncArenaBattleInfo syncMsg;
	m_ArenaBattleAssert.SetDataToProtocolStruct(syncMsg.m_DetailInfo);
	SendMsgToClient(MGPT_SYNC_ARENA_BATTLE_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncRankAssertToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncRankAssertToClient();

	MG_GC_SyncRankInfo syncMsg;
	m_RankAssert.SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_RANK_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncDomainAssertToClient()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncDomainAssertToClient();

	MG_SyncPlayerGuildInfo syncMsg;
	m_PlayerGuildAssert.SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_DOMAIN_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncActorOperationAssetToClient()
{
	if (!IsInstance())
	{
		return;
	}
	for (int i = 0; i < LAOT_MAX_COUNT; i++)
	{
		LC_ActorOperationEntry* pkEntry = m_kActorOperationAsset.GetEntryByOperationType(i);
		if (pkEntry && pkEntry->GetDirtyFlag())
		{
			MG_GC_SyncActorOperationAsset syncMsg;
			syncMsg.m_kOperationEntry.m_lOperationType = i;
			pkEntry->SetDataToProtocolStruct(syncMsg.m_kOperationEntry);
			SendMsgToClient(MGPT_SYNC_ACTOR_OPERATION, &syncMsg);
		}
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncDefaultTransferPos()
{
	if (!IsInstance())
	{
		return;
	}

	MG_SyncDefaultTransferPos syncMsg;
	syncMsg.m_iDefaultTransferMapID = m_iDefaultTransferMapID;
	syncMsg.m_iDefaultTransferPosX	= m_vecDefaultTransferPos.x;
	syncMsg.m_iDefaultTransferPosY	= m_vecDefaultTransferPos.y;
	syncMsg.m_iDefaultTransferPosZ	= m_vecDefaultTransferPos.z;
	SendMsgToClient(MGPT_SYNC_DEFAULT_TRANSFER_POS, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncEnterFov()
{
	Protocol::MG_SyncPlayerEnter	msg;
	MC_MessagePackageHelp::Packet(msg,this);
	SendMsgToClient(msg.GetMessageID(),&msg);
}
void LC_ServerPlayer::SyncAllBuddyEnterFov()
{
	if (!IsInstance())
		return;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncAllBuddyEnterFov();

	std::vector<LC_ServerPlayer*> vecBeChallengeEnterBuddyPtrPlayer;
	GetAllBuddyPtrPlayer(vecBeChallengeEnterBuddyPtrPlayer);
	for (int i=0; i<vecBeChallengeEnterBuddyPtrPlayer.size(); ++i)
	{
		LC_ServerPlayer* p_curr = vecBeChallengeEnterBuddyPtrPlayer[i];
		IF_A_NA_PLAYER(p_curr)
			continue;
		p_curr->SyncEnterFov();
	}
}

void LC_ServerPlayer::SyncLeaveFov(object_id_type nID)
{
	Protocol::MG_SyncPlayerLeave	msg;
	MC_MessagePackageHelp::Packet(msg, nID);
	SendMsgToClient(msg.GetMessageID(),&msg);
}

void LC_ServerPlayer::SyncAllBuddyLeaveFov()
{
	if (!IsInstance())
		return;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncAllBuddyLeaveFov();

	std::vector<LC_ServerPlayer*> vecBeChallengeLeaveBuddyPtrPlayer;
	GetAllBuddyPtrPlayer(vecBeChallengeLeaveBuddyPtrPlayer);
	for (int i=0; i<vecBeChallengeLeaveBuddyPtrPlayer.size(); ++i)
	{
		LC_ServerPlayer* p_curr = vecBeChallengeLeaveBuddyPtrPlayer[i];
		IF_A_NA_PLAYER(p_curr)
			continue;
		p_curr->SyncLeaveFov(p_curr->GetID());
	}
}

void LC_ServerPlayer::SyncBuddyNetPlayer()
{
	if (!IS_PLAYER_CLONE_ID( m_iID ))
		return;

	MG_CreateBuddyNetplayer data;
	data.m_iPlayerId = m_iID;
	data.m_iBuddyId = GetCharType();

	SendMsgToClient(MGPT_CREATE_BUDDY_NET_PLAYER, &data);
}

void LC_ServerPlayer::SyncLocationInfo()
{
	SyncBuddyNetPlayer();
	const Utility::UT_Vec3Int& location = GetCurrentLocation();

	MG_RLT_Transfer rltMsg;
	rltMsg.m_iResult		= RE_SUCCESS;
	rltMsg.m_lPlayerID		= GetID();
	rltMsg.m_lMapLogicID	= GetMapLogicID();
	rltMsg.m_lMapResID		= GetMapResID();
	rltMsg.m_lMapLogicType  = GetMapLogicType();
	rltMsg.m_PosX			= location.x;
	rltMsg.m_PosY			= location.y;
	rltMsg.m_PosZ			= location.z;
	int32_t nLocalLineIndex = this->GetLocalLineNum();
	int32_t nGlobalLineIndex = this->GetGlobalLineNum();
	rltMsg.m_iLineNum = nGlobalLineIndex;

	SendMsgToClient(MGPT_RLT_TRANSFER, &rltMsg);
	BroadCastTransferToAreaWithoutMe(GetOwnerPlayerId(), MGPT_RLT_TRANSFER, &rltMsg);

	IncActivateBuddyInSceneCount();
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncAIControlLocation()
{
	if (!IsInstance() || !GetAIControl())
	{
		return;
	}
	PlayerAILocationEntry syncMsg;
	syncMsg.m_lPlayerID = GetID();
	syncMsg.m_lCurrentLocationX = GetCurrentLocation().x;
	syncMsg.m_lCurrentLocationY = GetCurrentLocation().y;
	syncMsg.m_lTargetLocationX = GetTargetLocation().x;
	syncMsg.m_lTargetLocationY = GetTargetLocation().y;
	syncMsg.m_chCurrentDirAngle = LC_Helper::Angle_Float2Char( GetForwardDirAngle() );
	SendMsgToClient(MGPT_SYNC_AICONTROL_LOCATION, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncVIPInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return;

	MG_SyncVIPInfo syncMsg;
	LC_VIPAsset& pVIPAsset = pkOwnerPlayer->GetVIPAsset();
	pVIPAsset.SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_VIP_INFO, &syncMsg);
}

int LC_ServerPlayer::GetTotalEquipSlotLevelByBuddyID(int buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return 0;

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetTotalEquipSlotLevelByBuddyID(buddyID);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.find(buddyID);
	if(it == m_ppUsableBuddyInstance.end())
	{
		return 0;
	}

	BuddyInstance* pkBuddy = it->second;
	if (NULL == pkBuddy)
	{
		return 0;
	}

	return pkBuddy->GetEquipSlotTotalLevel();
}

void LC_ServerPlayer::SyncPromoteInfo()
{
	if (!IsInstance())
	{
		return;
	}

	MG_SyncPromoteInfo syncMsg;
	LC_PromoterAsset& kPromoteAsset = GetPromoterAsset();
	syncMsg.m_uiID = kPromoteAsset.GetID();
	syncMsg.m_uiFlag = kPromoteAsset.GetFlag();
	syncMsg.m_uiRakeOffA = kPromoteAsset.RakeOffA();
	syncMsg.m_uiRakeOffB = kPromoteAsset.RakeOffB();
	kPromoteAsset.GetAsPromoteeInfo().SetDataToProtocol(syncMsg.m_kAsPromotee);
	kPromoteAsset.GetMyPromoteesInfo().SetDataToProtocol(syncMsg.m_kMyPromotees);
	SendMsgToClient(MGPT_MY_PROMOTE_INFO_SYNC, &syncMsg);
}
//-----------------------------------------------------------------------
void LC_ServerPlayer::SyncWorldPowerGuild()
{
	if (!IsInstance())
	{
		return;
	}
	LC_ServerLogicManager* pkServerLogicManager = SERVER_GET_LOGIC_MANAGER();

	LC_WorldGuildWarAsset* pWorldGuildWarAsset = pkServerLogicManager->GetGuildWarAssert();
	if(pWorldGuildWarAsset == NULL)
	{
		return;
	}
	MG_SyncWorldGuildAssertInfo msg;
	pWorldGuildWarAsset->SetDataToProtocolStruct(msg, true);
	SendMsgToClient(MGPT_SYNC_WORLD_POWERGUILD, &msg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncGreatKungFuInfo()
{
	return;
	MG_SyncGreatKungfuInfo syncMsg;
	GetGreatKungFuAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_GREAT_KUNGFU, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncGMInfo()
{
	if (!IsInstance())
	{
		return;
	}
	MG_SyncGMInfo syncMsg;
	syncMsg.m_sUser.append(GetGMUser().c_str(), GetGMUser().size());
	syncMsg.m_uiPriority = GetGMPriority();
	SendMsgToClient(MGPT_SYNC_GM_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncUpdateBulletin()
{
	if (!IsInstance())
	{
		return;
	}
	GameServerApp* pkApp = GetGameServerApp();
	MG_SyncUpdateBulletin syncMsg;
	syncMsg.m_bIsNew = pkApp->CheckBulletinUpdate(m_iBulletinTime);
	syncMsg.m_sUpdateBulletin = TPSTR2STDSTR(pkApp->GetUpdateBulletin());
	SendMsgToClient(MGPT_SYNC_UPDATE_BULLETIN_INFO, &syncMsg);
	if (syncMsg.m_bIsNew)
	{
		m_iBulletinTime = pkApp->GetBulletinTime();
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncOpenAbilityInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncOpenAbilityInfo();

	MG_SyncOpenAbilityInfo syncMsg;
	GetOpenAbilityAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_OPEN_ABILITY_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncSubordinateInfo(bool& bDirty)
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->SyncSubordinateInfo(bDirty);
	}

	MG_SyncSubordinateInfo syncMsg;
	syncMsg.m_lPlayerID = GetID();
	bDirty = GetSubordinateAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_PLAYER_SUB_INFO, &syncMsg);
}

ResultType LC_ServerPlayer::AddSubTransform(int32_t iSubType, int32_t iTransfrom, bool useItem)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddSubTransform(iSubType, iTransfrom, useItem);
	}
	//萌宠,幻兽,背饰 皮肤激活--埋点日志
	int nLogCode = 0;
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(iTransfrom);
	switch(iSubType)
	{
	case LC_SUB_TP_VEHICLE:
		nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, MOUNTS_OPERATE, OPERATE_LOGTYPE5);
		break;
	case LC_SUB_TP_DEVA_EYE:
		nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, PETS_OPERATE, OPERATE_LOGTYPE5);
		break;
	case LC_SUB_TP_MUHUN:
		nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, BEISHI_OPERATE, OPERATE_LOGTYPE5);;
		break;
	}

	ResultType res = GetSubordinateAsset().AddTransform(iSubType, iTransfrom, useItem, nLogCode, nParams);
	if(RE_SUCCESS == res)
	{
		if(iTransfrom == GetGlobalSetting.AutoPickTransformID)
		{
			SetKillNPCExpFlag(true);
		}

		int32_t reasonType = SPART_None;
		switch(iSubType)
		{
		case LC_SUB_TP_VEHICLE:
			reasonType = SPART_Sub_Vehicle_3;
			break;
		case LC_SUB_TP_DEVA_EYE:
			reasonType = SPART_Sub_Devaeye_3;
			break;
		case LC_SUB_TP_MUHUN:
			reasonType = SPART_Sub_Wing_3;
			break;
		}

		GetCommanderAttrMgr().RefreshAllSubAttributeMap(this, false, reasonType, iSubType, true);
	}

	return res;
}

LC_SubordinateAsset&	LC_ServerPlayer::GetSubordinateAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetSubordinateAsset();

	if (!IsMainController())
	{
		return m_pOwnerPlayer->GetSubordinateAsset();
	}
	return LC_PlayerBase::GetSubordinateAsset();
}

//------------------------------------------------------------------------
void LC_ServerPlayer::SyncSkillBookInfo()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SyncSkillBookInfo();
	}

	MG_SyncSkillBookInfo syncMsg;
	GetSkillBookAsset().Save(syncMsg);
	SendMsgToClient(MGPT_SYNC_SKILL_BOOK_INFO, &syncMsg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncOpenNewSkillBook(int32_t iID)
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SyncOpenNewSkillBook(iID);
	}

	MG_SyncOpenNewSkillBook msg;
	msg.m_nSkillBookID = iID;

	SendMsgToClient(MGPT_SYNC_OPEN_NEW_SKILL_BOOK, &msg);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncTreasureChestsInfo()
{
	if (!IsInstance())
	{
		return;
	}

	MG_SyncTreasureChestsInfo syncMsg;
	GetTreasureChestsAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_TREASURE_CHESTS_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncCommonStatInfo(bool& bDirty)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncCommonStatInfo(bDirty);

	MG_SyncCommonStatInfo syncMsg;
	GetCommonStatAsset().SetDataToProtocolStruct(syncMsg, bDirty);
	SendMsgToClient(MGPT_SYNC_COMMON_STAT_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncCommonShopInfo(bool bSelf, bool bGlobal)
{
	if (!IsInstance() || (bSelf == false && bGlobal == false))
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncCommonShopInfo(bSelf, bGlobal);

	MG_SyncShopInfo syncMsg;
	if (bSelf == true)
	{
		GetCommonShopAsset().SetDataToProtocolStruct(syncMsg.m_kPlayerShopInfo);
		syncMsg.m_bSyncSelf = true;
	}
	if (bGlobal == true)
	{
		LC_CommonShopManager* pShopManager = LC_ServerShopManager::GetSingletonPtr();
		if (pShopManager != NULL)
		{
			LC_CommonShopAsset* pShopAsset = pShopManager->GetCommonShopAsset();
			if (pShopAsset != NULL)
			{
				pShopAsset->SetDataToProtocolStruct(syncMsg.m_kGlobalShopInfo);
			}
			syncMsg.m_bSyncGlobal = true;
		}
	}
	SendMsgToClient(MGPT_SYNC_COMMON_SHOP_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncGameStoryAsset()
{
	if (!IsInstance())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncGameStoryAsset();

	MG_GAMESTORY_ASSET_INFO_SYNC syncMsg;
	GetGameStoryAsset().SetDataToProtocolStruct(syncMsg);
	SendMsgToClient(MGPT_SYNC_GAMESTORY_ASSET, &syncMsg);
}

void LC_ServerPlayer::SyncFashionInfo()
{
	if (!IsInstance())
	{
		return;
	}

	MG_RTL_FashionInfo rtlMsg;
	GetFashionBagAsset().Save(rtlMsg);
	SendMsgToClient(MGPT_RLT_GET_FASHION_ASSET_INFO, &rtlMsg);
}
void LC_ServerPlayer::SyncSecretTreasureInfo(void)
{
	if (!IsInstance())
	{
		return;
	}

	MG_PB<char_data_define::secret_treasure_info> syncMsg;
	m_kSecretTreasureAsset.SetDataToPB(syncMsg.m_value);
	SendMsgToClient(MGPT_SYNC_SECRET_TREASURE_INFO, &syncMsg);
}
void LC_ServerPlayer::SyncACTScheduleInfo(bool& bDirty)
{
	if (!IsInstance())
	{
		return;
	}

	MG_PB<char_data_define::char_activity_info> syncMsg;
	bDirty = m_kACTScheduleAsset.SetDataToPB(syncMsg.m_value, false);
	SendMsgToClient(MGPT_SYNC_ACT_SCHEDULE_INFO, &syncMsg);
}

void LC_ServerPlayer::SyncActiviteBuddyProperty(bool bWithoutBuddy)
{
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
		pResultPlayer->SyncPropertyToClient(bWithoutBuddy);
	}
}

void LC_ServerPlayer::SyncAllBuddyInstance()
{
	if (!IsInstance())
		return;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->SyncAllBuddyInstance();

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		int32_t nTemplateId = it->first;
		BuddyInstance* pData = it->second;
		if (pData == NULL)
			continue;
		pData->SyncAllDataToClient();
	}
}
void LC_ServerPlayer::SyncAllInfo_Lite()
{
	SyncPlayerShortcutBarToClient();
	SyncItemCDToClient();
	SyncAIcontrol();
	SyncShortcutKeyInfo();
	SyncActionForbidInfoToClient();
	SyncActorOperationAssetToClient();
	SyncArenaBattleToClient();
	SyncAllBuddyInstance();
}

void LC_ServerPlayer::SyncAllInfo(bool bAsBuddy, bool bRefresh)
{
	if (IsMainController())
		SetCurrentBuddy( m_nCurrentBuddyIndex, true, true, eSwitchBuddyMode_DataOnly );
	//注意时序关系
	if(IsMainController())
	{
		SyncTutorialInfo();
		SyncGuildRewardState();
		SyncControllerPropertyToClient();
		SyncSocietyToClient();
		GetPackAsset()->RemarkModify();

		SyncBackPackToClient(PACK_TYPE_BASIC,true);
		SyncBackPackToClient(PACK_TYPE_WAREHOUSE,true);

		SyncAssistInfoSetToClient();
		SyncProcessingTaskMapToClient(true);
		SyncFinishedTaskMapToClient();
		SyncFailTaskMapToClient();
		SyncTaskTypeDataToClient();
		SyncSkillStatesToClient(SSC_ALL);
		SyncCashToClient();
		SyncYuanBaoToClient();
		SyncPentacleToClient();
		SyncCustomCashToClient();
		SyncTradePackToClient();
		SyncPKStateToClient();
		SyncFightStateToClient();
		SyncPlayerShortcutBarToClient();
		SyncTitleNameInfoToClient();
		SyncAchievementInfoToClient();
		SyncItemCDToClient();
		SyncTransportInfo();
		SyncRaidInfo();
		SyncRaidEnterMapRecord();
		SyncPortal();
		SyncOpenBag();
		SyncGuildWarInfo();
		SyncSignIn(SIGNIN_TYPE_1);
		SyncSignIn(SIGNIN_TYPE_2);
		SyncRankAssertToClient();
		SyncCrossRealmTeamInfo();
		SyncShortcutKeyInfo();
		SyncActionForbidInfoToClient();
		SyncAssignTaskInfo();
		SyncArenaInfoToClient();
		SyncActorOperationAssetToClient();
		SyncDefaultTransferPos();
		SyncArenaBattleToClient();
		SyncRankAssertToClient();
		SyncVIPInfo();
		SyncWorldPowerGuild();
		SyncAssignTaskInfo();
		SyncGMInfo();
		SyncOpenAbilityInfo();
		bool bDirty = false;
		SyncSubordinateInfo(bDirty);
		SyncTreasureChestsInfo();
		SyncGameStoryAsset();
		SyncCommonShopInfo();
		Sync_AnitWallowOnlineTime();

		{
			SERVER_GET_GAMESTORY_MANAGER->NotifyPlayerGameStoryContent(this);

			static Activity::ACT_ScheduleManager* pkScheduleMgr = Activity::ACT_ScheduleManager::GetSingletonPtr();
			pkScheduleMgr->NotifyToPlayer(this);
			pkScheduleMgr->NotifyToPlayerACTRewardInfo(this);
			pkScheduleMgr->NotifyToPlayerBossFirstKillInfo(this);
			pkScheduleMgr->UpdateShopResetTimes(this);
		}

		{
			bool bDirty = false;
			SyncCommonStatInfo(bDirty);
			if (bDirty)
			{
				UpdateDirtyFlag(DIRTY_FLAG_COMMON_STAT_INFO);
			}
		}

		SyncDomainAssertToClient();
		SyncDailyCleanInfo();
		SyncRewardGainInfo();
		SyncSecretTreasureInfo();
		SyncYiZhongQinXiDamageToClient();	

		{
			bool bDirty = false;
			SyncACTScheduleInfo(bDirty);
			if (!bDirty)
			{
				m_kACTScheduleAsset.SetDirtyFlag(false);
			}
		}

		SyncFashionInfo();
		SyncBiographyRewardInfo();
		SyncMainTaskReachRecord();
		SyncPlayerTimeLimitedActivity();
		SyncHolyDeedRecord();
		SyncAllBuddyRuneLevelnfo();
		DailyReceiveReward();
		SyncTreasureNum();
		SyncTaskChapterRecord();//同步任务章节领奖进度	
		NotifyCollectEquipInfo();
		SyncDecompositionSetting();//同步装备分解设置
		SyncLotteryConsumeUnBindYuanBao();
		SyncInvestmentCardRecord();
		SyncInvestmentCardRewardRecord();
		SyncYiZhongQinXiState();
		SyncNewVipInfo();
		GetDropTimesAsset().SyncBossDropInfo(this);
		GetStarShipTimesAsset().SyncBossDropInfo(this);
		SyncProfilePictureRecord();
		SyncCommanderTitleFrameRecord();
		SyncChainFlag();
		SyncRegularBossGroupInfo();
		SyncGoalRecord();
		SyncEquipSuitLevel();
		UT_ServerHelper::SyncKillPlayerInfo(this);
		SyncTestDatabase(true);
		SyncAnswerInfo(true);
		SyncAllChapterRaidStarNum();
		SyncTotalRaidStarNum();
		SyncAllChapterRaidStarRewardRecord();
		GetQuickRaidAsset().SyncQuickRaidAsset(this);
		GetYuanZhengPointAsset().SyncYuanZhengPointInfo(this);
		SyncGuildPresentFlag();
		SyncTreasurePos();
		SyncYiJiTuXiRewardRecord(true);
		SyncYiJiXunBaoRewardRecord(true);
		SyncPetIslandsRewardRecord(true);
		SyncSkillBookInfo();
		SyncActivateStarVein();
		SyncStarVeinGoalRecord();
		SyncFDDay();
		SyncFDRewardRecord();
		syncDailyActivity();
		SyncBuddyGrowthPackage();
		SyncCollectionInfo();
		SyncSkillBookSlotInfo();
		SyncRefreshRewardTaskTimes();
		SyncSevenDayTime();
		SyncSTRewardRecord();
		SyncFirstDayLoginRewardTime();
		BuddyChain_SyncToClient();
		SyncCollectBossJP();
		GetRotaryTableAsset().SyncAllRotaryTableInfo(this);
		SyncBestGuildTaskInfo();
		SyncRobbingTimes();
		SyncEscortTimes();
		SyncAcceptRewardTaskTimes();
		SyncResourceRetrieveState();
		SyncResourceRetrieverRecord();
		SyncFirstChargeInfo();
		SyncVIPExtraRewardUsedTimes();
		SyncNewAchievementStarNum();
		SyncNewAchievementReward();
		SyncGameRestartNotice();
		SyncSingleDamageReward();
		SyncHuanJingInvaildID();
		GetRedPointAsset().SyncAllRedPointFlag(this);
		SyncSubBData();
		BroadcastBuddyEquipSlotState(false);	
		SyncCommandEquip();
		m_RuneData.SyncRuneRecord(this);
		SyncBuddyRuneSlotState();
		SyncAllBuddyRuneEquipToClient();
		GetTaskExtraRewardAsset().SyncTaskExtraReward(this);
		SyncFinishMainTask();
		GetNoviceTutorialAsset().SyncNoviceTutorialInfo(this);
		GetPlayerMapInfoAsset().SyncMapBossFlagInfo(this);
		SyncPetInfoToClient();
		SyncBotInfoToClient();
		SyncNewVIPRewardToClient();
		SyncPropertyToClient();
		SyncGuildMapInfoToPlayer();
		GetCommanderAttrMgr().SyncAllAttr(this, true);
		m_EntrustTask.SendEntrustTask( this );
		m_Lottery.SendLotteryData( this );
		m_ChargeProfit.SendChargeProfitData( this );
		SyncUpdateBulletin();
		//临时屏蔽
		LC_RumorManager::GetSingletonPtr()->SyncRumorLogs(this);

		GetIDAsset().SyncIDAsset(this);

		GetBuddySchemeMgr().SyncBuddyActivateScheme(this);

		GetNonpareilAsset().SyncNonpareilRecordAsset(this);
	}

	SyncPlaceHolderInfoInFOVToClient(GET_PROCESS_TIME);
	SyncAIcontrol();

	if ( bRefresh == false )
	{
		if (bAsBuddy == false)
		{
			SyncBuddyData();
			for (int i = 1; i < MAX_ACTIVE_BUDDY_NUM ; i++)
			{
				LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
				IF_A_NA_PLAYER(pResultPlayer)
					continue;
				pResultPlayer->SyncAllInfo(true);
				pResultPlayer->SetServerViewState(LC_ServerPlayer::SERVER_STATE_INWORLD);
			}
		}
		SyncAllBuddyInstance();
	}
	SyncPetInfoToClient();
	SyncBotInfoToClient();
	SyncNewVIPRewardToClient();
	SyncPropertyToClient();
	SyncGuildMapInfoToPlayer();
	GetCommanderAttrMgr().SyncAllAttr(this, true);
	if( IsMainController() )
	{
		m_EntrustTask.SendEntrustTask( this );
		m_Lottery.SendLotteryData( this );
		m_ChargeProfit.SendChargeProfitData( this );
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::FillLastBiographyPartID()
{
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_Biography::DataEntry* pkBioData = kIter.PeekNextValuePtr();
		Utility::UT_SIMDataList::reverse_iterator it=pkBioData->_iBiographyTaskID.rbegin();
		if(it != pkBioData->_iBiographyTaskID.rend())
		{
			m_nLastBiographyPartID.insert(it->ID());
		}
	}
}
void LC_ServerPlayer::UpdateBiographyOldData()
{
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_Biography::DataEntry* pkBioData = kIter.PeekNextValuePtr();
		int biographyID = pkBioData->_iBiographyID;
		Utility::UT_SIMDataList& list = pkBioData->_iBiographyTaskID;
		for(Utility::UT_SIMDataList::iterator it=list.begin(); it!=list.end(); ++it)
		{
			int partID = it->ID();
			//对于已经领奖的章节，检测下一章节是否已经派发
			//若未派发，加入派发队列中
			//若已派发，加入完成队列中
			{
				if(IsInFinishBiographyRewardPartMap(partID))
				{
					AddAssignBiographyPartID(biographyID, partID);

					int nextPartID = partID+1;
					CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(nextPartID);
					if(NULL == pkData)
					{
						continue;
					}

					//下一章节的任务已经派发，这一章节一定已经完成
					if(IsBiographyPartAlreadyAssign(nextPartID))
					{
						AddFinishBiographyPartID(partID);
					}					
					continue;
				}
			}

			bool tag = true;
			//对于已经派发(任务在派发列表中/玩家已经接取任务)，未完成的章节，加入派发队列中
			{
				tag = true;
				CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(partID);
				Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
				for(int i=0; i<tasks.size(); ++i)
				{
					int taskID = tasks[i].IID();
					if(!IsInProcessingTaskMap(taskID) && !IsInAssignTaskMap(taskID) && !IsInFinishedTaskMap(taskID))
					{
						tag = false;
						break;
					}
				}

				if(tag)
				{
					AddAssignBiographyPartID(biographyID, partID);
					continue;
				}				
			}

			//对于已经派发，已经完成，未领奖的章节，加入派发队列中
			{
				tag = true;
				CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(partID);
				Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
				for(int i=0; i<tasks.size(); ++i)
				{
					int taskID = tasks[i].IID();
					if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
					{
						tag = false;
						break;
					}
				}

				if(tag)
				{
					Utility::UT_SIMDataList& achievements = pkData->_sAchievementID;
					for(int i=0; i<achievements.size(); ++i)
					{
						int achievementID = achievements[i].IID();
						ResultType res = CheckAchievementCanFinish(achievementID);
						if(RE_ACHIEVEMENT_REWARD_HAS_RECEIVED!=res && RE_SUCCESS!=res)
						{
							tag = false;
							break;
						}
					}

					if(tag)
					{
						AddAssignBiographyPartID(biographyID, partID);				
						continue;
					}
				}
			}
		}					
	}
}
void	LC_ServerPlayer::CheckAndSyncPackInfo(float fCurrentTime)
{
	bool bItemAssetDirty = false;
	if ((fCurrentTime - m_fLastCheckEquipEnduranceTime > 10.0f) && m_kPackAsset.GetEnduranceDirtyFlag())
	{
		m_kPackAsset.SetEnduranceDirtyFlag(false);
		m_fLastCheckEquipEnduranceTime = fCurrentTime;
	}
	//重新生成CD表
	if (bItemAssetDirty)
	{
		BuildItemCoolDownMap();
	}
}

void LC_ServerPlayer::CheckCanAssignNextBiographyTask(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->CheckCanAssignNextBiographyTask(tag);

	mem::vector<int> removePartID;
	for(nextAssignBiographyPartSet::iterator it=m_nNextAssignBiographyPartSet.begin(); it!=m_nNextAssignBiographyPartSet.end(); ++it)
	{
		int partID = *it;
		//这个传记是否已经完成
		ResultType res = CheckFinishBiographyPart(partID);
		if(RE_SUCCESS==res)
		{
			if(!IsInFinishBiographyPartMap(partID))
			{
				LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
				pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_BIOGRAPHY_TASK), false, NONE_ASSIGN, NONE_ASSIGN, partID);
				removePartID.push_back(partID);
			}
			else if(!IsLastBiographyPartID(partID))
			{
				LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
				pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_BIOGRAPHY_TASK), false, NONE_ASSIGN, NONE_ASSIGN, partID);
				removePartID.push_back(partID);
			}
		}
	}

	//统一删除，防止迭代器失效
	for(int i=0; i<removePartID.size(); ++i)
	{
		int partID = removePartID[i];
		AddFinishBiographyPartID(partID);		
	}
}

bool	LC_ServerPlayer::IsBiographyPartAlreadyAssign(int biographyPartID)
{	
	CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(biographyPartID);
	if(NULL == pkData)
	{
		return false;
	}

	{
		if(IsInFinishBiographyRewardPartMap(biographyPartID) || IsInFinishBiographyPartMap(biographyPartID))
		{
			return true;
		}
	}

	bool tag = true;
	{
		tag = true;
		Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
		for(int i=0; i<tasks.size(); ++i)
		{
			int taskID = tasks[i].IID();
			if(!IsInProcessingTaskMap(taskID) && !IsInAssignTaskMap(taskID) && !IsInFinishedTaskMap(taskID))
			{
				tag = false;
				break;
			}
		}

		if(tag)
		{
			return true;
		}
	}

	{
		Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
		for(int i=0; i<tasks.size(); ++i)
		{
			int taskID = tasks[i].IID();
			if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
			{
				return false;
			}
		}
		Utility::UT_SIMDataList& achievements = pkData->_sAchievementID;
		for(int i=0; i<achievements.size(); ++i)
		{
			int achievementID = achievements[i].IID();
			ResultType res = CheckAchievementCanFinish(achievementID);
			if(RE_ACHIEVEMENT_REWARD_HAS_RECEIVED!=res && RE_SUCCESS!=res)
			{
				return false;
			}
		}
	}

	return true;
}

//----------------------------------------------------------------------------
void LC_ServerPlayer::PackNetPlayerAttribute(Protocol::MG_RLT_NetPlayerAttribute& rkMsg)
{
	msg_define::net_player_attribute_info& info = rkMsg.m_value;
	info.set_charid(GetInstance());
	GetFinalAttributeMap()->SetDataToPB(*info.mutable_attrs());
}

void LC_ServerPlayer::DailyReceiveReward(bool refreshFlag)
{
	if(refreshFlag)
		m_DailyReward = 0;
	MGPT_Syc_Daily_Reward sycDailyReward;
	sycDailyReward.m_DailyReward = m_DailyReward;
	SendMsgToClient(MGPT_SYC_RECEIVE_DAILY_REWARD, &sycDailyReward);
}

void LC_ServerPlayer::SyncTreasureNum()
{
	MG_SyncTreasureNum sycTreasureNum ;
	for(uint32_t i = 0; i < m_vecTreasureNum.size(); ++i)
	{
		TreasureNumStruct info;
		info.m_uType = m_vecTreasureNum[i].uType;
		info.m_uCount = m_vecTreasureNum[i].uCount;
		sycTreasureNum.m_vecTreasureNum.push_back(info);
	}
	SendMsgToClient(MGPT_SYNC_TREASURE_NUM, &sycTreasureNum);
}


ResultType LC_ServerPlayer::TreasureReward(int nType, mem::vector<int>& vecReward)
{
	if(GetGlobalSetting.vecTreasureRewardNum.empty())
		return RE_FAIL;
	if(GetGlobalSetting.vecTreasureRewardNum.size() < LOTTERY_END)
		return RE_FAIL;
	int configNum = GetGlobalSetting.vecTreasureRewardNum[nType -1];	
	int nOwnNum = 0;
	int index = -1;
	for(uint32_t i = 0; i < m_vecTreasureNum.size(); ++i)
	{
		if(m_vecTreasureNum[i].uType == nType)
		{
			nOwnNum = m_vecTreasureNum[i].uCount;
			index = i;
			break;
		}
	}
	if(nOwnNum == 0)
		return RE_FAIL;
	if(configNum > nOwnNum)
		return RE_FAIL;
	if(index == -1)
		return RE_FAIL;
	if(m_vecTreasureNum[index].uCount >= configNum)
		m_vecTreasureNum[index].uCount -= configNum;
	int controllerLevel =  GetControllerLevel();
	struct randStruct
	{
		int _id;
		int preRand;
		int endRand;
		StringType _Award;
	};
	mem::vector<randStruct> totalVec;
	int totalRand = 1;
	CF_TreasureAddAward::DataEntryMapExternIterator kIter = CF_TreasureAddAward::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		const CF_TreasureAddAward::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		if(pkEntry->_Level > controllerLevel || pkEntry->_TreasureType != nType)
			continue;
		randStruct info;
		info._id = pkEntry->_iID;
		info._Award =  pkEntry->_Award;
		info.preRand = totalRand;
		totalRand += pkEntry->_Weight;
		info.endRand = totalRand;
		totalVec.push_back(info);
	}
	int rewardIndex = -1;
	if(totalRand > 1)
	{
		int randNum = rand()%totalRand + 1 ;
		for(int i = 0; i < totalVec.size();++i)
		{
			if(randNum >= totalVec[i].preRand && randNum < totalVec[i].endRand)
			{
				rewardIndex = i;
				break;
			}
		}
	}
	if(rewardIndex == -1)
		return RE_FAIL;
	//背包能否装得下返还的所有道具
	ResultType res = LC_Helper::CanAddItemByStrReward(this, totalVec[rewardIndex]._Award, CIET_NONE);
	if(RE_SUCCESS != res)
		return res;

	mem::vector<int> resultVec;
	LC_Helper::SpliteString2MultiInt(totalVec[rewardIndex]._Award, resultVec);
	for(int i = 0; i < resultVec.size();++i)
		vecReward.push_back(resultVec[i]);

	LC_Helper::AddItemByString(GetPackAsset(),totalVec[rewardIndex]._Award,CIET_NONE);

	SyncTreasureNum();
	return RE_SUCCESS;
}
void LC_ServerPlayer::AddTreasureRewardNum(int nType,int num)
{
	bool newFlag = true;
	for(uint32_t i = 0; i < m_vecTreasureNum.size(); ++i)
	{
		if(m_vecTreasureNum[i].uType == nType)
		{
			m_vecTreasureNum[i].uCount += num;
			newFlag = false;
			break;
		}
	}
	if(newFlag)
	{
		sTreasureNumStruct info ;
		info.uType = nType;
		info.uCount = num;
		m_vecTreasureNum.push_back(info);
	}
	SyncTreasureNum();
}

//----------------------------------------------------------------------------
void LC_ServerPlayer::_updateDaily()
{
	uint32_t now = GET_CURRENT_TIMESTAMP_IN_SECONDS();
#ifdef WIN32
	uint32_t hour = (uint32_t)((now - _timezone) / ONE_HOUR_SECONDS);
#else
	uint32_t hour = (uint32_t)((now - timezone) / ONE_HOUR_SECONDS);
#endif
	UpdateDailySystem(now);
}
//----------------------------------------------------------------------------
uint64_t LC_ServerPlayer::GetRankValueByRankType(int32_t rankType)
{
	uint64_t value = 0;
	int32_t buddyID = LC_Helper::GetBuddyIDByRankType(rankType);
	if(buddyID > 0)
	{
		value = GetBuddyAllBaseCombatScore(buddyID);
	}
	else
	{
		switch(rankType)
		{
		case Rank_Type_Level:
			value = GetCommanderLevel();
			break;
		case Rank_Type_Battle:
			value = GetControllerCombatScore();
			break;
		case Rank_Type_Vehicle:
			value = GetCommanderAttrMgr().GetSubCombatScoreBySubType(LC_SUB_TP_VEHICLE);
			break;
		case Rank_Type_Devaeye:
			value = GetCommanderAttrMgr().GetSubCombatScoreBySubType(LC_SUB_TP_DEVA_EYE);
			break;
		case Rank_Type_Wing:
			value = GetCommanderAttrMgr().GetSubCombatScoreBySubType(LC_SUB_TP_MUHUN);
			break;
		case Rank_Type_Ultimate:
			value = GetEndlessTotalFloor();
			break;
		case Rank_Type_MJBOSS:
			value = GetMJBossValue();
			break;
		case Rank_Type_Pet:
			value = GetTotalPetCombatScore();
			break;
		case Rank_Type_Rune:
			value = GetAllRuneItemCombatScore();
			break;
		case Rank_Type_BuddyEquip:
			value = GetAllBuddyEquipCombatScore();
			break;
		case Rank_Type_FinishMainTaskID:
			value = GetFinishMainTaskID();
			break;
		case Rank_Type_ExpTranscriptCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_Exp);
			break;
		case Rank_Type_WuXiaShengTangCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_jinjie2);
			break;
		case Rank_Type_MingYuShenYuanCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_jinjie1);
			break;
		case Rank_Type_MiYuanHuiLangCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_jinjie3);
			break;
		case Rank_Type_ZhiRanJiaoTuCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_DailyDungeons);
			break;
		case Rank_Type_ThreeBuddy:
			value = GetCommanderAttrMgr().GetThreeBuddy();
			break;
		case Rank_Type_NewAchievement:
			value = GetNewAchievementStarNum();
			break;
		case Rank_Type_RongGuangYuanZhengCount:
			value = GetRongGuangYuanZhengMapValue();
			break;
		case Rank_Type_SubVehicleCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_Sub1);
			break;
		case Rank_Type_SubDevaEyeCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_Sub2);
			break;
		case Rank_Type_SubMuhunCount:
			value = GetMapFinishCountFromGameStoryID(GameStoryIDType_Sub3);
			break;
		default:
			break;
		}
	}

	return value;
}
void LC_ServerPlayer::UpdateRankUserValueByRankType(int32_t rankType)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateRankUserValueByRankType(rankType);
	}

	MG_GG_Update_UserRankValue msg;
	msg.m_CharID = GetInstance();
	msg.m_ServerID = GetGameServerID();
	msg.m_RankType = rankType;
	msg.m_RankValue = GetRankValueByRankType(rankType);

	LC_RankManager* rank_manager=SERVER_GET_RANK_MANAGER();
	rank_manager->FillPlayerData(this, msg.m_UserInfo);
	SendMsgToGroup(MGPT_SS_RANK_UPDATE_USERVALUE, &msg, GetUserID(), GetInstance());
}

void LC_ServerPlayer::UpdatePlayerBaseDataToGroup()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdatePlayerBaseDataToGroup();
	}

	if(IsRobot())
	{
		return;
	}

	LC_RankManager* rank_manager=SERVER_GET_RANK_MANAGER();
	MG_GG_REQ_UpdatePlayerBaseData msg;
	msg.m_ServerID = GetGameServerEntryID();
	msg.m_nCharID = GetInstance();	
	rank_manager->FillRankPlayerBaseData(this, msg.m_PlayerBaseData);
	SendMsgToGroup(MGPT_SS_REQ_UPDATEPLAYERBASEDATA, &msg, GetUserID(), GetInstance());
}

//----------------------------------------------------------------------------
ResultType LC_ServerPlayer::TryRealizeGreatKungFu(uint32_t uiID)
{
	if (!IsInstance())
	{
		return RE_FAIL;
	}

	ResultType rslt = GetGreatKungFuAsset().TryRealize(this, uiID);

	return rslt;
}
//----------------------------------------------------------------------------
ResultType LC_ServerPlayer::OpenAbility(int32_t id, int32_t iType, int32_t iKey, bool send, bool force)
{
	switch (iType)
	{
	case LC_ABT_SUB:
		{
			ResultType retFlag = GetSubordinateAsset().EnableSub(iKey);
			if( RE_SUCCESS == retFlag)
			{
				int32_t reasonType = SPART_None;
				switch(iKey)
				{
					int32_t reasonType = SPART_None;
					switch(iKey)
					{
					case LC_SUB_TP_VEHICLE:
						reasonType = SPART_Sub_Vehicle_1;
						break;
					case LC_SUB_TP_DEVA_EYE:
						reasonType = SPART_Sub_Devaeye_1;
						break;
					case LC_SUB_TP_MUHUN:
						reasonType = SPART_Sub_Wing_1;
						break;
					case LC_SUB_TP_TALISMAN:
						reasonType = SPART_Sub_MingHao_1;
						break;
					}
					GetCommanderAttrMgr().RefreshAllSubAttributeMap(this, false, reasonType, iKey);
				}
				return retFlag;
			}
			return retFlag;
		}
		break;
	case LC_ABT_SKILL:
		{
			int32_t iSlotIndex = -1;
			if (!LearnSkillToController(iKey, iSlotIndex, send))
			{
				return RE_FAIL;
			}
		}
		break;
	case LC_ABT_TASK:
		{
			LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
			if (pkTaskManager)
			{
				if(iKey == STT_REWARD_TASK)
				{
					bool tag = UT_ServerHelper::CheckActivityVaild(GetGlobalSetting.RewardTaskActivityScheduleID_1);
					if(tag)
					{
						int32_t endTime = UT_ServerHelper::GetActivityEndTime(GetGlobalSetting.RewardTaskActivityScheduleID_1);
						AssignRewardTask(AssignRewardTaskType_OpenLevel, endTime);							
					}
					else
					{
						return RE_FAIL;
					}
				}
				else
				{
					pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(iKey), false, FIRST_ASSIGN);
				}
			}
		}
		break;
	case LC_ABT_SKILL_BOOK:
		{
			bool open = GetSkillBookAsset().OpenSkillBookSystem();
			if(open)
			{
				SyncSkillBookInfo();
			}
			return GetSkillBookAsset().GetSkillBookSystemState();
		}
		break;
	case LC_ABT_BUDDY_RUNE:
		{
			bool open = GetBuddyRuneEquipState();
			if(!open)
			{
				if(SetBuddyRuneSlotState())
				{
					SyncBuddyRuneSlotState(true);
					CheckRuneSlotDressState();
				}
			}
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_BUDDY_EQUILSLOT_STAR:
		{
			if(false==GetBuddyEquipSlotStarState() && true==SetBuddyEquipSlotStarState())
			{
				BroadcastBuddyEquipSlotState(true);				
			}			
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_PET:
		{
			OpenPetAbility(id);
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_YIZHONGQINXI:
		{
			bool open = GetYiZhongQinXiState();
			if(!open)
			{
				SetYiZhongQinXiState(true);
				SyncYiZhongQinXiState();
			}
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_NEWVIP:
		{
			bool open = GetNewVipState();
			if(!open)
			{
				SetNewVipState(true);
				SyncNewVipInfo();
			}
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_RESOURCE_RETRIEVE:
		{
			return OpenResourceRetrieve();
		}
		break;
	case LC_ABT_UIOPENLEVEL:
		{
			return RE_SUCCESS;
		}
		break;
	case LC_ABT_NONPAREIL:
		{
			return RE_SUCCESS;
		}
	default:
		return RE_FAIL;
	}
	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::CloseAbility(int32_t iType, int32_t iKey)
{
	switch (iType)
	{
	case LC_ABT_SUB:
		{
			GetSubordinateAsset().DisableSub(iKey);
		}
		break;
	case LC_ABT_SKILL:
		{
			RemoveSkill(iKey);
		}
		break;
	case LC_ABT_TASK:
		{
			//not surported
		}
		break;
	case LC_ABT_SKILL_BOOK:
		{
			GetSkillBookAsset().CloseSkillBook(iKey);
		}
		break;
	default:
		return RE_FAIL;
		break;
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::OpenPetAbility(int32_t abilityID, int32_t petID, bool force)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOnwerPlayer = GetOwnerPlayer();
	if(NULL==pkOnwerPlayer)
	{
		return res;
	}

	if(!IsMainController())
	{
		return pkOnwerPlayer->OpenPetAbility(abilityID, petID, force);
	}

	//参数合法性
	if(petID==0 || GetGlobalSetting.petIDs.end() != find(GetGlobalSetting.petIDs.begin(), GetGlobalSetting.petIDs.end(), petID))
	{
		CF_OpenLevel::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_OpenLevel>(abilityID);
		if(NULL != pkData)
		{			
			LC_OpenAbilityAsset& asset = GetOpenAbilityAsset();
			LC_OpenAbilityEntryMap& mapEntry = asset.GetEntryMap();
			LC_OpenAbilityEntryMap::iterator findIt = mapEntry.find(abilityID);
			LC_OpenAbilityEntry* entry = NULL;
			if(findIt != mapEntry.end())
			{
				entry = &(findIt->second);
			}

			bool flag = false;
			if(!force && NULL!=entry)
			{
				//条件是否满足
				res = entry->CheckAbility(this, time(NULL), flag);
				if(RE_SUCCESS != res)
				{
					return res;
				}
			}

			//开启
			res = OpenPetSystem(petID);
			if(RE_SUCCESS == res)
			{
				SyncPetInfoToClient();
			}
		}
	}

	return res;
}
//----------------------------------------------------------------------------
void	LC_ServerPlayer::RecommendFriend()
{
	LC_ServerPlayerManager* pkServerPlayerManager = SERVER_GET_PLAYER_MANAGER();
	mem::vector<unique_id_type> playerUIDVec;
	pkServerPlayerManager->GetRandomPlayerId(playerUIDVec, 2*MAX_RECOMMEND_FRIEND_NUM);

	mem::vector<unique_id_type> recommendPlayerUIDVec;
	for(int i=0;i<playerUIDVec.size();++i)
	{
		unique_id_type beRecommendUID = playerUIDVec[i];
		if(beRecommendUID== GetInstance() || IsFriend(beRecommendUID) || IsEnemy(beRecommendUID) || IsInBlackList(beRecommendUID) || IsInForbidList(beRecommendUID))
		{
			continue;
		}

		if(recommendPlayerUIDVec.size() >= MAX_RECOMMEND_FRIEND_NUM)
		{
			break;
		}

		recommendPlayerUIDVec.push_back(beRecommendUID);
	}

	MG_RLT_Recommend_Friend msg;
	msg.m_iResult = RE_SUCCESS;
	for(int j=0; j<recommendPlayerUIDVec.size(); ++j)
	{
		LC_ServerPlayer* pkBeRecommendPlayer = (LC_ServerPlayer*)(pkServerPlayerManager->FindPlayer(recommendPlayerUIDVec[j]));
		if(pkBeRecommendPlayer == NULL)
		{
			continue;
		}

		PS_PlayerBasicInfo playerInfo;
		playerInfo.uiCharID = pkBeRecommendPlayer->GetInstance();
		playerInfo.szCharName = TPSTR2STDSTR(pkBeRecommendPlayer->GetOwnerCharName());
		playerInfo.iCareer = pkBeRecommendPlayer->GetCareerType();
		playerInfo.iLevel = pkBeRecommendPlayer->GetLevel();
		playerInfo.iScore = pkBeRecommendPlayer->GetControllerCombatScore();
		playerInfo.iBornCharType = pkBeRecommendPlayer->GetProfilePictureID();
		msg.m_RecommendFriendInfos.push_back(playerInfo);
	}

	if(msg.m_RecommendFriendInfos.size() == 0)
	{
		msg.m_iResult = RE_ONLINE_PLAYER_TOO_FEW;
	}
	SendMsgToClient(MGPT_RLT_FRIEND_RECOMMEND_FRIEND, &msg);
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::SaveCharInfoToFriendDB(bool force)
{
	if (!force && m_iDBUpdateTick++ % 5)
	{
		return;
	}

	MG_SS_REQ_Update_CharInfo kMsg;
	kMsg.m_iServerID = m_iServerID;
	fillCharFriendInfo(kMsg.m_kCharInfo);
	SendMsgToSociety(MGPT_GF_REQ_UPDATE_CHARINFO, &kMsg, m_dwUserID, GetInstance());
}

void LC_ServerPlayer::fillCharFriendInfo(PS_FriendInfo& kCharInfo)
{
	//kCharInfo.iFriendGroupID = 0;
	LC_PlayerGroupBase* group = GetPlayerGroup();
	if (group != NULL)
	{
		kCharInfo.iGroupID	= group->GetID();
		kCharInfo.iGroupNum	= group->GetMemberCount(false);
	}
	kCharInfo.iMapID = GetMapResID();
	kCharInfo.iArea = GetCurrentLogicAreaID();
	kCharInfo.iServerID = GetCitizenship();
	TPSTR2STDSTR(GetCharMood(), kCharInfo.szMood);

	kCharInfo.kBasicInfo.iCharType = GetCharType();
	kCharInfo.kBasicInfo.iCareer = GetCareerType();
	kCharInfo.kBasicInfo.iWeaponType = GetWeaponAttribute();
	kCharInfo.kBasicInfo.iLevel = GetLevel();
	kCharInfo.kBasicInfo.uiCharID = GetInstance();
	TPSTR2STDSTR(GetOwnerCharName(), kCharInfo.kBasicInfo.szCharName);
	//kCharInfo.kBasicInfo.iScore = GetTotalScore();
	kCharInfo.kBasicInfo.iScore = GetControllerCombatScore();
	kCharInfo.kBasicInfo.iCurServerID = UT_ServerHelper::GetServerId();
	kCharInfo.kBasicInfo.iBornCharType = GetProfilePictureID();
	const platform_vip_info& pf_info = GetPlatformVipInfo();
	for(platform_vip_info::const_iterator iter = pf_info.begin(); iter != pf_info.end(); iter++)
	{
		kCharInfo.kBasicInfo.kPlatform[iter->first.c_str()] =  iter->second.format_vip_info();
	}

	LC_SocietyAsset* pSocietyAsset = GetSocietyAsset();
	kCharInfo.kBasicInfo.iStatus = uint8_t(pSocietyAsset->GetStatus());
}
//------------------------------------------------------------------------------------------
uint32_t LC_ServerPlayer::GetRelationFlag(const unique_id_impl& charID)
{
	LC_SocietyAsset* pkSocietyAsset = GetSocietyAsset();

	LC_SocietyBasicInfo* pkBasic = pkSocietyAsset->GetSocietyInfo(charID);
	return pkBasic ? pkBasic->GetFlag() : 0;
}
//------------------------------------------------------------------------------------------

ResultType LC_ServerPlayer::ChangeCharFriendRelation(ResultType rslt, const char_data_define::friend_relation_info& relation, const char_data_define::friend_char_info& char_info, const std::string& msg)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return RE_FAIL;

	if (!IsMainController())
	{
		return pOwner->ChangeCharFriendRelation(rslt, relation, char_info, msg);
	}
	LC_SocietyAsset* pkSocietyAsset = GetSocietyAsset();


	uint64_t playerCharID = GetInstance();

	LC_ServerPlayerManager* pkServerPlayerManager = SERVER_GET_PLAYER_MANAGER();
	LC_ServerPlayer* pkTargetPlayer = (LC_ServerPlayer*)(pkServerPlayerManager->FindPlayer(relation.char_id()));
	uint32_t preFlag = GetRelationFlag(relation.char_id());
	uint32_t identicalFlag = preFlag & relation.flag();
	preFlag &= ~identicalFlag;
	uint32_t postFlag = relation.flag() & ~identicalFlag;
	LC_SocietyBasicInfo kBaseInfo;
	kBaseInfo.SetCharID(char_info.char_id());
	if (pkTargetPlayer)
	{
		kBaseInfo.SetStatus(pkTargetPlayer->GetSocietyAsset()->GetStatus());
		kBaseInfo.SetCharName(pkTargetPlayer->GetOwnerCharName());
		kBaseInfo.SetCareer(pkTargetPlayer->GetCareerType());
		kBaseInfo.SetCharType(pkTargetPlayer->GetCharType());
		kBaseInfo.SetLevel(pkTargetPlayer->GetLevel());
		kBaseInfo.SetWeaponType(pkTargetPlayer->GetWeaponAttribute());

		kBaseInfo.SetScore(pkTargetPlayer->GetControllerCombatScore());
		kBaseInfo.SetCurrentServer(pkTargetPlayer->GetServerID());
		kBaseInfo.SetBornCharType(pkTargetPlayer->GetProfilePictureID());

		kBaseInfo.m_Platform.clear();
		const platform_vip_info& pf_info = pkTargetPlayer->GetPlatformVipInfo();
		for(platform_vip_info::const_iterator iter = pf_info.begin(); iter != pf_info.end(); iter++)
		{
			const platform_node& rPfNode = iter->second;
			kBaseInfo.m_Platform[iter->first.c_str()] = rPfNode.format_vip_info();
		}
	}
	else
	{
		kBaseInfo.SetStatus(LC_SST_OFFLINE);
		kBaseInfo.SetCharName(char_info.char_name().c_str());
		kBaseInfo.SetCareer(char_info.career());
		kBaseInfo.SetCharType(char_info.char_type());
		kBaseInfo.SetLevel(char_info.level());
		kBaseInfo.SetWeaponType(char_info.weapon());

		kBaseInfo.SetScore(char_info.score());
		kBaseInfo.SetCurrentServer(char_info.serverid());
		kBaseInfo.SetBornCharType(char_info.bornchartype());

		kBaseInfo.m_Platform.clear();
		for (int i=0; i<char_info.platforms_size(); ++i)
		{
			const char_data_define::platform_info& rentry = char_info.platforms(i);
			kBaseInfo.m_Platform[rentry.name().c_str()] = rentry.detail();
		}
	}
	kBaseInfo.SetDegree(relation.degree());

	PS_SocietyBasicInfo psBasicIF;
	psBasicIF.iCharType = kBaseInfo.GetCharType();
	psBasicIF.iStatus = kBaseInfo.GetStatus();
	psBasicIF.iCareer = kBaseInfo.GetCareer();
	psBasicIF.iWeaponType = kBaseInfo.GetWeaponType();
	psBasicIF.iLevel = kBaseInfo.GetLevel();
	psBasicIF.uiCharID = kBaseInfo.GetCharID();
	TPSTR2STDSTR(kBaseInfo.GetCharName(), psBasicIF.szCharName);
	psBasicIF.iScore = kBaseInfo.GetScore();
	psBasicIF.uiDegree = kBaseInfo.GetDegree();
	psBasicIF.iCurServerID = kBaseInfo.GetCurrentServer();
	psBasicIF.iBornCharType = kBaseInfo.GetBornCharType();

	sim_platform_info::iterator it = kBaseInfo.m_Platform.begin();
	for (; it!=kBaseInfo.m_Platform.end(); ++it)
	{
		psBasicIF.kPlatform[it->first.c_str()] = it->second;
	}	

	int action_type = 0;
	for (uint32_t i = 0; i < char_data_define::friend_relation_info_relation_type_MAX; i++)
	{
		if (preFlag & (1 << i))
		{
			switch (i)
			{
			case char_data_define::friend_relation_info_relation_type_FRIEND:
				{
					MG_RLT_DelFriend rltDelFriendMsg;
					rltDelFriendMsg.m_lTargetCharID = relation.char_id();
					rltDelFriendMsg.m_iResultType = rslt;
					if (RE_SUCCESS == rslt)
					{
						action_type = 2;
						rltDelFriendMsg.m_iResultType = pkSocietyAsset->DeleteSociety(ST_FRIEND, relation.char_id());
						//找到被删的人，如果被删的人在线，查找被删的人的"我是谁的好友"列表，如果有请求删好友的人，则把这个人删掉
						if(pkTargetPlayer)
						{
							pkTargetPlayer->GetSocietyAsset()->DeleteBeSociety(ST_FRIEND, playerCharID);
							pkTargetPlayer->GetSocietyAsset()->RegDirtyIDs(GetInstance());
						}
						pkSocietyAsset->RegDirtyIDs(relation.char_id());
					}
					SendMsgToClient(MGPT_RLT_DEL_FRIEND, &rltDelFriendMsg);
				}
				break;
			case char_data_define::friend_relation_info_relation_type_ENEMY:
				{
					MG_RLT_DelEnemy kDelEnemyMsg;
					kDelEnemyMsg.m_iResultType = rslt;
					kDelEnemyMsg.m_lTargetCharID = relation.char_id();

					if (rslt == RE_SUCCESS)
					{
						action_type = 6;
						kDelEnemyMsg.m_iResultType = pkSocietyAsset->DeleteSociety(ST_ENEMY, relation.char_id());
					}
					SendMsgToClient(MGPT_RLT_DEL_ENEMY, &kDelEnemyMsg);
				}
				break;
			case char_data_define::friend_relation_info_relation_type_BLACK:
				{
					MG_RLT_DelBlackList rltDelBlackListMsg;
					rltDelBlackListMsg.m_iResultType = rslt;
					rltDelBlackListMsg.m_lTargetCharID = relation.char_id();

					if (rslt == RE_SUCCESS)
					{
						action_type = 4;
						rltDelBlackListMsg.m_iResultType = pkSocietyAsset->DeleteSociety(ST_BLACKLIST, relation.char_id());
					}
					SendMsgToClient(MGPT_RLT_DEL_BLACKLIST, &rltDelBlackListMsg);
				}
				break;
			case char_data_define::friend_relation_info_relation_type_MAX:
			default:
				break;
			}
			if (action_type > 0)
			{
				oss_role_friend(this, action_type, "0", char_info.char_id(), kBaseInfo.GetCharName().c_str(), kBaseInfo.GetWeaponType(), kBaseInfo.GetCharType(), kBaseInfo.GetLevel());
			}
		}
	}
	for (uint32_t i = 0; i < char_data_define::friend_relation_info_relation_type_MAX; i++)
	{
		if (identicalFlag & (1 << i))
		{
			switch (i)
			{
			case char_data_define::friend_relation_info_relation_type_FRIEND:
				{
					pkSocietyAsset->UpdateSocietyBaseInfo(ST_FRIEND, kBaseInfo);
				}
				break;
			case char_data_define::friend_relation_info_relation_type_ENEMY:
				{
					pkSocietyAsset->UpdateSocietyBaseInfo(ST_ENEMY, kBaseInfo);
				}
				break;
			case char_data_define::friend_relation_info_relation_type_BLACK:
				{
					pkSocietyAsset->UpdateSocietyBaseInfo(ST_BLACKLIST, kBaseInfo);
				}
				break;
			default:
				break;
			}
		}
		else if (postFlag & (1 << i))
		{
			switch (i)
			{
			case char_data_define::friend_relation_info_relation_type_FRIEND:
				{
					MG_RLT_AddFriend rltMsg;
					rltMsg.m_lTargetCharID = relation.char_id();
					rltMsg.m_iResultType = rslt;
					rltMsg.m_szCharName = char_info.char_name();

					MG_RLT_GetFriendDetail rltSingleInfo;
					rltSingleInfo.m_uiCharID = relation.char_id();
					rltSingleInfo.m_iResult = RE_SUCCESS;

					PS_FriendInfo& psFriendIF = rltSingleInfo.m_kFriendInfo;
					psFriendIF.kBasicInfo = psBasicIF;
					psFriendIF.iServerID =psBasicIF.iCurServerID;
					if (rslt == RE_SUCCESS)
					{
						rltMsg.m_iResultType = pkSocietyAsset->AddSociety(ST_FRIEND, relation.char_id(), char_info.char_name().c_str());
						if (pkTargetPlayer)
						{
							//把申请的人加进被申请人的"我在谁的好友列表清单中"
							pkTargetPlayer->GetSocietyAsset()->AddBeSociety(ST_FRIEND, playerCharID);
							pkTargetPlayer->GetSocietyAsset()->RegDirtyIDs(GetInstance());

							psFriendIF.iMapID = static_cast<int16_t>(pkTargetPlayer->GetMapResID());
							psFriendIF.iArea = static_cast<int16_t>(pkTargetPlayer->GetCurrentLogicAreaID());
							TPSTR2STDSTR(pkTargetPlayer->GetCharMood(), psFriendIF.szMood);
							const platform_vip_info& pf_info = pkTargetPlayer->GetPlatformVipInfo();
							for(platform_vip_info::const_iterator iter = pf_info.begin(); iter != pf_info.end(); iter++)
							{
								psFriendIF.kBasicInfo.kPlatform[iter->first.c_str()] =  iter->second.format_vip_info();
							}
							psFriendIF.kBasicInfo.beFriendWithEachOther = pkSocietyAsset->IsInBeSociety(ST_FRIEND, pkTargetPlayer->GetInstance());
						}
						pkSocietyAsset->RegDirtyIDs(relation.char_id());	
						psFriendIF.iServerID = GetGameServerID();
						action_type = 1;
						if (pkTargetPlayer)
						{
							LC_FriendInfo* pkTarFriendInfo = pkTargetPlayer->GetSocietyAsset()->GetFriendInfo();
							{
								if (!pkTarFriendInfo->IsExist(GetInstance()))
								{
									MG_REQ_Confirm_BeAddFriend xConfirmMsg;
									xConfirmMsg.m_lTargetCharID = GetInstance();
									TPSTR2STDSTR(GetOwnerCharName(), xConfirmMsg.m_szCharName);
									xConfirmMsg.m_szMsg = msg;
									xConfirmMsg.m_uiCareer = GetCareerType();
									xConfirmMsg.m_uiWeaponType = GetWeaponAttribute();
									xConfirmMsg.m_uiLevel = GetLevel();
									xConfirmMsg.m_BornCharType = GetProfilePictureID();
									pkTargetPlayer->SendMsgToClient(MGPT_REQ_CONFIRM_BEADDFRIEND, &xConfirmMsg);
								}
								else
								{
									MG_RLT_BeAddFriend kRltMsg;
									kRltMsg.m_lTargetCharID = GetInstance();
									TPSTR2STDSTR(GetOwnerCharName(), kRltMsg.m_szCharName);
									kRltMsg.m_iResult = RE_BEADDFRIEND_SUCCESS;
									pkTargetPlayer->SendMsgToClient(MGPT_RLT_BEADDFRIEND, &kRltMsg);
								}
							}
						}
						else
						{
							MG_SS_REQ_RegRequest reqMsg;
							reqMsg.m_uiCharID = relation.char_id();

							TPSTR2STDSTR(GetOwnerCharName(), reqMsg.m_szCharName);
							reqMsg.m_szMsg = msg;
							reqMsg.m_uiCareer = GetCareerType();
							reqMsg.m_uiWeaponType = GetWeaponAttribute();
							reqMsg.m_uiLevel = GetLevel();
							SendMsgToSociety(MGPT_GF_REQ_REG_REQUEST, &reqMsg, GetUserID(), GetInstance());
						}
					}
					SendMsgToClient(MGPT_RLT_ADD_FRIEND, &rltMsg);
					SendMsgToClient(MGPT_RLT_GETFRIEND_DETAIL, &rltSingleInfo);

					//添加好友成功，通知成就系统
					if(rltMsg.m_iResultType == RE_ADD_FRIEND_SUCCESS)
					{
						AchievementEvent kEvent;
						kEvent.SetNum(1);
						UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ADDFRIEND, kEvent);
					}
				}
				pkSocietyAsset->UpdateSocietyBaseInfo(ST_FRIEND, kBaseInfo);
				break;
			case char_data_define::friend_relation_info_relation_type_ENEMY:
				{
					MG_RLT_AddEnemy rltMsg;
					rltMsg.m_lTargetCharID = relation.char_id();
					rltMsg.m_iResultType = rslt;
					rltMsg.m_kEnemyInfo = psBasicIF;
					if (rslt == RE_SUCCESS)
					{
						action_type = 5;
						rltMsg.m_iResultType = pkSocietyAsset->AddSociety(ST_ENEMY, relation.char_id(), char_info.char_name().c_str());
					}
					SendMsgToClient(MGPT_RLT_ADD_ENEMY, &rltMsg);
				}
				pkSocietyAsset->UpdateSocietyBaseInfo(ST_ENEMY, kBaseInfo);
				break;
			case char_data_define::friend_relation_info_relation_type_BLACK:
				{
					MG_RLT_AddBlackList rltMsg;
					rltMsg.m_lTargetCharID = relation.char_id();
					rltMsg.m_iResultType = rslt;
					rltMsg.m_kBlackListInfo = psBasicIF;
					if (rslt == RE_SUCCESS)
					{
						action_type = 3;
						rltMsg.m_iResultType = pkSocietyAsset->AddSociety(ST_BLACKLIST, relation.char_id(), char_info.char_name().c_str());
					}
					SendMsgToClient(MGPT_RLT_ADD_BLACKLIST, &rltMsg);
				}
				pkSocietyAsset->UpdateSocietyBaseInfo(ST_BLACKLIST, kBaseInfo);
				break;
			default:
				break;
			}
			if (action_type > 0)
			{
				oss_role_friend(this, action_type, "0", char_info.char_id(), kBaseInfo.GetCharName().c_str(), kBaseInfo.GetWeaponType(), kBaseInfo.GetCharType(), kBaseInfo.GetLevel());
			}
		}
	}
	//handle request list
	LC_FriendRequestInfo reqIF;
	if (pkSocietyAsset->PopRequest(reqIF))
	{
		MG_REQ_Confirm_BeAddFriend xConfirmMsg;
		xConfirmMsg.m_lTargetCharID = reqIF.m_uiCharID;
		xConfirmMsg.m_szCharName = reqIF.m_szCharName;
		xConfirmMsg.m_szMsg = reqIF.m_szMsg;
		xConfirmMsg.m_uiCareer = reqIF.m_uiCareer;
		xConfirmMsg.m_uiWeaponType = reqIF.m_uiWeaponType;
		xConfirmMsg.m_uiLevel = reqIF.m_uiLevel;
		SendMsgToClient(MGPT_REQ_CONFIRM_BEADDFRIEND, &xConfirmMsg);
	}

	GetSocietyAsset()->RegDirtyIDs(relation.char_id());
	if(NULL != pkTargetPlayer)
	{
		pkTargetPlayer->GetSocietyAsset()->RegDirtyIDs(GetInstance());
	}

	return RE_SUCCESS;
}
//------------------------------------------------------------------------------------------
bool LC_ServerPlayer::GetDBSaveMaskFlag(LC_PlayerDataSaveType eSaveType)
{
	return UT_MathBase::GetDigitalOnBinaryPos(m_ulDBSaveMaskFlag, eSaveType);
}
//------------------------------------------------------------------------------------------
void LC_ServerPlayer::SetDBSaveMaskFlag(LC_PlayerDataSaveType eSaveType, bool bSaveFlag)
{
	if (eSaveType == LPDST_CHAR_MAX_COUNT)
	{
		if (bSaveFlag)
		{
			m_ulDBSaveMaskFlag = 0xFFFFFFFF;
		}
		else
		{
			m_ulDBSaveMaskFlag = 0;
		}
		return;
	}
	UT_MathBase::SetDigitalOnBinaryPos(m_ulDBSaveMaskFlag, eSaveType, bSaveFlag);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::NotifySkillEvent(SK_SkillEvent* pkSkillEvent)
{
	if (NULL == pkSkillEvent)
	{
		return;
	}

	LC_PlayerBase::NotifySkillEvent(pkSkillEvent);
	GetPKRecorder()->NotifySkillEvent(pkSkillEvent);
	//通知控制器
	if (NULL != m_pkSMController)
		m_pkSMController->NotifySkillEvent(this, pkSkillEvent);
}
//------------------------------------------------------------------------
bool	LC_ServerPlayer::GetBuddyEquipSlotStarState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetBuddyEquipSlotStarState();
	}

	return m_BuddyEquipData.GetEquipSlotStarState();
}

bool	LC_ServerPlayer::SetBuddyEquipSlotStarState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetBuddyEquipSlotStarState();
	}

	return m_BuddyEquipData.SetEquipSlotStarState();
}

int32_t LC_ServerPlayer::GetYiZhongQinXiEndTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetYiZhongQinXiEndTime();
	}

	return m_nYiZhongQinXiEndTime;
}

void LC_ServerPlayer::UpdateYiZhongQinXiEndTime(int32_t endTime)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateYiZhongQinXiEndTime(endTime);
	}

	m_nYiZhongQinXiEndTime = endTime;
}

bool	LC_ServerPlayer::GetYiZhongQinXiState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetYiZhongQinXiState();
	}

	return m_nYiZhongQinXiState;
}

void	LC_ServerPlayer::SetYiZhongQinXiState(bool state)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetYiZhongQinXiState(state);
	}

	m_nYiZhongQinXiState = state;
}

void LC_ServerPlayer::SyncYiZhongQinXiState()
{
	MG_SyncYiZhongQinXiState msg;
	msg.m_nOpen = GetYiZhongQinXiState();
	SendMsgToClient(MGPT_SYNC_YIZHONGQINXI_STATE, &msg);
}
void LC_ServerPlayer::PackCommanderBaseInfo(CommanderBaseInfo &commanderBaseInfo)
{
	commanderBaseInfo.m_uCharId = GetInstance();
	commanderBaseInfo.m_nCharName = GetOwnerCharName().c_str();
	commanderBaseInfo.m_nControllerLevel = GetControllerLevel();
	commanderBaseInfo.m_nDamageData = GetMaxCombatRecorderData().GetValue();
	commanderBaseInfo.m_nBornType = GetProfilePictureID();
	commanderBaseInfo.m_nCommanderTitleFrameID = GetCurrentCommanderTitleFrameID();
	commanderBaseInfo.m_nCommanderTitleID = GetCommanderTitle();
}


void LC_ServerPlayer::PackSingleSideStruct(SingleSideStruct &singleSideInfo)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return ;

	if(!IsMainController())
		return m_pOwnerPlayer->PackSingleSideStruct(singleSideInfo);

	PackCommanderBaseInfo(singleSideInfo.m_CommanderBaseInfo);
	mem::vector<int> buddyIDs;
	GetActivateBuddyIDs(buddyIDs);
	for(int i=0; i<buddyIDs.size(); ++i)
	{
		int buddyID = buddyIDs[i];
		PS_Buddy singleBuddyInfo;
		PackPS_BuddyByBuddyId(buddyID,singleBuddyInfo);
		singleSideInfo.m_nVecBuddyInfo.push_back(singleBuddyInfo);
	}
}

void LC_ServerPlayer::PackPS_BuddyByBuddyId(int buddyID , PS_Buddy & ps_buddyInfo)
{
	BuddyInstance* pkBuddy =GetBuddyInstanceByID(buddyID);
	if(!pkBuddy)
		return;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM ; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
		if(pResultPlayer->GetBuddyID() != buddyID)
			continue;
		ps_buddyInfo.m_nBuddyIndex = pResultPlayer->GetBuddyAbsoluteIndex();
		break;
	}

	LC_ActorBase::CombatRecord* pkRecord = GetPlayerCombatDataMapByID(buddyID);
	if(NULL != pkRecord)
	{
		ps_buddyInfo.m_nDamageData = pkRecord->m_nDamageData;
		ps_buddyInfo.m_nHurtData = pkRecord->m_nHealData;
		ps_buddyInfo.m_nHealData = pkRecord->m_nHurtData;
	}

	pkBuddy->FillBuddyCSInfo(ps_buddyInfo.m_nBuddyData);
}
void LC_ServerPlayer::PackBaseBattlefieldBuddyDataToVec(mem::vector<int>& buddyIDs,std::vector<BaseBattlefieldBuddyData> &vecResult)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return ;
	if(!IsMainController())
		return m_pOwnerPlayer->PackBaseBattlefieldBuddyDataToVec(buddyIDs,vecResult);
	/*bool bGetDead = false;
	if(buddyIDs.size() == 0)
	{
		GetActivateBuddyIDs(buddyIDs);
		bGetDead = true;
	}*/
	for(int i=0; i< buddyIDs.size(); ++i)
	{
		int buddyID = buddyIDs[i];
		BaseBattlefieldBuddyData _baseBattlefieldBuddyData;
		// 所有buddy 状态全部初始化为死亡
		_baseBattlefieldBuddyData.m_nReliveState = 0;
		PackPS_BuddyByBuddyId(buddyID,_baseBattlefieldBuddyData.m_BuddyInfo);
		/*if(bGetDead)
		{
			LC_ServerPlayer* pResultPlayer = GetActivateBuddyByID(buddyID);
			IF_A_VALID_PLAYER(pResultPlayer)
				_baseBattlefieldBuddyData.m_nReliveState = pResultPlayer->GetDead()?0:1;
		}*/
		vecResult.push_back(_baseBattlefieldBuddyData);
	}
}

void LC_ServerPlayer::GetDamageRankInfo(int32_t mapResID)
{
	if(!IsMainController())
	{
		return;
	}

	MG_RESP_GetDamageRankInfo rltMsg;
	rltMsg.m_nMapResID = mapResID;

	do 
	{
		if(GetMapResID() != mapResID)
		{
			rltMsg.m_nResult = RE_ERROR_PARAM;
			break;
		}

		CDamageRankManager* pkMgr = CDamageRankManager::GetSingletonPtr();
		rltMsg.m_nResult = pkMgr->FillRankIndex(rltMsg.m_nMapResID, GetGuildID(), GetInstance(), rltMsg.m_nSelfGuildRankIndex, rltMsg.m_nSelfGuildTotalDamage, rltMsg.m_nSelfDamageIndex, rltMsg.m_nSelfTotalDamage);
	} while (0);

	SendMsgToClient(MGPT_RESP_DAMAGERANKINFO, &rltMsg);
}

void LC_ServerPlayer::GetGuildDamageRankInfo(int32_t mapResID)
{
	if(!IsMainController())
	{
		return;
	}

	MG_RESP_GetGuildDamageRankInfo rltMsg;
	rltMsg.m_nMapResID = mapResID;
	
	do 
	{
		if(GetMapResID() != mapResID)
		{
			rltMsg.m_nResult = RE_ERROR_PARAM;
			break;
		}

		CDamageRankManager* pkMgr = CDamageRankManager::GetSingletonPtr();
		rltMsg.m_nResult = pkMgr->FillGuildDamageRankInfo(rltMsg.m_nMapResID, this, rltMsg.m_nSelfInfo, rltMsg.m_nPlayerInfo);
	} while (0);

	SendMsgToClient(MGPT_RESP_GETGUILDDAMAGERANKINFO, &rltMsg);
}

void LC_ServerPlayer::UpdateDamageData(int32_t storyID, int32_t updateType, uint64_t param, bool syncClient)
{
	if(!IsMainController())
	{
		return;
	}

	LC_CombatRecorder recorder = GetMaxCombatRecorderData();
	uint64_t data = recorder.GetValue();
	int32_t rankIndex = UpdatePlayerDamageData(storyID, data, updateType);
	DisableCombatRecorder(rankIndex, data, param, syncClient);

	static LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* pkPlace = (LC_ServerMapLogic_Place*)pkWorldManager->GetMapLogic(GetMapLogicID());
	if(NULL!=pkPlace || pkPlace->GetGuildID()!=0)
	{
		UpdateGuildDamageData(storyID, data);
	}

	
	UpdateRankTypeDamage(GetMapResID(), data);
}

int32_t LC_ServerPlayer::UpdatePlayerDamageData(int storyID, uint64_t damageData, int32_t updateType)
{
	int32_t index = SPECIES_RANK_NONE;
	if(damageData == 0)
	{
		return index;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
	{
		return index;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdatePlayerDamageData(storyID, damageData, updateType);
	}

	mem::vector<uint64_t> params;
	params.push_back(storyID);

	uint64_t nScore = 0;
	bool tag = UT_ServerHelper::RedisRank_ReadDamage(UT_REDIS_KEY_DAMAGE_RANK, params, GetInstance(), nScore, index);

	uint64_t newDamageData = UT_ServerHelper::GetNewDamageData(updateType, nScore, damageData);
	if(newDamageData < 0)
	{
		return index;
	}

	SettleInfo info;
	if(!FillSettleInfo(info, damageData))
	{
		return index;
	}

	std::stringstream ss;
	boost::ajson::save_to_buff(info, ss);
	std::string data = ss.str().c_str();

	//每次的伤害数据都要写到redis
	mem::vector<uint64_t> nameKey;
	nameKey.push_back(storyID);
	nameKey.push_back(GetInstance());

	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	mem::vector<uint64_t> key;
	key.push_back(currentTime);
	UT_ServerHelper::RedisWriteString(UT_REDIS_KEY_COMBAT_INFO, nameKey, key, data);

	if(tag || newDamageData>0)
	{
		SettleInfo battleInfo;
		if(!FillSettleInfo(battleInfo, newDamageData))
		{
			return index;
		}

		mem::vector<uint64_t> key;
		key.push_back(GetInstance());

		std::stringstream ss;
		boost::ajson::save_to_buff(info, ss);
		std::string battleInfoData = ss.str().c_str();

		UT_ServerHelper::RedisSetData_DamageString(UT_REDIS_KEY_BATTLE_INFO, params, key, battleInfoData, false, true);

		UT_ServerHelper::RedisRank_WriteDamage(UT_REDIS_KEY_DAMAGE_RANK, params, GetInstance(), newDamageData);

		UT_ServerHelper::RedisRank_ReadDamage(UT_REDIS_KEY_DAMAGE_RANK, params, GetInstance(), nScore, index);
	}

	ClearMonstarCombatDataMap();
	ClearPlayerCombatDataMap();

	SetCombatFlag(false);

	UT_ServerHelper::GetDetailDamageData(this, storyID, currentTime, GetInstance());
	return index;	
}

void LC_ServerPlayer::UpdateGuildDamageData(int storyID, uint64_t damageData)
{
	if(0 == damageData)
	{
		return;
	}

	uint64_t guildID = GetGuildID();
	if(0 == guildID)
	{
		return;
	}

	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	LC_ServerGuildInfo* pkGuild = pkGuildManager->GetGuildInfoByID(guildID);
	if (NULL == pkGuild)
	{
		return;
	}

	mem::vector<uint64_t> params;
	params.push_back(storyID);

	uint64_t nScore = 0;
	int32_t index = 0;
	UT_ServerHelper::RedisRank_ReadDamage(UT_REDIS_KEY_GUILD_DAMAGE_RANK, params, guildID, nScore, index);
	uint64_t newDamageData = nScore + damageData;
	UT_ServerHelper::RedisRank_WriteDamage(UT_REDIS_KEY_GUILD_DAMAGE_RANK, params, guildID, newDamageData);

	GuildInfo guildInfo(guildID, pkGuild->GetGuildName().c_str(), newDamageData);
	
	std::stringstream ss;
	boost::ajson::save_to_buff(guildInfo, ss);
	std::string data = ss.str().c_str();

	mem::vector<uint64_t> key;
	key.push_back(guildID);

	UT_ServerHelper::RedisSetData_DamageString(UT_REDIS_KEY_GUILD_DAMAGE_INFO, params, key, data, false, true);
}

bool LC_ServerPlayer::FillSettleInfo(SettleInfo& info, uint64_t damageData)
{
	if(!IsMainController())
	{
		return false;
	}

	mem::vector<int> buddyIDs;
	GetActivateBuddyIDs(buddyIDs);

	info.charName = GetOwnerCharName().c_str();
	info.controllerLevel = GetControllerLevel();
	info.damageData = damageData;
	info.bornType = GetProfilePictureID();
	info.commanderTitleFrameID = GetCurrentCommanderTitleFrameID();
	info.commanderTitle = GetCommanderTitle();
	for(int i=0; i<buddyIDs.size(); ++i)
	{
		int buddyID = buddyIDs[i];
		mem::map<int32_t, BuddyInstance*>::iterator kIt = m_ppUsableBuddyInstance.find(buddyID);
		if(kIt == m_ppUsableBuddyInstance.end())
		{
			continue;
		}

		BuddyInstance* pkBuddy = kIt->second;
		if(NULL == pkBuddy)
		{
			continue;
		}

		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByID(buddyID);
		IF_A_NA_PLAYER(pResultPlayer)
		{
			continue;
		}

		int buddyIndex = pResultPlayer->GetBuddyAbsoluteIndex();
		info.buddyIndexs.push_back(buddyIndex);

		LC_ActorBase::CombatRecord* pkRecord = GetPlayerCombatDataMapByID(buddyID);
		if(NULL != pkRecord)
		{
			info.buddyDamageDatas.push_back(pkRecord->m_nDamageData);
			info.buddyHealDatas.push_back(pkRecord->m_nHealData);
			info.buddyHurtDatas.push_back(pkRecord->m_nHurtData);
		}

		bool flag = pkBuddy->GetTotalActivatedSkillCount()==4 ? true:false;

		std::map<int32_t, PS_RuneItemInfo_BuddyCS> buddyRuneInfo;
		pkBuddy->GetBuddyRuneInfo(buddyRuneInfo);

		mem::map<int32_t, int32_t> buddyRuneItemInfo;
		mem::map<int32_t, int32_t> buddyRuneStarLevelInfo;			
		for(std::map<int32_t, PS_RuneItemInfo_BuddyCS>::iterator it=buddyRuneInfo.begin(); it!=buddyRuneInfo.end(); ++it)
		{
			buddyRuneItemInfo.insert(std::make_pair(it->first, it->second.m_nRuneItemID));
			buddyRuneStarLevelInfo.insert(std::make_pair(it->first, it->second.m_nRuneStarLevel));
		}

		std::map<int32_t,PS_EquipItemInfo_BuddyCS> equipData;
		pkBuddy->GetEquipInfo(equipData);

		mem::map<int32_t, int32_t> equipSlotStarLevel;
		mem::map<int32_t, int32_t> equipItemID;
		for(std::map<int32_t,PS_EquipItemInfo_BuddyCS>::iterator it=equipData.begin(); it!=equipData.end(); ++it)
		{
			equipItemID.insert(std::make_pair(it->first, it->second.m_nEquipItemID));
			equipSlotStarLevel.insert(std::make_pair(it->first, it->second.m_nEquipSlotStarLevel));
		}

		info.buddyIDs.push_back(pkBuddy->GetTemplateID());
		info.buddyLevels.push_back(pkBuddy->GetLevel());
		info.buddyStarLevels.push_back(pkBuddy->GetStarLevel());
		info.activeAllSkills.push_back(flag);
		info.equipSlotLevelCount.push_back(pkBuddy->GetEquipSlotTotalLevel());
		info.buddyRuneStarLevelInfo.insert(std::make_pair(pkBuddy->GetTemplateID(), buddyRuneStarLevelInfo));
		info.buddyRuneItemInfo.insert(std::make_pair(pkBuddy->GetTemplateID(), buddyRuneItemInfo));
		info.equipSlotStarLevel.insert(std::make_pair(pkBuddy->GetTemplateID(), equipSlotStarLevel));
		info.equipItemID.insert(std::make_pair(pkBuddy->GetTemplateID(), equipItemID));
	}

	const mem::map<int32_t, LC_ActorBase::CombatRecord>* pkCombatMap = GetMonstarCombatDataMap();
	if(NULL != pkCombatMap)
	{
		for(mem::map<int32_t, LC_ActorBase::CombatRecord>::const_iterator it=pkCombatMap->begin(); it!=pkCombatMap->end(); ++it)
		{
			info.bossCharTypeID.push_back(it->second.m_nID);
			info.bossDamageDatas.push_back(it->second.m_nDamageData);
			info.bossHurtDatas.push_back(it->second.m_nHurtData);
			info.bossHealDatas.push_back(it->second.m_nHealData);
		}
	}

	return true;
}

void LC_ServerPlayer::SetCombatFlag(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetCombatFlag(tag);
	}

	m_bCombatFlag = tag;
}

bool LC_ServerPlayer::GetCombatFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetCombatFlag();
	}

	return m_bCombatFlag;
}

const mem::map<int32_t, LC_ActorBase::CombatRecord>* LC_ServerPlayer::GetMonstarCombatDataMap()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return NULL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetMonstarCombatDataMap();
	}

	return &m_nMonstarCombatDataMap;
}

LC_ActorBase::CombatRecord* LC_ServerPlayer::GetMonstarCombatDataMapByID(int id)
{
	bool tag = GetCombatFlag();
	if(!tag)
	{
		return NULL;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return NULL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetMonstarCombatDataMapByID(id);
	}

	mem::map<int32_t, LC_ActorBase::CombatRecord>::iterator findIt = m_nMonstarCombatDataMap.find(id);
	if(findIt != m_nMonstarCombatDataMap.end())
	{
		return &(findIt->second);
	}

	LC_ActorBase::CombatRecord data;
	data.m_nID = 0;
	data.m_nDamageData = 0;
	data.m_nHealData = 0;
	data.m_nHurtData = 0;
	m_nMonstarCombatDataMap.insert(std::make_pair(id, data));
	findIt = m_nMonstarCombatDataMap.find(id);
	return &(findIt->second);
}

LC_ActorBase::CombatRecord* LC_ServerPlayer::GetPlayerCombatDataMapByID(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return NULL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetPlayerCombatDataMapByID(id);
	}

	mem::map<int32_t, LC_ActorBase::CombatRecord>::iterator findIt = m_nPlayerCombatDataMap.find(id);
	if(findIt != m_nPlayerCombatDataMap.end())
	{
		return &(findIt->second);
	}

	LC_ActorBase::CombatRecord data;
	data.m_nID = 0;
	data.m_nDamageData = 0;
	data.m_nHealData = 0;
	data.m_nHurtData = 0;
	m_nPlayerCombatDataMap.insert(std::make_pair(id, data));
	findIt = m_nPlayerCombatDataMap.find(id);
	return &(findIt->second);
}

void LC_ServerPlayer::ClearMonstarCombatDataMap()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ClearMonstarCombatDataMap();
	}

	m_nMonstarCombatDataMap.clear();
}

void LC_ServerPlayer::ClearPlayerCombatDataMap()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ClearPlayerCombatDataMap();
	}

	m_nPlayerCombatDataMap.clear();
}

uint64_t LC_ServerPlayer::GetAllRuneItemCombatScore()
{
	uint64_t score = 0;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return score;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAllRuneItemCombatScore();
	}

	LC_PackAsset* pkAsset = GetPackAsset();
	if(NULL == pkAsset)
	{
		return score;
	}

	//buddy宝具背包
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			score += pkBuddy->GetBuddyRuneScore();
		}
	}

	//基础背包
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				score += LC_Helper::GetRuneEquipScore(pkItemEntry);
			}
		}
	}

	//仓库里的装备
	int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
	for (int32_t i = 0;i < iWarehousePackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				score += LC_Helper::GetRuneEquipScore(pkItemEntry);
			}
		}
	}

	return score;
}

void LC_ServerPlayer::OnAchieveEvent_BuddyInstanceCreate( BuddyInstance* pInput )
{
	if (pInput == NULL)
		return;

	//buddy激活时，尝试开启宝具槽位穿戴状态
	pInput->CheckFlushRuneSlotDressState();

	//通知成就系统
	AchievementEvent kEvent1;
	kEvent1.SetConditionInfo(pInput->GetLevel(), pInput->GetQuality());
	kEvent1.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_BUDDY_LEVEL, kEvent1);

	AchievementEvent kEvent2;
	kEvent2.SetConditionInfo(pInput->GetStarLevel(), pInput->GetQuality());
	kEvent2.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_BUDDY_STARLEVEL, kEvent2);

	AchievementEvent kEvent3;
	kEvent3.SetConditionInfo(pInput->GetTemplateID());
	kEvent3.SetNum(pInput->GetLevel());
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_LEVEL, kEvent3);

	AchievementEvent kEvent4;
	kEvent4.SetConditionInfo(pInput->GetTemplateID());
	kEvent4.SetNum(pInput->GetStarLevel());
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_STARLEVEL, kEvent4);

	//派发该buddy的角色传记任务
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(m_kOpenAbilityAsset.IsAbilityEnabled(LC_ABT_TASK, STT_BIOGRAPHY_TASK))
	{
		pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_BIOGRAPHY_TASK), false, BUDDY_ASSIGN, pInput->GetTemplateID());
	}
}

void LC_ServerPlayer::PostInitGameData( int nCharDataVersion )
{
	if (nCharDataVersion >= 1)
		return;
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.begin();
	for ( ; it != m_ppUsableBuddyInstance.end(); ++it )
	{
		BuddyInstance* pData = it->second;
		if (pData == NULL)
			continue;

		OnAchieveEvent_BuddyInstanceCreate(pData);
	}
}

//------------------------------------------------------------------------
void LC_ServerPlayer::PunchMove(SkillMoveActorPositionType Type, const Utility::UT_Vec3Int& kTargetPoint , float fPunchTime)
{
	LC_PlayerBase::PunchMove(Type, kTargetPoint, fPunchTime);
	const UT_Vec3Int& kCurrentPoint = this->GetCurrentLocation();
	SetTargetLocation(kTargetPoint);
	SetMoveLineTargetLocation(kTargetPoint);
	m_dataChangeFlag.GetBroadCastFlag().SetLocation();
	SetAIControlNotify(true);
	GetMovePath().Clear();

	////广播消息
	MG_MoveActorPosition	nMsg;
	nMsg.m_lActorID				= m_iID;
	nMsg.m_lMoveType			= Type;
	nMsg.m_lCurrentLocationX	= kCurrentPoint.x;
	nMsg.m_lCurrentLocationY	= kCurrentPoint.y;
	nMsg.m_lTargetLocationX		= kTargetPoint.x;
	nMsg.m_lTargetLocationY		= kTargetPoint.y;
	nMsg.m_fMoveTime			= fPunchTime;
	nMsg.m_fServerTime			= GET_PROCESS_TIME;
	if (m_pkMap)
	{
		((LC_ServerMap*)m_pkMap)->BroadCastToArea(GetSectorIndex(), MGPT_PUNCH_MOVE_PLAYER, &nMsg);
	}
	if (Type == SMAPT_PASSIVEMOVE)
	{
		this->FixCurrentState(ST_PLAYER_PASSIVE_MOVE, GET_PROCESS_TIME, 0);
	}
	else if (Type == SMAPT_PUNCHBACK)
	{
		this->FixCurrentState(ST_PLAYER_PUNCH_BACK, GET_PROCESS_TIME, 0);
	}
	else
	{
		this->FixCurrentState(ST_PLAYER_PASSIVE_MOVE, GET_PROCESS_TIME, 0);
	}
}

void LC_ServerPlayer::UpdateCashOP(void)
{
	LC_CommonShopAsset& kCommonShopAsset = GetCommonShopAsset();
	LC_CashOPCluster* pkCashOPCluster = kCommonShopAsset.GetCashOPCluster(CT_UNBIND_YUANBAO);
	if (NULL == pkCashOPCluster || !pkCashOPCluster->NeedSync())
	{
		return;
	}
	MG_PB<char_data_define::char_cash_op_info> reqMsg;
	char_data_define::char_cash_op_info& kchar = reqMsg.m_value;
	kchar.set_char_id(GetInstance());
	kCommonShopAsset.SetDataToPB(kchar);
	SendMsgToLogin(MGPT_GL_SYNC_CASH_OP_REQ, &reqMsg, GetUserID(), GetInstance());
}

void LC_ServerPlayer::InitGameData_AllBuddy()
{
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.begin();

	for ( ; it != m_ppUsableBuddyInstance.end(); ++it )
	{
		BuddyInstance* pBuddy = it->second;
		if (pBuddy)
			pBuddy->InitGameData();
	}

	//初始化圣痕
	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		LC_ServerPlayer* pkPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pkPlayer)
			continue;
		for(int j=0; j<m_nSkillBookSlotDataInfo[i].size(); ++j)
		{
			bool slotState = m_nSkillBookSlotDataInfo[i][j].m_nSlotState;
			int slotID = m_nSkillBookSlotDataInfo[i][j].m_nSlotID;
			int skillBookID = m_nSkillBookSlotDataInfo[i][j].m_nSkillBookID;
			if(slotState && skillBookID!=0)
			{
				pkPlayer->InitSkillBookProperty(i, slotID, skillBookID);
			}
		}
	}
}

void LC_ServerPlayer::InitGameData(bool clonePlayer)
{
	if (!IsMainController())
		return;

	if(!clonePlayer)
	{
		RefreshAchievementSystem();
	}

	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	uint32_t registerTime = GetRegTime();
	if(currentTime < registerTime)
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "registerTime error! c_cid:%d, c_citizenship:%d, c_uid:%d, registerTime:%d, currentTime:%d", 
			instance.detail(), instance.catagory(), GetUserID(), registerTime, currentTime);
	}

	//离线玩家资源找回
	UpdateResourceRetrieveRecord();

	time_t ct = (time_t)registerTime;
	tm ctm = *localtime(&ct);
	ctm.tm_hour = 23;
	ctm.tm_min = 59;
	ctm.tm_sec = 59;
	int32_t time = (int32_t)mktime(&ctm);

	//计算转盘活动的结束时间
	GetRotaryTableAsset().InitRotaryTableData(time);

	//第一次登陆游戏
	if(m_nCharDataVersion == 0)
	{
		//远征点加满
		GetYuanZhengPointAsset().AddTimes(this, GetGlobalSetting.YuanZhengPointMaxCount);
		GetDropTimesAsset().AddTimes(this, GetGlobalSetting.nKillNpcDropMaxTimes);
		GetStarShipTimesAsset().AddTimes(this, GetGlobalSetting.StarShipTimesMaxCount);

		//计算七日试炼的结束时间
		m_nSevenDayEndTime1 = registerTime+GetGlobalSetting.SevenDayActivityVaildTime*ONE_MINUTE_SECONDS;
		m_nSevenDayEndTime2 = registerTime+GetGlobalSetting.SevenDayActivityFinishTime*ONE_MINUTE_SECONDS;
	}

	GetOpenAbilityAsset().Init();

	//坐骑系统会受装备影响 所以先应用
	GetSubordinateAsset().Init();
	
	//进阶线装备属性
	EquipAllSubItem(true);
	//buddy属性
	EquipAllBuddyItem(true);

	InitGameData_AllBuddy();

	//先清理然后再加载状态，避免因为时序问题导致状态加载两遍
	//激活保存的技能状态
	SetBuffLoginFlag(true);
	m_kControllerSkillStateMap->StartSavedSkillState();
	m_kSkillStateMap->StartSavedSkillState();
	SetBuffLoginFlag(false);

	//激活被动技能
	// weixin TODO: Check init buddy data
	ActivePassiveSkill();

	GetVIPAsset().Init();

	GetFashionBagAsset().Apply();

	GetMeltAsset().Apply();

	if (!IsInstance())
	{
		return;
	}

	if (GetGameServerApp()->GetAllowDebug())
	{
		m_uiGMPriority = INIT_GM_PRIORITY;
	}

	SERVER_GET_STORYLOGIC_MANAGER->CheckUpdateTask(this);


	LC_TitleAsset* pkTitleAsset = GetTitleAsset();
	{
		// 称号战力
		if (pkTitleAsset->GetCurrentTitleType() == TNT_NONE_TITLE)
		{
			SetCharTitle("");
		}
		else if (pkTitleAsset->GetCurrentTitleType() == TNT_SYSTEM_TITLE || pkTitleAsset->GetCurrentTitleType() == TNT_DIY_TITLE)
		{
			SetCharTitle(pkTitleAsset->GetTitle(pkTitleAsset->GetCurrentTitleType(), pkTitleAsset->GetCurrentTitle()));
		}

		CheckInbornTitle();
	}

	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	LC_ServerTaskMap* pkTaskMap = (LC_ServerTaskMap*)GetTaskMap();
	if (pkTaskMap)
	{
		pkTaskMap->InitBillboardTaskList();
		HandleProcessTaskForEnter();
	}

	uint32_t curtimestamp  = GET_CURRENT_TIMESTAMP_IN_SECONDS();

	GetTaskMap()->SetUp();

	GetAssistAsset().Init();


	//task
	pkTaskManager->CheckReset(this, curtimestamp);
	//promote
	GetPromoterAsset().Reset(curtimestamp);
	GetTreasureChestsAsset().CheckReset(curtimestamp);

	{
		//顺序不能换
		//1 重置统计数据
		GetCommonStatAsset().CheckReset(this, curtimestamp);
		//2 计算第一天登录奖励可领取的时间
		LC_CommonStatBasic* kCmnStatAsset = GetCommonStatAsset().GetCommonStatBasic(LC_ST_TP_FORERVER);
		if(NULL != kCmnStatAsset)
		{
			uint32_t uiOnlineTime = kCmnStatAsset->GetOnlineTime(currentTime);
			uint32_t limitTime = GetGlobalSetting.FirstDayLoginRewardTime*ONE_MINUTE_SECONDS;
			if(uiOnlineTime < limitTime)
			{
				m_nFirstDayLoginRewardTime = limitTime-uiOnlineTime;
			}
		}
	}

	GetVIPAsset().CheckReset(curtimestamp);
	GetCommonShopAsset().CheckReset(curtimestamp);
	SERVER_GET_GAMESTORY_MANAGER->CheckReset(this);


	ResetBestGuild(true);

	GetSecreteTreasureAsset().CheckReset(curtimestamp);
	GetACTScheduleAsset().CheckReset(curtimestamp);
	static Activity::ACT_ScheduleDataManager* pkScheduelDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	pkScheduelDataMgr->OnLogin(this, curtimestamp);
	pkScheduelDataMgr->CheckData(this);

	GetArenaAsset()->CheckDaily(curtimestamp);

	GetCommonStatAsset().CheckCompensate(this, curtimestamp);
	GetCommonStatAsset().OnLogin(this, curtimestamp);
	if (1 == GetLoginCount())
	{
		LC_ThirdPlatformReport::GetSingletonPtr()->OnCreateChar(this);
		GetBuddySchemeMgr().SetBuddyActivateScheme(this, INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Offensive, m_ppActivateBuddyTemplateId);
		GetBuddySchemeMgr().SetBuddyActivateScheme(this, INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Defence, m_ppActivateBuddyTemplateId);
	}

	LC_ThirdPlatformReport::GetSingletonPtr()->OnCharLogin(this);

	DailyRechargeReturnSettle();

	//日清
	ClearDailyClean(curtimestamp);

	//Insert Event, The TranscriptionMgr should handle
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (pkGameEvent != NULL)
		{
			pkGameEvent->SetEventType(GLET_GAMEPLAYER_ENTER_GAME);
			pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1, GetID());
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	InitActivateStarVein();

	SK_SkillExecute* skill = m_kSkillTrigger.GetNormalAttackSkill();
	if (skill)
	{
		m_SurroundRanger = skill->GetProperty_MaxExecuteDistance() * 4 / 5;
	}
	else
	{
		m_SurroundRanger = 0;
	}

	if (GetGameServerApp()->GetAllowDebug())
	{
		m_uiGMPriority = 0;
	}

	int level = GetCommanderLevel();
	if(level >= GetGlobalSetting.OfflineEXPStartLevel)
	{
		//计算离线时间
		calculateOfflineTimeExp();
	}

	LC_ServerPlayerGroupManager* pkPlayerGroupManager = SERVER_GET_PLAYER_GROUP_MANAGER();
	LC_ServerPlayerGroup* pGroup = pkPlayerGroupManager->GetPlayerGroup(m_Instance);
	if (pGroup != NULL)
	{
		pGroup->UpdatePlayerState(m_Instance, PLAYER_ON_LINE);
	}

	//init chat cd
	m_kChatChannelController.Init();

	ServerMysticalShop::GetSingletonPtr()->RefreshItems(this);

	m_kResourceAlert.Init();

	{
		SC_ServerDebugInterface debug;
		debug.HandleAsset(GetInstanceUniqueID(), false);
	}

	if(IsMainController())
	{
		SyncTaskRankInfo();//同步任务排名

		//宝具系统
		EquipAllRuneItem(true);

		//最强公会系统
		FlushBestGuildCounter();

		CheckTaskChapterReward();

		//初始化头衔系统
		ApplyCommanderTitleSystem();

		ResetGoalProcess();

		UpdateSubBInfo();

		{
			//物资配送任务
			LC_GameStory_Manager *pkGSMgr = SERVER_GET_GAMESTORY_MANAGER;
			LC_Server_GameStory_Base* pkStory = pkGSMgr->GetGameStoryBasePtrByStoryID(GameStoryIDType_BJEscort);
			if (NULL!= pkStory && pkStory->IsActive())
			{
				pkStory->AssignEscortTask(this);
			}
		}

		{
			//上线后，发未领取的遗迹突袭阶段奖励
			int32_t YiJiTuXiEndTime = GetYiJiTuXiEndTime();
			if(0!=YiJiTuXiEndTime && curtimestamp >= YiJiTuXiEndTime)
			{
				SendYiJiTuXiReward();
			}

			//上线后，发未领取的遗迹寻宝阶段奖励
			int32_t YiJiXunBaoEndTime = GetYiJiXunBaoEndTime();
			if(0!=YiJiXunBaoEndTime && curtimestamp >= YiJiXunBaoEndTime)
			{
				SendYiJiXunBaoReward();
			}

			//上线后，发未领取的玩具岛阶段奖励
			int32_t PetIslandsEndTime = GetPetIslandsEndTime();
			if(0!=PetIslandsEndTime && curtimestamp >= PetIslandsEndTime)
			{
				SendPetIslandsReward();
			}
		}

		{
			//达标榜的玩家数据
			mem::vector<uint64_t> key;
			key.push_back(GetInstance());
			std::string ssSub;
			bool tag = UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ACT_SUB_PLAYER_INFO, key, ssSub);
			if(tag)
			{
				PlayerACTSubInfo subInfo;
				std::string errorMsg;
				if(boost::ajson::load_from_buff(subInfo, ssSub.c_str(), errorMsg))
				{
					SetActSubPlayerInfoCache(subInfo);
					SyncPlayerACTSubInfo(subInfo);
				}
			}

			std::string ssSubPlus;
			tag = UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ACT_SUB_PLAYER_INFO_PLUS, key, ssSubPlus);
			if(tag)
			{
				PlayerACTSubInfo subPlusInfo;
				std::string errorMsg;
				if(boost::ajson::load_from_buff(subPlusInfo, ssSubPlus.c_str(), errorMsg))
				{
					SetActSubPlusPlayerInfoCache(subPlusInfo);
					SyncPlayerACTSubInfo(subPlusInfo);
				}
			}
		}		

		//传记任务相关
		//{}内的代码，顺序不能变
		{			
			//每次上线，从表中更新每个传记的最后一个章节任务
			FillLastBiographyPartID();

			//老玩家已经完成传记任务，但是没派发下一章节的任务
			//为了修老玩家，加的代码
			if(m_nCheckBiography)
			{
				UpdateBiographyOldData();
				CheckCanAssignNextBiographyTask(true);
				m_nCheckBiography = false;				
			}

			//每次上线，重新检测已完成的传记
			UpdateFinishBiography();
			SyncBiography();
		}

		{
			bool tag = UT_ServerHelper::CheckActivityVaild(GetGlobalSetting.RewardTaskActivityScheduleID_1);
			if(tag)
			{
				int32_t endTime = UT_ServerHelper::GetActivityEndTime(GetGlobalSetting.RewardTaskActivityScheduleID_1);
				AssignRewardTask(AssignRewardTaskType_Activity, endTime);
			}
		}

		if(m_fixMainTaskBug)
		{
			//修复部分账号主线任务丢失的bug
			//1 已经接取的主线任务中，只留下任务id最大的主线任务
			int mainTaskID = RemoveErrorProcessingMainTask();

			//2 已通关的相位副本是否有任务丢失
			LC_RaidAssert*	raidAsset = GetRaidAsset();
			{
				//完成的主线任务中的最后一个相位任务
				int finishMirrorTaskID = 0;
				const mem::map<int, int>& record = UT_ServerHelper::GetMapIDAndMirrorTaskIDRecords();
				for(mem::map<int, int>::const_iterator it=record.begin(); it!=record.end(); ++it)
				{
					int mapID = it->first;
					int taskID = it->second;
					const RaidInfo* raidInfo = raidAsset->FindRaid(mapID);
					if(NULL != raidInfo)
					{
						bool tag = IsInFinishedTaskMap(taskID);
						if(!tag)
						{
							finishMirrorTaskID = taskID;
							break;
						}
					}
				}

				bool tag = false;
				int FinalTaskID = 0;
				if(finishMirrorTaskID>mainTaskID)
				{
					RemoveProcessingTaskByTaskID(mainTaskID);
					FinalTaskID = finishMirrorTaskID;
					tag = true;
				}
				else
				{
					FinalTaskID = mainTaskID;
				}

				//将第一个任务至FinalTaskID的前一个任务设置为完成
				int taskSaveIndex = 0;
				CF_TaskList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TaskList>(FinalTaskID);
				if(NULL != pkData)
				{
					taskSaveIndex = pkData->_iIndex;

					taskSaveIndex = tag ? taskSaveIndex : taskSaveIndex-1;
					for(int i=0; i<=taskSaveIndex; ++i)
					{
						FinishTask_bug(i);
					}
				}
			}
			m_fixMainTaskBug = false;
		}
	}

	UT_ServerHelper::FlushOfflineAnswerResult(this);

	PostInitGameData(m_nCharDataVersion);
	//m_bInitGame = true;
	PostInitAllBuddyInstance();
	SyncBuddyData_Usable();

	bool bRelive = false;
	if(GetBuddySchemeMgr().CheckSchemeReady(INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Offensive))
	{
		uint32_t mapID = 0;
		uint32_t groupID = 0;
		GetBuddySchemeMgr().GetCurrentSchemeInfo(mapID, groupID);
		if(INIT_MAP_ID!=mapID && INIT_SCHEME_GROUPID!=groupID)
		{
			bRelive = true;
		}
	}
	SwitchBuddyScheme(INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Offensive, bRelive, true);

	GenSkillRandList();
	// 提取所有离线期间订单
	FetchAllPay();
	// 加载完玩家所有的数据 统一计算属性
	//1.刷新所有指挥官 系统的属性
	GetCommanderAttrMgr().RefreshCommanderAllAttributeMap(this, true);
	// 2.刷新所有英雄系统的属性
	RefreshAllHeroAllSysAttrMap();
	// 3 刷新灵魂链上所有英雄提供出去的灵魂链属性
	RefreshChainAllBuddyToGiveCoreAttr();
	// 4.刷新所有灵魂连 上英雄应该获得的灵魂链属性
	RefreshChainBuddyCoreAttr(true);
	RefreshAllHeroAllNewFinalAttrMap(true);
	
	if(bRelive)
	{
		ReliveAllBuddyBeforeEnterMap(true, true);
	}

	int nAliveCount = 0;
	// 数据初始化完成后，补发 玩家状态消息
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM ; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
			//AddAliveBuddyCount();
		nAliveCount++;
		pResultPlayer->UpdateHpAndSetDeadState();
		pResultPlayer->SyncEnterFov();
	}
	SetAliveBuddyCount(nAliveCount);

	// 玩家HP MP 放在最后同步
	if ( m_nCharDataVersion < 1 )
	{
		attr_value_type nMaxHP = GetFinalAttributeMap()->GetAttribute(ATT_MAX_HP);
		SetHP(nMaxHP);
	}
	SyncOwnerMP();	
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
		if(pResultPlayer->GetHP() <= 0)
			pResultPlayer->SetDead(true);
	}
	SetAllInitGame(true);
	if(IsMainController())
	{
		SetAllPlayerBaseLevel(GetCommanderLevel());
	}
	NotifyRankOpenTime();
	NotifyAtvChargeRedPoint2Client();

	static CEndActivityManager* pkMgr = CEndActivityManager::GetSingletonPtr();
	pkMgr->CheckEndActivity(this);
	LoginCheckACTEnd();
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::GetFriendDataFromDB()
{
	if (!IsInstance())
	{
		return;
	}
	//向FriendServer请求好友相关信息, 放在这里，否则会有时序问题
	SendMsgToSociety(MGPT_GF_REQ_GET_FRIEND_LIST, NULL, GetUserID(), GetInstance());
	SendMsgToSociety(MGPT_GF_REQ_GET_ENEMY_LIST, NULL, GetUserID(), GetInstance());
	SendMsgToSociety(MGPT_GF_REQ_GET_BLACKLIST, NULL, GetUserID(), GetInstance());
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::GetGuildDataFromDB(uint64_t guildId, bool newAdd)
{
	if(IsRobot())
	{
		return;
	}

	//向GuildServer请求公会相关信息
	const unique_id_impl& playerInstanceID = GetInstance();

	MG_SS_QUERY_GUILD reqGuild;	
	reqGuild.m_CharID = playerInstanceID;
	reqGuild.m_GuildId = guildId;
	reqGuild.m_bNewAdd = newAdd;

	char_data_define::guild_user_info userinfo;
	LC_ServerGuildManager::GetSingletonPtr()->FillPlayInfo(this, userinfo);
	userinfo.SerializeToString(&reqGuild.m_userInfo);

	SendMsgToSociety(MGPT_GGU_REQ_GUILD_ASSET, &reqGuild, GetUserID(), GetInstance());

	GfxWriteLog(LOG_TAG_INFO, LOG_SWITCH_INFO, "GetGuildDataFromDB guildId:[%d] c_id:[%d] c_citizenship:[%d] c_uid:[%d]\n", guildId, playerInstanceID.detail(), playerInstanceID.catagory(), GetUserID());
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	m_updateGuildStamp = currentTime;
}
//----------------------------------------------------------------------------
bool LC_ServerPlayer::IsInGame()
{
	return SERVER_STATE_INWORLD == m_serverViewState;
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::LeaveGame( bool bException ,ResultType nReason)
{
	PreLeaveMap(GetMapResID(), 0);
	SetNormalQuit(true);

	if ( !bException )
	{
		if ( !bException && IsMainController())
		{
			SetLastOfflineTime(GET_CURRENT_TIMESTAMP_IN_SECONDS());
			StopTrade();
			HandleProcessTaskForQuit();
			UpdateToDBServer(true,nReason);
		}
		if(IsMainController())
		{
			LC_ServerPlayerManager* pkSvrPlayerManager = SERVER_GET_PLAYER_MANAGER();
			pkSvrPlayerManager->PrePlayerOffline(this);
		}
		// 处理门派
		static LC_ServerGuildManager* pkPlayerGuildManager = LC_ServerGuildManager::GetSingletonPtr();
		pkPlayerGuildManager->CharLeave(this);

		static LC_ServerPlayerGroupManager* pkPlayerGroupManager = (LC_ServerPlayerGroupManager*)SERVER_GET_PLAYER_GROUP_MANAGER();
		pkPlayerGroupManager->UpdatePlayerState(GetInstance(), PLAYER_OFF_LINE);

		static LC_Arena_Manager* pkArenaMgr = SERVER_GET_ARENA_MANAGER();
		pkArenaMgr->CharLeave(this);

		static LC_GuildLadderManager* pkGuildLadderMgr = LC_GuildLadderManager::GetSingletonPtr();
		pkGuildLadderMgr->CharLeave(this);
	}

	int buddyID = GetBuddyID();
	m_kSkillStateMap->ClearStatesOnLeaveGame();
	LC_ThirdPlatformReport::GetSingletonPtr()->OnCharTotalOnlineTime(this);
	GfxWriteFmtLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "PlayerLeaveGame", GetID(), GetUserID(), GetInstance(), bException);
}
//----------------------------------------------------------------------------
void  LC_ServerPlayer::StopTrade()
{
	if (!IsInstance())
	{
		return;
	}
	const unique_id_impl& lTradeTargetChar = m_kTradeManager.GetTradeTargetID();
	LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	LC_ServerPlayer* pkNetPlayer = (LC_ServerPlayer*)pkPlayerManager->FindPlayer(lTradeTargetChar);
	if (pkNetPlayer)
	{
		LC_TradeManager* pkNetTradeManager = pkNetPlayer->GetTradeManager();
		if (pkNetTradeManager && pkNetTradeManager->GetTradeTargetID() == GetInstance())
		{
			pkNetPlayer->InterruptTradeAndClearTradeData();

			MG_RLT_InterruptTrade rltMsg;
			rltMsg.m_lTradeTargetCharID	= lTradeTargetChar;
			rltMsg.m_iResult			= RE_ITEM_TRADE_NOT_ONLIE;
			pkNetPlayer->SendMsgToClient(MGPT_RLT_ITEM_TRADE_INTERRUPT, &rltMsg);
		}
	}
	InterruptTradeAndClearTradeData();
}
//------------------------------------------------------------------------
int LC_ServerPlayer::GetPackageSize()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return LC_PlayerBase::GetPackageSize();

	LC_PackAsset* pkPackAsset = pkOwnerPlayer->GetPackAsset();
	if(NULL != pkPackAsset)
	{
		LC_BasicPack& pack = pkPackAsset->GetBasicPack();
		return pack.m_iSize;
	}

	return 0;
}
LC_PackAsset* LC_ServerPlayer::GetPackAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPackAsset();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetPackAsset();
	}

	return LC_PlayerBase::GetPackAsset();
}
//------------------------------------------------------------------------
LC_GameStoryAsset& LC_ServerPlayer::GetGameStoryAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetGameStoryAsset();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetGameStoryAsset();
	}

	return LC_PlayerBase::GetGameStoryAsset();
}

LC_TaskMap* LC_ServerPlayer::GetTaskMap()
{
	if (m_pTaskMap_Cache)
		return m_pTaskMap_Cache;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetTaskMap();

	if(!IsMainController())
	{
		m_pTaskMap_Cache = m_pOwnerPlayer->GetTaskMap();
		return m_pTaskMap_Cache;
	}

	m_pTaskMap_Cache = LC_PlayerBase::GetTaskMap();
	return m_pTaskMap_Cache;
}

void LC_ServerPlayer::ResetEveryDayTask()
{
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	const mem::vector<int32_t>& everyDayTasks = pkTaskManager->GetEveryDayTaskIDs();
	for(int i=0; i<everyDayTasks.size(); ++i)
	{
		int taskID = everyDayTasks[i];
		if(IsInFinishedTaskMap(taskID))
		{
			RemoveFinishTaskByTaskID(taskID);
		}
	}
}

bool LC_ServerPlayer::CanFinish(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	if (NULL==pkOwnerPlayer || NULL==pkTaskManager)
	{
		return false;
	}

	LC_Task* pkTask = pkTaskManager->GetTask(taskID);
	if (pkTask == NULL)
	{
		return false;
	}

	if (RE_TASK_FINISH_SUCCESS != pkTask->CanFinish(pkOwnerPlayer, GET_PROCESS_TIME))
	{
		return false;
	}

	return true;
}

bool LC_ServerPlayer::IsInProcessingTaskMap(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->IsInProcessingTaskMap(taskID);
}

bool LC_ServerPlayer::IsInAssignTaskMap(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->IsInAssignTaskMap(taskID);
}

bool LC_ServerPlayer::IsInFinishedTaskMap(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->IsInFinishedTaskMap(taskID);
}

bool LC_ServerPlayer::IsInFinishAchievementMap(int achievementID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->IsInFinishAchievementMap(achievementID);
	}

	return GetAchievementAsset().IsInFinishAchievementRecord(achievementID);
}

ResultType LC_ServerPlayer::CheckAchievementCanFinish(int achievementID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckAchievementCanFinish(achievementID);
	}

	return GetAchievementAsset().CheckAchievementCanFinish(achievementID);
}

void LC_ServerPlayer::RefreshAchievementSystem()
{
	if(!IsMainController())
	{
		return;
	}

	RefreshAchievement_ControllerEquip();
	GetSkillBookAsset().RefreshSkillBookInfoToAchievement(this);
	RefreshAchievement_BuddyInfo();
	RefreshAchievement_RuneInfo();
	RefreshAchievement_BuddyEquipSlotInfo();
	GetCommandEquipPack().UpdateControllerMoldingSpiritSuitInfo(this);
	getCollectEquipRecord()->RefreshAchievement_CollectEquip(this);
}

void LC_ServerPlayer::RefreshAchievement_ControllerEquip()
{
	LC_ItemFactoryBase* pkItemFactory = LC_ItemFactoryBase::GetSingletonPtr();
	if(NULL == pkItemFactory)
	{
		return;
	}

	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_CONTROLLER_EQUIP);

	std::map<int32_t,PS_ControllerEquipSlotItemInfo> controllerEquipSlotItemInfo;
	GetCommandEquipPack().GetControllerEquipSlotlnfo(controllerEquipSlotItemInfo);
	for(std::map<int32_t,PS_ControllerEquipSlotItemInfo>::iterator it=controllerEquipSlotItemInfo.begin(); it!=controllerEquipSlotItemInfo.end(); ++it)
	{
		int32_t itemID = it->second.m_nEquipItem;
		LC_ItemBase* pkItem = pkItemFactory->RequestItem( itemID );
		if(NULL != pkItem)
		{
			AchievementEvent kEvent;
			kEvent.SetConditionInfo(pkItem->GetLevel(), pkItem->GetGrade(), pkItem->GetEquipTypeLimit());
			kEvent.SetNum(1);
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_CONTROLLER_EQUIP, kEvent);
		}
	}
}

void LC_ServerPlayer::RefreshAchievement_SubInfo()
{
	int arr[] = {LC_SUB_TP_VEHICLE, LC_SUB_TP_DEVA_EYE, LC_SUB_TP_MUHUN};
	for(uint32_t i=0; i<sizeof(arr)/sizeof(arr[0]); ++i)
	{
		int subType = arr[i];
		AchievementEvent kEvent;
		kEvent.SetConditionInfo(subType);

		kEvent.SetNum(GetSubordinateAsset().GetSubStage(subType));
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SUB_STAGE, kEvent);

		kEvent.SetNum(GetSubordinateAsset().GetTransformMapSize(subType));
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ADD_SUB_TRANSFORM, kEvent);
	}
}

void LC_ServerPlayer::RefreshAchievement_BuddyInfo()
{
	const mem::map<int32_t, BuddyInstance*>* pkBuddyMap = GetUsableBuddyMap();
	if(NULL == pkBuddyMap)
	{
		return;
	}

	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_BUDDY_STARLEVEL);
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_STARLEVEL);
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_LEVEL);
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_GET_TRANSFORM_ID);

	for(mem::map<int32_t, BuddyInstance*>::const_iterator it=(*pkBuddyMap).begin(); it!=(*pkBuddyMap).end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			AchievementEvent kEvent1;
			kEvent1.SetConditionInfo(pkBuddy->GetStarLevel(), pkBuddy->GetQuality());
			kEvent1.SetNum(1);
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_BUDDY_STARLEVEL, kEvent1);

			AchievementEvent kEvent2;
			kEvent2.SetConditionInfo(pkBuddy->GetTemplateID());
			kEvent2.SetNum(pkBuddy->GetStarLevel());
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_STARLEVEL, kEvent2);

			AchievementEvent kEvent;
			kEvent.SetConditionInfo(pkBuddy->GetTemplateID());
			kEvent.SetNum(pkBuddy->GetLevel());
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_LEVEL, kEvent);

			mem::vector<int32_t> transformID;
			pkBuddy->GetBuddyTransformID(transformID);
			for(int i=0; i<transformID.size(); ++i)
			{
				AchievementEvent kEvent1;
				kEvent1.SetConditionInfo(transformID[i]);
				kEvent1.SetNum(1);
				UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_GET_TRANSFORM_ID, kEvent1);
			}
		}
	}	
}

void LC_ServerPlayer::RefreshAchievement_RuneInfo()
{
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_RUNE_STARLEVEL);

	LC_PackAsset* pkAsset = GetPackAsset();
	if(NULL == pkAsset)
	{
		return;
	}

	//buddy宝具背包
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			mem::map<int32_t, int32_t> itemID2StarLevelMap;
			pkBuddy->GetRunePack().GetAllBuddyRuneItemStarLevelData(itemID2StarLevelMap);

			for(mem::map<int32_t, int32_t>::iterator it=itemID2StarLevelMap.begin(); it!=itemID2StarLevelMap.end(); ++it)
			{
				int starLevel = it->second;
				for(int i=1; i<=starLevel; ++i)
				{
					AchievementEvent kEvent;
					kEvent.SetConditionInfo(i);
					kEvent.SetNum(1);
					UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_RUNE_STARLEVEL, kEvent);
				}
			}
		}
	}

	//基础背包
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				for(int i=1; i<=pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_STAR); ++i)
				{
					AchievementEvent kEvent;
					kEvent.SetConditionInfo(i);
					kEvent.SetNum(1);
					UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_RUNE_STARLEVEL, kEvent);
				}
			}
		}
	}

	//仓库
	int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
	for (int32_t i = 0;i < iWarehousePackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				for(int i=1; i<=pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_STAR); ++i)
				{
					AchievementEvent kEvent;
					kEvent.SetConditionInfo(i);
					kEvent.SetNum(1);
					UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_RUNE_STARLEVEL, kEvent);
				}
			}
		}
	}
}

void LC_ServerPlayer::RefreshAchievement_BuddyEquipSlotInfo()
{
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_BUDDY_EQUIPSLOT_STARLEVEL);
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_EQUIPSLOT);
	GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_BUDDY_EQUIPSLOT_TOTALLEVEL);

	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
		{
			continue;
		}

		AchievementEvent kEvent3;
		kEvent3.SetConditionInfo(pkBuddy->GetTemplateID());
		kEvent3.SetNum(pkBuddy->GetEquipSlotTotalLevel());
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_BUDDY_EQUIPSLOT_TOTALLEVEL, kEvent3);

		std::map<int32_t,PS_EquipItemInfo_BuddyCS> equipData;
		pkBuddy->GetEquipInfo(equipData);
		for(std::map<int32_t,PS_EquipItemInfo_BuddyCS>::iterator it=equipData.begin(); it!=equipData.end(); ++it)
		{
			int starLevel = it->second.m_nEquipSlotStarLevel;
			for(int i=1; i<=starLevel; ++i)
			{
				AchievementEvent kEvent;
				kEvent.SetConditionInfo(pkBuddy->GetTemplateID(), i);
				kEvent.SetNum(1);
				UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_BUDDY_EQUIPSLOT_STARLEVEL, kEvent);
			}

			int level = it->second.m_nEquipSlotLevel;
			AchievementEvent kEvent1;
			kEvent1.SetConditionInfo(pkBuddy->GetTemplateID(), it->first);
			kEvent1.SetNum(level);
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_UPGRADE_BUDDY_EQUIPSLOT, kEvent1);		
		}
	}	
}

bool LC_ServerPlayer::IsInFinishBiographyMap(int biographyID)
{
	return m_biographySet.find(biographyID) != m_biographySet.end();
}

bool LC_ServerPlayer::IsInFinishBiographyRewardPartMap(int biographyPartID)
{
	return m_biographytRewardPartSet.find(biographyPartID) != m_biographytRewardPartSet.end();
}

bool LC_ServerPlayer::IsInFinishBiographyPartMap(int biographyPartID)
{
	return m_nFinishBiographyPartSet.find(biographyPartID) != m_nFinishBiographyPartSet.end();
}

bool LC_ServerPlayer::CheckBiographyFinishCondition(int biographyID)
{
	CF_Biography::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
	if(NULL == pkData)
	{
		return false;
	}

	const Utility::UT_SIMDataList& biographyPartID = pkData->_iBiographyTaskID;
	for(Utility::UT_SIMDataList::const_iterator it1=biographyPartID.begin(); it1!=biographyPartID.end(); ++it1)
	{
		int partID = it1->IID();
		CF_BiographyTask::DataEntry* pkBKData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(partID);
		if(NULL == pkBKData)
		{
			return false;
		}

		const Utility::UT_SIMDataList& taskIDs = pkBKData->_sTaskID;
		for(Utility::UT_SIMDataList::const_iterator it2=taskIDs.begin(); it2!=taskIDs.end(); ++it2)
		{
			int taskID = it2->IID();
			if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
			{
				return false;
			}
		}

		const Utility::UT_SIMDataList& achievementIDs = pkBKData->_sAchievementID;
		for(Utility::UT_SIMDataList::const_iterator it3=achievementIDs.begin(); it3!=achievementIDs.end(); ++it3)
		{
			int achievementID = it3->IID();
			if(!IsInFinishAchievementMap(achievementID))
			{
				return false;
			}
		}
	}
	return true;
}

void LC_ServerPlayer::HandleProcessTaskForEnter()
{
	if (!IsInstance())
	{
		return;
	}
	if (IsRegisterTask())
	{
		return;
	}
	_removeTimeLimitTask();
	SetRegisterTaskFlag(true);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::HandleProcessTaskForQuit()
{
	if (!IsInstance())
	{
		return;
	}

	if (IsRegisterTask() == false)
	{
		return;
	}
	_removeTimeLimitTask();
	SetRegisterTaskFlag(false);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::_removeTimeLimitTask()
{
	if (!IsInstance())
	{
		return;
	}

	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	if (NULL == pkTaskManager)
	{
		return;
	}
	if (NULL == m_pkTaskMap)
	{
		return;
	}
	mem::vector<int> vecTaskList;
	LC_ProcessingTaskEntryMap& kProcessEntryMap = m_pkTaskMap->GetProcessingTaskEntryMap();
	LC_ProcessingTaskEntryMap::iterator it = kProcessEntryMap.begin();
	for (; it != kProcessEntryMap.end(); ++it)
	{
		//检查进行中任务entry
		LC_ProcessingTaskEntry& kProcessingTaskEntry = it->second;

		int lTaskID = kProcessingTaskEntry.GetTaskID();
		LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
		if (NULL == pkTask)
		{
			continue;
		}

		//有时间限制的任务，下线不删除
		if (pkTask->GetActiveTime() > 0)
		{
			vecTaskList.push_back(lTaskID);
		}
	}

	for (int i = 0; i < (int)vecTaskList.size(); ++i)
	{
		CancelTask(vecTaskList[i]);
		LC_Task* pkTask = pkTaskManager->GetTask(vecTaskList[i]);
		if (NULL == pkTask)
		{
			continue;
		}
		if (m_pkTaskMap)
		{
			m_pkTaskMap->RecordTaskFail(vecTaskList[i], pkTask->GetTaskIndex());
		}
	}
}
//---------------------------------------------------------------------------------------
void LC_ServerPlayer::AIFillExecuteSkillParam(Skill::SK_SkillExecute* pkSkill)
{
	if (NULL == pkSkill)
	{
		return;
	}

	LC_MapBase* pkMap = GetMap();
	if (NULL == pkMap)
	{
		return;
	}

	int iOperationType	= pkSkill->GetProperty_OperationType();
	switch (iOperationType)
	{
	case SOT_TARGET: //目标型
		{
		}
		break;
	case SOT_DIR:	//朝向型
		{
			object_id_type lTargetID = this->GetLockedTargetID();
			LC_LogicObject* pkTarget = pkMap->FindObject(lTargetID);
			//UT_Vec3Int kCurrentLocation = this->GetCurrentLocation();
			const UT_Vec3Int& kTargetLocation  = (NULL != pkTarget) ? pkTarget->GetCurrentLocation() : this->GetLockedLocation();
			if (NULL != pkTarget)	this->SetLockedLocation(kTargetLocation);	//跟踪目标，将用来设置TargetLocation
		}
		break;
	case SOT_LOCATION: //地点型
		{
			//以地面位置设为目标点
			object_id_type lTargetID = this->GetLockedTargetID();
			LC_LogicObject* pkTarget = pkMap->FindObject(lTargetID);
			//UT_Vec3Int kCurrentLocation = this->GetCurrentLocation();
			const UT_Vec3Int& kTargetLocation  = (NULL != pkTarget) ? pkTarget->GetCurrentLocation() : this->GetLockedLocation();
			if (NULL != pkTarget)	this->SetLockedLocation(kTargetLocation);	//跟踪目标，将用来设置TargetLocation
		}
		break;
	default:
		break;
	}

}
#define MAX_INVITE_TIME 300000
//---------------------------------------------------------------------------------------
ResultType LC_ServerPlayer::CheckExecuteSkill(float fCurrentTime, Skill::SK_SkillExecute* pkSkill, int lItemID)
{
	if (NULL == pkSkill)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}
	int lSkillType = pkSkill->GetExecuteID();
	CF_SkillSpecialAttrib::DataEntry* pkSkillAttrib = pkSkill->GetAttrDataEntryPtr();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkill->GetDataEntryPtr();

	if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	//判断技能是否合法
	if (!CheckSkillValid(pkSkillAttrib, lItemID))
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	LC_MapBase* pkMap = GetMap();
	if (NULL == pkMap)
	{
		return RE_SKILL_LOST_TARGET;
	}

	if(pkSkillData->_iMinPackCount != 0)
	{
		int emptySize = LC_Helper::GetPackEmptyEntryCount(this, PACK_TYPE_BASIC);
		if(emptySize < pkSkillData->_iMinPackCount)
		{
			return RE_ITEM_PACKAGE_FULL;
		}
	}

	//检查自身SkillFlag是否满足技能释放需求
	//StringType kWrongSkillFlag;
	ResultType eCheckSkillFlag = pkSkill->CheckActorSkillFlag(GetAllSkillFlag());
	if (eCheckSkillFlag != RE_SKILL_CHECK_SKILLFLAG_SUCCESS)
	{
		return eCheckSkillFlag;
	}
	//检查CD

	int lSkillNeedCheckCD = lSkillType;

	if ( GetGlobalSetting.nSkillUsableCountMode && !pkSkill->GetProperty_IsLCSkill())
	{
		int nUsableCount = GetSkillUsableCount_Self(lSkillNeedCheckCD);
		if (nUsableCount <= 0)
			return RE_SKILL_USABLE_COUNT_LIMIT;
	}
	else
	{
		//放宽服务器端技能cd检查，避免客户端cd结束，但服务器cd还未结束
		//再次因为客户端技能先释放，因此客户端技能更早进入CD ，加大到1s		
		if (pkSkillData->_fCoolDownTime > 0 && GetSkillCoolDownMap()->GetSkillCurrentCDTime(lSkillNeedCheckCD) > 0.15f)
		{
			return RE_SKILL_PENDING_FAIL_CD;
		}
	}
	//判断武器类型

	//判断资源
	ResultType eCheckCostResult = LC_Helper::CheckSkillCost(this, pkSkillData);
	if (eCheckCostResult != RE_SKILL_ENOUGH_RESOURCE)
	{
		return eCheckCostResult;
	}

	CF_LogicAreaFunc::DataEntry* pkLogicAreaFunc = GetLogicAreaFunc();
	if (NULL != pkLogicAreaFunc)
	{
		//是否能在当前区域使用
		if (!pkSkill->CanUseInCurrentLogicArea(pkLogicAreaFunc->_iID))
		{
			return RE_SKILL_PENDING_FAIL_ILLEGAL_LOGIC_AREA;
		}
	}


	//判断触发条件
	{
		int iOperationType			 = pkSkill->GetProperty_OperationType();
		int iLockTargetType			 = pkSkill->GetProperty_LockTargetType();

		int iSkillExecuteMaxDistance = pkSkill->GetProperty_MaxExecuteDistance();

		int	 lExecuteDistanceFunc	= pkSkill->GetProperty_ExecuteDistanceFunc();

		UT_Vec3Int kCurrentLocation = GetCurrentLocation();
		UT_Vec3Int kTargetLocation = kCurrentLocation;
		ResultType iResult;
		switch (iOperationType)
		{
		case SOT_TARGET: //目标型
			{
				object_id_type lTargetID = 0;
				LC_LogicObject* pkTarget = NULL;
				UT_Vec3Int kCurrentLocation = GetCurrentLocation();
				UT_Vec3Int kTargetLocation;
				CF_ActorFilterFunc* pkCSVActorFilterFunc = CF_ActorFilterFunc::GetSingletonPtr();
				CF_ActorFilterFunc::DataEntry* pkData = pkCSVActorFilterFunc->GetEntryPtr(iLockTargetType);
				if (NULL == pkData)
				{
					return RE_SKILL_SYSTEM_ERROR;
				}
				lTargetID = GetLockedTargetID();

				pkTarget = pkMap->FindObject(lTargetID);

				GfxWriteLog(LOG_RES_FILELINE,LOG_SWITCH_RES,"[Combat]%lu cast skill <%d>", lTargetID, lItemID);
				ResultType rty = LC_Helper::IsValidTarget(this, lTargetID, pkData);
				if (!pkTarget || (rty != RE_SKILL_CHECK_VALID_TARGET && rty != RE_SKILL_PENDING_FAIL_IN_SAFE_AREA))
				{
					iResult = RE_SKILL_LOST_TARGET;
				}
				else
				{
					iResult = RE_SKILL_NONE_ERROR;
					kTargetLocation  = pkTarget->GetCurrentLocation();
					int iDistance = UT_MathBase::LineLengthXYInt(kCurrentLocation, kTargetLocation);
					if (iDistance > iSkillExecuteMaxDistance + 1000)
					{
						iResult = RE_SKILL_DISTANCE_TOO_FAR;
					}
				}
			}
			break;
		case SOT_DIR: //朝向型
			{
				if (lExecuteDistanceFunc != SEDF_CHECK)	//不检查距离则不做距离检测
				{
					iResult = RE_SKILL_NONE_ERROR;
				}
				else
				{
					object_id_type lTargetID = this->GetLockedTargetID();
					//pkTarget will be NULL when lTargetID == 0
					iResult = RE_SKILL_NONE_ERROR;
					if ( (IsInstance() || IsProxy()) && !GetAIControl() && GetControlType() == eControlType_Player)
					{
						break;
					}

					LC_LogicObject* pkTarget = pkMap->FindObject(lTargetID);
					const UT_Vec3Int& kCurrentLocation = this->GetCurrentLocation();
					UT_Vec3Int kTargetLocation  = (NULL != pkTarget) ? pkTarget->GetCurrentLocation() : this->GetLockedLocation();
					if (NULL != pkTarget)
					{
						this->SetLockedLocation(kTargetLocation);	//跟踪目标，将用来设置TargetLocation
					}
					int iSafeRadius	 = this->GetProperty_ShapeRadius();
					if ((IS_PLAYER_CLASS_ID(lTargetID) || IS_NPC_ID(lTargetID)) && NULL != pkTarget)
					{
						iSafeRadius	+= ((LC_ActorBase*)pkTarget)->GetProperty_ShapeRadius();
					}
					kTargetLocation = UT_MathBase::ComputeSafeRadiusTargetLocation(kCurrentLocation, kTargetLocation, iSafeRadius);
					int iDistance = UT_MathBase::LineLengthXYInt(kCurrentLocation, kTargetLocation);
					if (iDistance > iSkillExecuteMaxDistance)
					{
						iResult = RE_SKILL_DISTANCE_FAR;
					}
				}
				break;
			}

		case SOT_LOCATION: //地点型
			{
				//以地面位置设为目标点
				iResult = RE_SKILL_NONE_ERROR;
				kTargetLocation = GetLockedLocation();
				int iCurrentDistance = UT_MathBase::LineLengthXYInt(kCurrentLocation, kTargetLocation);
				if (iCurrentDistance > iSkillExecuteMaxDistance + 1000 && lExecuteDistanceFunc == SEDF_CHECK)
				{
					iResult = RE_SKILL_DISTANCE_TOO_FAR;
				}
			}
			break;
		default:
			{
				iResult = RE_SKILL_SYSTEM_ERROR;
			}
			break;
		}



		if (iResult != RE_SKILL_NONE_ERROR)
		{
			return iResult;
		}
	}
	return LC_ActorBase::CheckExecuteSkill(fCurrentTime, pkSkill, lItemID);
}
//---------------------------------------------------------------------------------------
ResultType LC_ServerPlayer::ExecuteSkill(float fCurrentTime, Skill::SK_SkillExecute* pkSkill, int lItemID)
{
	if (NULL == pkSkill || m_pAssignedBuddyInstance == NULL)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	LC_ActorBase::ExecuteSkill(fCurrentTime, pkSkill, lItemID);
	int lSkillType = pkSkill->GetExecuteID();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkill->GetDataEntryPtr();
	if (NULL == pkSkillData)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}
	//互斥骑乘状态
	if (GetRiderCharType() > 0)
	{
		if (pkSkillData->_bMutexWithRider || (pkSkillData->_bMutexWithVehicleLevel > 0 && !IsCimeliaEnabled(LC_SUB_TP_VEHICLE_FIGHTING)))
		{
			SC_ServerSkillInterface* pkSkillInterface = SC_ServerScriptInterface::GetSingleton().GetSkillInterface();

			pkSkillInterface->DetachTargetStateToController(this, TARGET_ME, SMT_KIND, 99, 0, 0);
		}
	}

	//1、非引导型技能在启动技能时扣除资源、刷新cd
	//2、引导型的在脚本中扣除资源、刷新cd
	if (SPC_INDUCE != pkSkillData->_iSkillProcessCategory)
	{
		LC_Helper::CostSkillResource(this, pkSkillData);
		if (pkSkill->GetProperty_CoolDownTime() > 0 || pkSkill->GetProperty_UseCoolDown())
		{

			bool bIgnoreSkillGlobalCD = GetSkillFlag(SK_IGNORE_SKILL_GLOBAL_CD);
			if (!bIgnoreSkillGlobalCD)
			{
				//添加公共CD
				GetSkillCoolDownMap()->AddGlobalCoolDownLevel(pkSkill->GetExecuteID(), fCurrentTime);
			}
			//添加CD
			if ( GetGlobalSetting.nSkillUsableCountMode == 0)
			{
				GetSkillCoolDownMap()->RefreshSkillCD(lSkillType, bIgnoreSkillGlobalCD, false);
			}
		}
	}

	//重丢骰子
	RecomputeRandNums();

	//设置启动参数
	if (IS_ITEM_ID(lItemID))
	{
		CF_ItemList* pkCSVItemList = CF_ItemList::GetSingletonPtr();
		CF_ItemList::DataEntry* pkData = pkCSVItemList->GetEntryPtr(lItemID);
		if (NULL == pkData)
		{
			return RE_SKILL_SYSTEM_ERROR;
		}

		//第0个参数是物品ID
		SetSkillStartParameter(0, lItemID);
		//第1-4个参数从物品表获得
		SetSkillStartParameter(1, pkData->_lUseTriggerSkillPara1);
		SetSkillStartParameter(2, pkData->_lUseTriggerSkillPara2);
		SetSkillStartParameter(3, pkData->_lUseTriggerSkillPara3);
		SetSkillStartParameter(4, pkData->_lUseTriggerSkillPara4);
		LC_ItemCoolDownMapBase* cdMap = GetControllerItemCoolDownMap();
		if(cdMap != NULL)
		{
			cdMap->RefreshItemCD(lItemID);
		}		
	}

	switch (pkSkill->GetProperty_OperationType())
	{
	case SOT_TARGET:
		{
			MG_Rlt_PlayerExecuteSkillTypeTarget rltMsg;
			rltMsg.m_lRequesterID    = m_iID;
			rltMsg.m_lSkillExecuteID = pkSkill->GetExecuteID();
			rltMsg.m_lLockTargetID   = m_lLockedTargetID;
			rltMsg.m_iResultType	 = RE_SKILL_NONE_ERROR;
			GetRandNums(rltMsg.m_afRandNums);
			rltMsg.m_fServerTime			= fCurrentTime;
			SectorIndex dwSectorIndex = GetSectorIndex();
			rltMsg.m_nLogicValue = m_pAssignedBuddyInstance->CheckActivateSkill(pkSkill->GetExecuteID());
			LC_ServerMap* pkServerMap = (LC_ServerMap*)(GetMap());
			if (pkServerMap)
			{
				pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_TARGET, &rltMsg);
			}
		}
		break;
	case SOT_DIR:
		{
			MG_Rlt_PlayerExecuteSkillTypeDir rltMsg;
			rltMsg.m_lRequesterID		= m_iID;
			rltMsg.m_lLockedTargetID	= m_lLockedTargetID;
			rltMsg.m_lSkillExecuteID	= pkSkill->GetExecuteID();
			rltMsg.m_iForwardDirAngle	= (uint16_t)GetForwardDirAngle();
			rltMsg.m_lLockedLocationX	= GetLockedLocation().x;
			rltMsg.m_lLockedLocationY	= GetLockedLocation().y;
			rltMsg.m_lLockedLocationZ	= GetLockedLocation().z;
			rltMsg.m_iResultType		= RE_SKILL_NONE_ERROR;
			//GetRandNums(rltMsg.m_afRandNums);
			rltMsg.m_fServerTime			= fCurrentTime;
			rltMsg.m_nLogicValue = m_pAssignedBuddyInstance->CheckActivateSkill(pkSkill->GetExecuteID());
			//通知给周围的玩家
			SectorIndex dwSectorIndex = GetSectorIndex();
			LC_ServerMap* pkServerMap = (LC_ServerMap*)(GetMap());
			if (pkServerMap)
			{
				pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_DIR, &rltMsg);
			}
		}
		break;
	case SOT_LOCATION:
		{
			MG_Rlt_PlayerExecuteSkillTypeLocation rltMsg;
			rltMsg.m_lRequesterID			= m_iID;
			rltMsg.m_lSkillExecuteID		= pkSkill->GetExecuteID();
			rltMsg.m_lLockedLocationX		= GetLockedLocation().x;
			rltMsg.m_lLockedLocationY		= GetLockedLocation().y;
			rltMsg.m_lLockedLocationZ		= GetLockedLocation().z;
			rltMsg.m_iResultType			= RE_SKILL_NONE_ERROR;
			GetRandNums(rltMsg.m_afRandNums);
			rltMsg.m_fServerTime			= fCurrentTime;
			rltMsg.m_nLogicValue = m_pAssignedBuddyInstance->CheckActivateSkill(pkSkill->GetExecuteID());

			//通知给周围的玩家
			SectorIndex dwSectorIndex = GetSectorIndex();
			LC_ServerMap* pkServerMap = (LC_ServerMap*)GetMap();
			if (pkServerMap)
			{
				pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_LOCATION, &rltMsg);
			}
		}
		break;
	default:
		break;
	}
	return RE_SKILL_EXECUTE_SUCCESS;
}
//---------------------------------------------------------------------------------------
void LC_ServerPlayer::SetLastExecuteSkillTime(float fTime)
{
	m_fLastExecuteSkillTime = fTime;
}

ResultType LC_ServerPlayer::ExecuteSkillImmediately(float fCurrentTime, Skill::SK_SkillExecute* pkSkill, int lItemID)
{
	if (NULL == pkSkill)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	int lSkillType = pkSkill->GetExecuteID();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkill->GetDataEntryPtr();
	if (NULL == pkSkillData)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	//互斥骑乘状态
	if (GetRiderCharType() > 0)
	{
		if (pkSkillData->_bMutexWithRider || (pkSkillData->_bMutexWithVehicleLevel > 0 && !IsCimeliaEnabled(LC_SUB_TP_VEHICLE_FIGHTING)))
		{
			SC_ServerSkillInterface* pkSkillInterface = SC_ServerScriptInterface::GetSingleton().GetSkillInterface();
			pkSkillInterface->DetachTargetStateToController(this, TARGET_ME, SMT_KIND, 99, 0, 0);
		}
	}

	//1、非引导型技能在启动技能时扣除资源、刷新cd
	//2、引导型的在脚本中扣除资源、刷新cd
	if (SPC_INDUCE != pkSkillData->_iSkillProcessCategory)
	{
		LC_Helper::CostSkillResource(this, pkSkillData);
		if (pkSkill->GetProperty_CoolDownTime() > 0 || pkSkill->GetProperty_UseCoolDown())
		{
			//GetSkillCoolDownMap()->AddSkillCDSlot(lSkillType);
			bool bIgnoreSkillGlobalCD = GetSkillFlag(SK_IGNORE_SKILL_GLOBAL_CD);
			if (!bIgnoreSkillGlobalCD)
			{
				//添加公共CD
				GetSkillCoolDownMap()->AddGlobalCoolDownLevel(pkSkill->GetExecuteID(), fCurrentTime);
			}
			//添加CD
			if ( GetGlobalSetting.nSkillUsableCountMode == 0)
			{
				GetSkillCoolDownMap()->RefreshSkillCD(lSkillType, bIgnoreSkillGlobalCD);
			}
		}
	}

	//暂存技能随机数
	float afOldRandNum[MAX_ATTACKER_RANDNUM_COUNT];
	memcpy_s(afOldRandNum, sizeof(float) * MAX_ATTACKER_RANDNUM_COUNT, m_fRandNum, sizeof(float) * MAX_ATTACKER_RANDNUM_COUNT);

	//重丢骰子
	RecomputeRandNums();
	//执行技能
	pkSkill->ExecuteImmediate(this);

	//回滚技能随机数
	memcpy_s(m_fRandNum, sizeof(float) * MAX_ATTACKER_RANDNUM_COUNT, afOldRandNum, sizeof(float) * MAX_ATTACKER_RANDNUM_COUNT);


	MG_Rlt_PlayerExecuteSkillTypeDir rltMsg;
	rltMsg.m_lRequesterID		= m_iID;
	rltMsg.m_lLockedTargetID	= m_lLockedTargetID;
	rltMsg.m_lSkillExecuteID	= pkSkill->GetExecuteID();
	rltMsg.m_iForwardDirAngle	= (uint16_t)GetForwardDirAngle();
	rltMsg.m_lLockedLocationX	= GetLockedLocation().x;
	rltMsg.m_lLockedLocationY	= GetLockedLocation().y;
	rltMsg.m_lLockedLocationZ	= GetLockedLocation().z;
	rltMsg.m_iResultType		= RE_SKILL_NONE_ERROR;

	rltMsg.m_fServerTime		= fCurrentTime;
	SendMsgToClient(MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_DIR, &rltMsg);

	//抛出释放技能事件
	SK_SkillEventManagerBase* pkEventManager = SK_SkillEventManagerBase::GetSingletonPtr();
	SK_SkillEvent* pkEvent = pkEventManager->AllocEvent();
	if (NULL != pkEvent)
	{
		pkEvent->SetEventType(SETE_EXECUTE_SKILL);
		pkEvent->SetSrcActorID(GetID());
		pkEvent->SetDstActorID(0);
		pkEvent->SetLogicID(pkSkill->GetExecuteID());
		pkEvent->SetParam(SK_ExecuteSkillEvent::SEP_RESULT, SK_ExecuteSkillEvent::SER_SUCCESS);
		pkEventManager->AddEvent(pkEvent);
	}
	return RE_SKILL_EXECUTE_SUCCESS;
}
//---------------------------------------------------------------------------------------

ResultType LC_ServerPlayer::ExecuteLCSkillTargetImmediately( float fCurrentTime, Skill::SK_SkillExecute* pkSkill,object_id_type lLockedID )
{
	if ( !pkSkill )
		return RE_FAIL;

	pkSkill->ExecuteImmediate(this);

	int lSkillType = pkSkill->GetExecuteID();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkill->GetDataEntryPtr();
	if (NULL == pkSkillData)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	if (SPC_INDUCE != pkSkillData->_iSkillProcessCategory)
	{
		LC_Helper::CostSkillResource(this, pkSkillData);
		if (pkSkill->GetProperty_CoolDownTime() > 0 || pkSkill->GetProperty_UseCoolDown())
		{
			//GetSkillCoolDownMap()->AddSkillCDSlot(lSkillType);
			bool bIgnoreSkillGlobalCD = GetSkillFlag(SK_IGNORE_SKILL_GLOBAL_CD);
			if (!bIgnoreSkillGlobalCD)
			{
				//添加公共CD
				GetSkillCoolDownMap()->AddGlobalCoolDownLevel(pkSkill->GetExecuteID(), fCurrentTime);
			}
			//添加CD
			if ( GetGlobalSetting.nSkillUsableCountMode == 0)
			{
				GetSkillCoolDownMap()->RefreshSkillCD(lSkillType, bIgnoreSkillGlobalCD);
			}

		}
	}

	SetLCLockedID(lLockedID);

	MG_Rlt_PlayerExecuteSkillTypeTarget rltMsg;
	rltMsg.m_lRequesterID    = m_iID;
	rltMsg.m_lSkillExecuteID = pkSkill->GetExecuteID();
	rltMsg.m_lLockTargetID   = m_lLockedTargetID;
	rltMsg.m_iResultType	 = RE_SKILL_NONE_ERROR;
	rltMsg.m_fServerTime	= fCurrentTime;
	rltMsg.m_nLogicValue = 0;
	SectorIndex dwSectorIndex = GetSectorIndex();
	LC_ServerMap* pkServerMap = (LC_ServerMap*)(GetMap());
	if (pkServerMap)
	{
		pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_TARGET, &rltMsg);
	}
	return RE_SKILL_NONE_ERROR;
}

//---------------------------------------------------------------------------------------
ResultType LC_ServerPlayer::ExecuteLCSkillImmediately(float fCurrentTime, Skill::SK_SkillExecute* pkSkill
													  ,object_id_type lLockedID, UT_Vec3Int lockedLocation, float dirAngle)
{
	if ( !pkSkill )
		return RE_FAIL;

	UT_Vec3Int oldLockedLocation = GetLockedLocation();
	UT_Vec2Float oldDirection = GetForwardDir();
	UT_Vec2Float oldTargetDirection = GetTargetForwardDir();
	UT_Vec3Int newLockedLocation = lockedLocation;

	if (lLockedID>0)
	{
		LC_MapBase* pkMapBase = GetMap();
		if (pkMapBase)
		{
			LC_ActorBase* pkTarget = (LC_ActorBase*)(pkMapBase->FindObject(lLockedID));
			if (pkTarget)
				newLockedLocation = pkTarget->GetCurrentLocation();
		}
	}

	SetLockedLocation(newLockedLocation);
	LC_Helper::FaceActorToLocation(this,GetCurrentLocation(),newLockedLocation);

	pkSkill->ExecuteImmediate(this);
	SetLockedLocation(oldLockedLocation);
	SetForwardDir(oldDirection);
	SetTargetForwardDir(oldTargetDirection);

	int lSkillType = pkSkill->GetExecuteID();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkill->GetDataEntryPtr();
	if (NULL == pkSkillData)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	if (SPC_INDUCE != pkSkillData->_iSkillProcessCategory)
	{
		LC_Helper::CostSkillResource(this, pkSkillData);
		if (pkSkill->GetProperty_CoolDownTime() > 0 || pkSkill->GetProperty_UseCoolDown())
		{

			bool bIgnoreSkillGlobalCD = GetSkillFlag(SK_IGNORE_SKILL_GLOBAL_CD);
			if (!bIgnoreSkillGlobalCD)
			{
				//添加公共CD
				GetSkillCoolDownMap()->AddGlobalCoolDownLevel(pkSkill->GetExecuteID(), fCurrentTime);
			}
			//添加CD
			if ( GetGlobalSetting.nSkillUsableCountMode == 0)
			{
				GetSkillCoolDownMap()->RefreshSkillCD(lSkillType, bIgnoreSkillGlobalCD);
			}
		}
	}

	SetLCLockedID(lLockedID);

	MG_Rlt_PlayerExecuteSkillTypeDir rltMsg;
	rltMsg.m_lRequesterID		= m_iID;
	rltMsg.m_lLockedTargetID	= lLockedID;
	rltMsg.m_lSkillExecuteID	= pkSkill->GetExecuteID();
	rltMsg.m_iForwardDirAngle	= (uint16_t)dirAngle;
	rltMsg.m_lLockedLocationX	= lockedLocation.x;
	rltMsg.m_lLockedLocationY	= lockedLocation.y;
	rltMsg.m_lLockedLocationZ	= lockedLocation.z;
	rltMsg.m_iResultType		= RE_SKILL_NONE_ERROR;
	//GetRandNums(rltMsg.m_afRandNums);
	rltMsg.m_fServerTime			= fCurrentTime;
	//通知给周围的玩家
	SectorIndex dwSectorIndex = GetSectorIndex();
	LC_ServerMap* pkServerMap = (LC_ServerMap*)(GetMap());
	if (pkServerMap)
	{
		pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_DIR, &rltMsg);
	}
	return RE_SKILL_NONE_ERROR;
}
//--------------------------------------------------------------------------------------
LC_SkillBookAsset& LC_ServerPlayer::GetSkillBookAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetSkillBookAsset();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetSkillBookAsset();
	}

	return LC_PlayerBase::GetSkillBookAsset();
}
//--------------------------------------------------------------------------------------
ResultType LC_ServerPlayer::SkillBookUpgrade(int32_t id, int32_t pos)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return RE_FAIL;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SkillBookUpgrade(id, pos);
	}

	ResultType res = RE_FAIL;
	LC_SkillBookAsset& skillBookAsset = GetSkillBookAsset();
	res = skillBookAsset.CheckUpgrade(id);
	if(res != RE_SUCCESS)
		return res;

	res = skillBookAsset.TryUpgrade(id, pos);
	return res;
}
//---------------------------------------------------------------------------------------
ResultType LC_ServerPlayer::InterruptSkill(float fCurrentTime, int lSkillTypeID, SkillInterruptType eInterruptType)
{
	ResultType eInterruptResult = LC_ActorBase::InterruptSkill(fCurrentTime, lSkillTypeID, eInterruptType);
	if (eInterruptResult != RE_SKILL_NONE_ERROR)
	{
		return eInterruptResult;
	}

	//通知客户端
	//	bool bInterruptError = false;

	MG_Rlt_PlayerInterruptSkill rltMsg;
	rltMsg.m_lRequesterID		= m_iID;
	rltMsg.m_lSkillExecuteID	= lSkillTypeID;
	rltMsg.m_usInterruptType	= eInterruptType;
	rltMsg.m_iResultType		= RE_SKILL_NONE_ERROR;

	//通知给周围的玩家
	SectorIndex dwSectorIndex = GetSectorIndex();
	LC_ServerMap* pkServerMap = (LC_ServerMap*)GetMap();
	if (NULL != pkServerMap)
	{
		pkServerMap->BroadCastToArea(dwSectorIndex, MGPT_RLT_PLAYER_INTERRUPT_SKILL, &rltMsg);
	}
	SendMsgToClient(MGPT_RLT_PLAYER_INTERRUPT_SKILL, &rltMsg);
	return RE_SKILL_NONE_ERROR;
}
//------------------------------------------------------------------------

bool	LC_ServerPlayer::LearnSkillToBuddyByIndex(int32_t nBuddyIndex, int lSkillID, int& iSlotIdx, int32_t runeSystemType, int32_t runeSystemParam, LC_SkillIDSet* pkReplacedSkills)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner)
		return false;

	if (!IsMainController())
	{
		return pOwner->LearnSkillToBuddyByIndex(nBuddyIndex, lSkillID, iSlotIdx, runeSystemType, runeSystemParam, pkReplacedSkills);
	}
	LC_ServerPlayer* pResultPlayer = pOwner->GetActivateBuddyByIndex(nBuddyIndex);
	IF_A_NA_PLAYER(pResultPlayer)
		return false;
	return pResultPlayer->LearnSkill(lSkillID, iSlotIdx, runeSystemType, runeSystemParam, pkReplacedSkills);
}

bool	LC_ServerPlayer::RemoveSkillToBuddyByIndex(int32_t nBuddyIndex, int lSkillID)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner)
		return false;

	if (!IsMainController())
	{
		return pOwner->RemoveSkillToBuddyByIndex(nBuddyIndex, lSkillID);
	}
	LC_ServerPlayer* pResultPlayer = pOwner->GetActivateBuddyByIndex(nBuddyIndex);
	IF_A_NA_PLAYER(pResultPlayer)
		return false;
	return pResultPlayer->RemoveSkill(lSkillID);
}


bool LC_ServerPlayer::RemoveSkill(int lSkillID)
{
	if (m_pAssignedBuddyInstance == NULL)
		return false;

	//更新至客户端
	UpdateDirtyFlag(DIRTY_FLAG_SKILLASSET);
	return m_pAssignedBuddyInstance->RemoveSkill( lSkillID);

#if 0
	if (!IsInstance())
	{
		return false;
	}

	if (IS_SKILL_TYPE(lSkillID))
	{
		if (RE_SUCCESS == m_kSkillAsset.DeleteSkillFromAsset(lSkillID))
		{
			//如果是被动技能，立即激活
			SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(lSkillID);
			if (pkSkillExecute == NULL)
			{
				return false;
			}
			CF_SkillExecuteList::DataEntry* pkSkillData = pkSkillExecute->GetDataEntryPtr();
			if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
			{
				if (pkSkillExecute->HasPassive())
				{
					pkSkillExecute->EndPassive(this);
				}
				else
				{
					CF_SkillSpecialAttrib::DataEntry* pkAttrib = pkSkillExecute->GetAttrDataEntryPtr();
					if(pkAttrib)
						this->DeactiveSkillState(pkAttrib->_lSkillConstParameter1);
				}
			}
			//删除该CD信息
			GetSkillCoolDownMap()->RemoveSkillCDSlot(lSkillID);
			//更新至客户端
			UpdateDirtyFlag(DIRTY_FLAG_SKILLASSET);
			return true;
		}
	}
	return false;
#endif
}

bool LC_ServerPlayer::LearnSkillToBuddy(int32_t nBuddyId, int lSkillID, int& iSlotIdx, int32_t runeSystemType, int32_t runeSystemParam, GameLogic::LC_SkillIDSet* pkReplacedSkills, bool bSyncLearnSkillEvent)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController() )
	{
		return m_pOwnerPlayer->LearnSkillToBuddy(nBuddyId, lSkillID, iSlotIdx, runeSystemType, runeSystemParam, pkReplacedSkills, bSyncLearnSkillEvent);
	}
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if (pBuddy == NULL)
		return false;
	return pBuddy->LearnSkill(lSkillID, iSlotIdx, true, runeSystemType, runeSystemParam, pkReplacedSkills, bSyncLearnSkillEvent);
}

bool LC_ServerPlayer::RemoveSkillToBuddy(int32_t nBuddyId, int lSkillID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;
	if (!IsMainController())
		return m_pOwnerPlayer->RemoveSkillToBuddy(nBuddyId, lSkillID);
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if (pBuddy == NULL)
		return false;
	return pBuddy->RemoveSkill(lSkillID);
}

LC_PKRecorderBase* LC_ServerPlayer::GetPKRecorder()
{
	if ( m_pPKRecorder_Cache )
		return m_pPKRecorder_Cache;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPKRecorder();

	if (!IsMainController())
	{
		m_pPKRecorder_Cache =  m_pOwnerPlayer->GetPKRecorder();
		return m_pPKRecorder_Cache;
	}

	//return &m_kPKRecorder;
	m_pPKRecorder_Cache = LC_PlayerBase::GetPKRecorder();
	return m_pPKRecorder_Cache;
}

PKStateType LC_ServerPlayer::GetPKState()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPKState();

	if (!IsMainController())
	{
		return m_pOwnerPlayer->GetPKState();
	}

	return LC_PlayerBase::GetPKState();
}

//------------------------------------------------------------------------
LC_ShortcutBar* LC_ServerPlayer::GetShortcutBar()
{
	if (m_pAssignedBuddyInstance == NULL)
		return NULL;

	return m_pAssignedBuddyInstance->GetShortcutBar();
}

ResultType LC_ServerPlayer::UpdateSkillInSkillAsset(int iCategory, int& iEntryIndex, int iMax)
{
	if (!IsInstance())
	{
		return RE_FAIL;
	}
	LC_SkillAssetEntry* pkSDEntry = m_kSkillAsset.GetSkillEntryInAsset(iCategory, iEntryIndex);
	if (!pkSDEntry || !pkSDEntry->GetValid())
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	skill_id_type preSkillID = pkSDEntry->GetTypeID();
	CF_SkillLevelUp* pkCSVSkillLevelUp = CF_SkillLevelUp::GetSingletonPtr();
	CF_SkillLevelUp::DataEntry* pkSDData = pkCSVSkillLevelUp->GetEntryPtr(preSkillID);
	if (!pkSDData)
	{
		return RE_SKILL_SYSTEM_ERROR;
	}

	ResultType ret = LC_PlayerBase::UpdateSkillInSkillAsset(iCategory, iEntryIndex, iMax);
	if (ret != RE_SKILL_UPDATE_SUCCESS)
	{
		return ret;
	}

	//处理被动技能
	LC_SkillAssetEntry* pkEntry = m_kSkillAsset.GetSkillEntryInAsset(iCategory, iEntryIndex);
	skill_id_type curskillid = pkEntry ? pkEntry->GetTypeID() : 0;
	if (preSkillID == curskillid)
	{
		return ret;
	}


	SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(preSkillID);
	if (pkSkillExecute == NULL)
	{
		return ret;
	}
	CF_SkillSpecialAttrib::DataEntry* pkSkillAttrib = pkSkillExecute->GetAttrDataEntryPtr();
	CF_SkillExecuteList::DataEntry* pkSkillData = pkSkillExecute->GetDataEntryPtr();

	if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
	{
		if (pkSkillExecute->HasPassive())
		{
			pkSkillExecute->EndPassive(this);
		}
		else
		{
			this->DeactiveSkillState(pkSkillAttrib->_lSkillConstParameter1);
		}
	}

	pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(curskillid);
	if (pkSkillExecute == NULL)
	{
		return ret;
	}
	pkSkillAttrib = pkSkillExecute->GetAttrDataEntryPtr();
	pkSkillData = pkSkillExecute->GetDataEntryPtr();
	if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
	{
		if (pkSkillExecute->HasPassive())
		{
			pkSkillExecute->StartPassive(this);
		}
		else
		{
			this->ActiveSkillState(pkSkillAttrib->_lSkillConstParameter1, 0, this->GetID(),
				Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter2),
				Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter3),
				Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter4),
				Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter5),
				Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter6));
		}
	}


	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL != pkOwnerPlayer)
	{
		oss_role_sk_lvup(pkOwnerPlayer, curskillid, pkSkillData->_lCategory2, pkSDData->_lNeedSP, pkSDData->_lNeedCash);
	}
	return ret;
}

//------------------------------------------------------------------------
bool LC_ServerPlayer::LearnSkill(int lSkillID, int& iSlotIdx, int32_t runeSystemType, int32_t runeSystemParam, GameLogic::LC_SkillIDSet* pkReplacedSkills)
{
	if (m_pAssignedBuddyInstance == NULL)
		return false;

	//更新至客户端
	UpdateDirtyFlag(DIRTY_FLAG_SKILLASSET);
	return m_pAssignedBuddyInstance->LearnSkill( lSkillID, iSlotIdx, true, runeSystemType, runeSystemParam, pkReplacedSkills );
}

//------------------------------------------------------------------------
void LC_ServerPlayer::ActivePassiveSkill()
{
	//激活指挥官级别的所有被动技能
	LC_SkillAsset* skilldata = this->GetControllerSkillAsset();
	if (skilldata == NULL)
	{
		return;
	}
	const LC_SkillAssetEntryMap& kSkillAssetEntryMap = skilldata->GetSkillAssetData()->GetSkillAssetEntryMap();
	LC_SkillAssetEntryMap::const_iterator cit = kSkillAssetEntryMap.begin();
	for (; cit != kSkillAssetEntryMap.end(); ++cit)
	{
		const LC_SkillAssetEntry& kAssetEntry = cit->second;
		if (!kAssetEntry.GetValid())
		{
			continue;
		}
		SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(kAssetEntry.GetTypeID());
		if (pkSkillExecute == NULL)
		{
			continue;
		}
		CF_SkillSpecialAttrib::DataEntry* pkSkillAttrib = pkSkillExecute->GetAttrDataEntryPtr();
		CF_SkillExecuteList::DataEntry* pkSkillData = pkSkillExecute->GetDataEntryPtr();
		if (pkSkillData->_lPosNegType != SPNT_NEGTIVE)
		{
			continue;
		}
		if (pkSkillExecute->HasPassive())
		{
			pkSkillExecute->StartPassive(this);
		}
		else
		{
			this->ActiveSkillStateToAllBuddyInstance(pkSkillAttrib->_lSkillConstParameter1, 0, this->GetID(), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter2), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter3), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter4), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter5), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter6));
		}
	}
}
//------------------------------------------------------------------------
ResultType LC_ServerPlayer::CheckWriteMail(Protocol::PS_WriteMailInfo& kWriteMail, int64_t& iPostage)
{
	if (!IsInstance())
	{
		return RE_FAIL;
	}
	if (kWriteMail.lReceiverCharID == GetInstance())
	{
		return RE_WRITEMAIL_FAIL_TO_SELF;
	}
	if (TPSTReqSTDSTR(kWriteMail.szReceiverCharName, m_kCharName_gb) == true)
	{
		return RE_WRITEMAIL_FAIL_TO_SELF;
	}
	if (kWriteMail.lReceiverCharID > 0)
	{
		if (CheckName(kWriteMail.lReceiverCharID))
		{
			return RE_WRITEMAIL_FAIL_RECEIVER_IS_FORBIDDEN;
		}
		LC_PlayerBase* pkTargetPlayer = (SERVER_GET_PLAYER_MANAGER())->FindPlayer(kWriteMail.lReceiverCharID);
		if (pkTargetPlayer && pkTargetPlayer->CheckName(GetInstance()))
		{
			return RE_WRITEMAIL_FAIL_SELF_IS_FORBIDDEN;
		}
	}

	//物品是否绑定
	for (int i = 0; i < MAIL_ITEM_AFFIX_NUM; ++i)
	{
		if (kWriteMail.aItemAffix[i].bValid)
		{
			LC_BackPackEntry* pkBackPackEntry = GetPackAsset()->GetBackPackEntry(kWriteMail.aItemAffix[i].iPackType, kWriteMail.aItemAffix[i].iIndex);
			if (!pkBackPackEntry || !pkBackPackEntry->GetBackPackValueByType(LPSFET_VALID))
			{
				return RE_WRITEMAIL_FAIL_CANT_FIND_ITEM;
			}
			if (pkBackPackEntry->GetBackPackValueByType(LPSFET_BINDMODE))
			{
				return RE_WRITEMAIL_FAIL_ITEM_IS_BIND;
			}
		}
	}
	iPostage = 0;
	int iItemAffixNum = 0;
	for (int i = 0; i < MAIL_ITEM_AFFIX_NUM; ++i)
	{
		if (kWriteMail.aItemAffix[i].bValid)
		{
			++iItemAffixNum;
		}
	}
	// 邮件无附件
	if (0 == iItemAffixNum)
	{
		// 不寄钱的基本费用(文本邮件)
		if (kWriteMail.m_llMoney <= 0)
		{
			CF_MailCharge::DataEntry* pkDataEntry = CF_MailCharge::GetSingletonPtr()->GetEntryPtr(1);
			if (pkDataEntry)
			{
				iPostage = pkDataEntry->_lCost;
			}
		}
		// 寄钱的邮件费用
		else
		{
			CF_MailCharge::DataEntry* pkDataEntry = CF_MailCharge::GetSingletonPtr()->GetEntryPtr(21);
			if (pkDataEntry)
			{
				iPostage = pkDataEntry->_lCost;
			}
		}
	}
	// 有附件的邮件，已包含寄钱费用
	else
	{
		int iIndex = 10 + iItemAffixNum;
		CF_MailCharge::DataEntry* pkDataEntry = CF_MailCharge::GetSingletonPtr()->GetEntryPtr(iIndex);
		if (pkDataEntry)
		{
			iPostage = pkDataEntry->_lCost;
		}
	}

	if (!IS_VALID_MAIL_MONEY(iPostage))
	{
		return RE_WRITEMAIL_FAIL_CHARGE_NOT_ENOUGH;
	}

	if (!IsCashEnough(iPostage, CT_UNBIND_CASH))
	{
		return RE_WRITEMAIL_FAIL_CHARGE_NOT_ENOUGH;
	}

	MoneyType llMoneyAffix = kWriteMail.m_llMoney;
	if (!IS_VALID_MAIL_MONEY(llMoneyAffix))
	{
		return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
	}

	// 寄钱
	if (!kWriteMail.bIsPay)
	{
		if (!IsCashEnough(llMoneyAffix, CT_UNBIND_CASH))
		{
			return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
		}
		if (!IsCashEnough(llMoneyAffix + iPostage, CT_UNBIND_CASH))
		{
			return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
		}
	}
	return RE_WRITEMAIL_SUCCESS;
}

void LC_ServerPlayer::GetBuddyPresentElem(mem::vector<int>& elemVec)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->GetBuddyPresentElem(elemVec);
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer)
			continue;
		elemVec.push_back(pResultPlayer->GetDamageElementType());
	}
}

DamageElementType LC_ServerPlayer::GetDamageElementType()
{
	if (m_pAssignedBuddyInstance == NULL)
		return eDamageElementType_0;

	return m_pAssignedBuddyInstance->GetDamageElementType();
}

// ------------------------------------------------------------------------
ResultType LC_ServerPlayer::WriteMail(Protocol::PS_WriteMailInfo& kWriteMail, Protocol::PS_MailInfo& kMailInfo)
{
	if (!IsInstance())
	{
		return RE_FAIL;
	}

	//如果正在发送的邮件还未处理完，那么目前的邮件不能发送，让玩家等待
	MoneyType iPostage = 0;

	// 判断能否发送邮件，并获取发送邮件所需的邮资
	ResultType iResult = CheckWriteMail(kWriteMail, iPostage);

	if (iResult != RE_WRITEMAIL_SUCCESS)
	{
		return iResult;
	}

	if (iPostage < 0)
	{
		return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
	}
	kMailInfo.lMailID			= INVALID_MAIL_ID;
	kMailInfo.m_llMoney			= kWriteMail.m_llMoney;
	kMailInfo.lReceiverCharID	= kWriteMail.lReceiverCharID;
	kMailInfo.m_iTimestamp		= 0;
	kMailInfo.bReadFlag			= false;
	kMailInfo.bUntreadFlag		= false;
	kMailInfo.szSubject = kWriteMail.szSubject;
	kMailInfo.szContent = kWriteMail.szContent;
	TPSTR2STDSTR(GetOwnerCharName(), kMailInfo.szSenderCharName);
	kMailInfo.szReceiverCharName = kWriteMail.szReceiverCharName;

	bool bmoney = true;
	// 附件物品写入邮件
	for (int i = 0; i < MAIL_ITEM_AFFIX_NUM; ++i)
	{
		Protocol::PS_MailItemAffix& kItemAffix = kWriteMail.aItemAffix[i];
		if (kItemAffix.bValid)
		{
			LC_BackPackEntry* pkBackPackEntry = GetPackAsset()->GetBackPackEntry(kItemAffix.iPackType, kItemAffix.iIndex);
			if (pkBackPackEntry)
			{
				int iPackType = GetWhichPackAutoPut(pkBackPackEntry->GetBackPackValueByType(LPSFET_TYPE_ID));
				GetPackAsset()->UpdateDirtyFlag(iPackType);
				pkBackPackEntry->SetToProtocol(kMailInfo.aItemAffix[i], true);
				//目前，直接删除
				pkBackPackEntry->Reset();
			}
		}
		else
		{
			if (!kWriteMail.bIsPay && kWriteMail.m_llMoney > 0 && bmoney)
			{
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_VALID, 1);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_LOCKED, 1);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_TYPE_ID, SPEC_ITEM_TID_CASH);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_OVERLAP_COUNT, (int32_t)kWriteMail.m_llMoney);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_UNIQUE_ID_0, GetInstanceCitizen());
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_UNIQUE_ID_1, GetInstanceCharID());
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_UNIQUE_ID_2, SPEC_ITEM_TID_CASH);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_UNIQUE_ID_3, 1);
				kMailInfo.aItemAffix[i].SetPropertyValue(LPSFET_UNIQUE_ID_4, 1);
				bmoney = false;
				kMailInfo.m_llMoney = 0;
			}
		}
	}

	// 附件加入金钱
	MoneyType llMoneyAffix = kWriteMail.m_llMoney;
	if (!IS_VALID_MAIL_MONEY(llMoneyAffix))
	{
		return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
	}
	if (!IS_VALID_MAIL_MONEY(iPostage))
	{
		return RE_WRITEMAIL_FAIL_CASH_NOT_ENOUGH;
	}
	// 扣邮资
	ReduceCash(iPostage, CT_UNBIND_CASH, SYS_FUNC_TP_MAIL_SEND, INVALID_MAIL_ID);
	// 处理金钱附件
	if (kWriteMail.bIsPay)
	{
		kMailInfo.bPayFlag = MAIL_NEED_PAY;
	}
	else
	{
		kMailInfo.bPayFlag = MAIL_NO_PAY;
		if (llMoneyAffix > 0)
		{
			// 扣除钱币
			ReduceCash(llMoneyAffix, CT_UNBIND_CASH, SYS_FUNC_TP_MAIL_PAY, INVALID_MAIL_ID);
		}
	}
	// 邮件类型
	kMailInfo.bMailType = MAIL_TYPE_NORMAL;

	return RE_WRITEMAIL_SUCCESS;
}
//---------------------------------------------------------------------------------------
void LC_ServerPlayer::AccumulateMoveDistance(const UT_Vec3Int& rkClientSyncLocation)
{
	int iMoveDistance = UT_MathBase::LineLengthXYInt(rkClientSyncLocation, m_kCurrentLocation);
	m_lAccumulateMoveDistance += iMoveDistance;
}
//---------------------------------------------------------------------------------------
int LC_ServerPlayer::GetAccumulateMoveDistance()
{
	return m_lAccumulateMoveDistance;
}
//---------------------------------------------------------------------------------------
void LC_ServerPlayer::ClearAccumulateMoveDistance()
{
	m_lAccumulateMoveDistance = 0;
}
//---------------------------------------------------------------------------------------
bool LC_ServerPlayer::CheckSkillValid(CSVFile::CF_SkillSpecialAttrib::DataEntry* pkSkillData, int lItemID)
{
	if (!LC_PlayerBase::CheckSkillValid(pkSkillData, lItemID))
	{
		return false;
	}

	CF_SkillExecuteList::DataEntry *pkSkillInfo = LC_Helper::SafeGetSkillExecuteDataEntryPtr(pkSkillData->_iID);
	if(!pkSkillInfo)
	{
		return false;
	}

	if (IS_ITEM_TRIGGER_SKILL_CATEGORY(pkSkillInfo->_lCategory1))
	{
		if (!IS_ITEM_ID(lItemID))
		{
			return false;
		}
		CF_ItemList* pkItemList = CF_ItemList::GetSingletonPtr();
		CF_ItemList::DataEntry* pkItemData = pkItemList->GetEntryPtr(lItemID);
		if (NULL == pkItemData)
		{
			return false;
		}
		if (pkItemData->_lUseTriggerSkillTypeID != pkSkillData->_iID)
		{
			return false;
		}
		ResultType iResult = LC_Helper::CanDeleteItem(&m_kPackAsset, lItemID, 1);
		if (RE_FAIL == iResult)
		{
			return false;
		}
	}
	return true;
}

//---------------------------------------------------------------------------------------
void LC_ServerPlayer::_updatePairSitRecover(float fCurrentTime)
{
	float match_time = GetStartMatchPairSitRecoverTime();
	if (match_time > 0.0f)
	{
		if (fCurrentTime > (match_time + 10.f))
		{
			SetStartMatchPairSitRecoverTime(0.0f);
		}
	}
	else
	{
		object_id_type pid = GetPairSitRecoverID();
		if (0 == pid)
		{
			return;
		}
		int skillid = GetCurrentStateType();
		if (skillid != SKILL_DOUBLE_MEDITATION)
		{
			SetPairSitRecoverID(0);
			return;
		}
		LC_MapBase* map = GetMap();
		LC_ServerPlayer* tplayer = (LC_ServerPlayer*)map->FindObject(pid);
		if (NULL == tplayer)
		{
			SetPairSitRecoverID(0);
			return;
		}
		if (tplayer->GetPairSitRecoverID() != GetID())
		{
			SetPairSitRecoverID(0);
			return;
		}
		int pdistance = UT_MathBase::LineLengthXYInt(GetCurrentLocation(), tplayer->GetCurrentLocation());
		if (pdistance > 500)
		{
			SetPairSitRecoverID(0);
			return;
		}
		skillid = tplayer->GetCurrentStateType();
		if (skillid != SKILL_DOUBLE_MEDITATION)
		{
			SetPairSitRecoverID(0);
			return;
		}
	}
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::HeartBeat(void)
{
	if (!IsInstance())
	{
		return;
	}
	++m_iHeartBeatCount;
	m_fLastHeartBeatTime = GET_PROCESS_TIME;
	if (0 == (m_iHeartBeatCount % 2))
	{
		SendMsgToLogin(MGPT_SS_USER_HEARTBEAT, NULL, m_dwUserID, GetInstance(), 0, GetGateWayServerID(this));
		SendMsgToMailDB(MGPT_SS_USER_HEARTBEAT, NULL, m_dwUserID, GetInstance());
		SendMsgToSociety(MGPT_SS_USER_HEARTBEAT, NULL, m_dwUserID, GetInstance());
		SendMsgToTrade(MGPT_SS_USER_HEARTBEAT, NULL, m_dwUserID, GetInstance());
		SendMsgToChat(MGPT_SS_USER_HEARTBEAT, NULL, m_dwUserID, GetInstance(), GetCitizenship(), GetGateWayServerID(this));
	}
}

void LC_ServerPlayer::SendGameEvent(GameLogic::LC_GameEvent* pkEvent , bool bSendName)
{
	if (NULL == pkEvent)
	{
		return;
	}
	int lNoticeType = (int)pkEvent->GetEventParam(EVENT_SEND_TYPE_PARAM);
	_SyncEventRelatedData(pkEvent);
	if (lNoticeType == GENT_SELF)
	{
		_sendEventToSelf(pkEvent, bSendName);
	}
	else if (lNoticeType == GENT_GROUP)
	{
		_sendEventToGroup(pkEvent, bSendName);
	}
	else if (lNoticeType == GENT_AREA)
	{
		_sendEventToArea(pkEvent, bSendName);
	}
	else if (lNoticeType == GENT_WORLD)
	{
		_sendEventToWorld(pkEvent, bSendName);
	}
}

void LC_ServerPlayer::_sendEventToSelf(GameLogic::LC_GameEvent* pkEvent , bool bSendName)
{
	MG_PB<msg_define::game_event> EventMsg;
	msg_define::game_event& msg_val = EventMsg.m_value;
	pkEvent->SetToProtocol(msg_val);
	if (bSendName)
	{

		msg_val.set_string_param(TPSTR2STDSTR(GetOwnerCharName()));
	}
	SendMsgToClient(MGPT_RLT_GAME_EVENT, &EventMsg);
}

void LC_ServerPlayer::_sendEventToGroup(GameLogic::LC_GameEvent* pkEvent , bool bSendName)
{
	LC_ServerPlayerGroup* pkGroup = (LC_ServerPlayerGroup*)GetPlayerGroup();
	if (NULL == pkGroup)
	{
		return;
	}
	MG_PB<msg_define::game_event> EventMsg;
	msg_define::game_event& msg_val = EventMsg.m_value;
	pkEvent->SetToProtocol(msg_val);
	if (bSendName)
	{
		msg_val.set_string_param(TPSTR2STDSTR(GetOwnerCharName()));
	}
	pkGroup->BroadCast(MGPT_RLT_GAME_EVENT, &EventMsg);
}

void LC_ServerPlayer::_sendEventToArea(GameLogic::LC_GameEvent* pkEvent , bool bSendName)
{
	LC_MapBase* pkMap = GetMap();
	if (NULL == pkMap)
	{
		return;
	}
	SectorIndex dwSectorIndex = GetSectorIndex();
	LC_ServerSector* pkCenterSector = (LC_ServerSector*)pkMap->GetSector(dwSectorIndex);
	if (NULL == pkCenterSector)
	{
		return;
	}
	MG_PB<msg_define::game_event> EventMsg;
	msg_define::game_event& msg_val = EventMsg.m_value;
	pkEvent->SetToProtocol(msg_val);
	if (bSendName)
	{
		msg_val.set_string_param(TPSTR2STDSTR(GetOwnerCharName()));
	}
	SectorIndexSet& kAroundIndex = pkCenterSector->GetSectorNeighborIndexSet();
	SectorIndexSetIter IterBe = kAroundIndex.begin();
	SectorIndexSetIter IterEd = kAroundIndex.end();
	for (; IterBe != IterEd; ++IterBe)
	{
		LC_ServerSector* pkSector = (LC_ServerSector*)pkMap->GetSector(*IterBe);
		if (NULL == pkSector)
			continue;

		pkSector->BroadCast(MGPT_RLT_GAME_EVENT, &EventMsg);
	}
}

void LC_ServerPlayer::_sendEventToWorld(GameLogic::LC_GameEvent* pkEvent , bool bSendName)
{
	MG_PB<msg_define::game_event> EventMsg;
	msg_define::game_event& msg_val = EventMsg.m_value;
	pkEvent->SetToProtocol(msg_val);
	if (bSendName)
	{
		msg_val.set_string_param(TPSTR2STDSTR(GetOwnerCharName()));
	}
	LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	pkPlayerManager->BroadCast(MGPT_RLT_GAME_EVENT, &EventMsg);
}

void LC_ServerPlayer::_SyncEventRelatedData(GameLogic::LC_GameEvent* pkEvent)
{
	if (NULL == pkEvent)
	{
		return;
	}
	if (pkEvent->GetEventType() == GLET_ADD_ITEM)
	{
		CheckAndSyncPackInfo(GET_PROCESS_TIME);
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SyncPlayerEnterFOVToClient()
{

}

void LC_ServerPlayer::SyncSocietyDynamicInfo()
{
	LC_SocietyAsset* pkSocietyAsset = GetSocietyAsset();

	const unique_id_set& ids = pkSocietyAsset->GetDirtyIDs();
	//sync
	MG_SyncSocietyDynmicInfo kSyncMsg;

	static LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	unique_id_set::const_iterator it = ids.begin();
	for (int i = 0; it != ids.end(); ++it, ++i)
	{
		PS_SocietyBasicInfo kBaseInfo;
		LC_SocietyBasicInfo* pkBasicInfo = pkSocietyAsset->GetSocietyInfo(*it);
		if (NULL == pkBasicInfo)
		{
			continue;
		}
		kBaseInfo.uiCharID = *it;
		LC_ServerPlayer* pTargetPlayer = static_cast<LC_ServerPlayer*>(pkPlayerManager->FindPlayer(*it));
		if (pTargetPlayer)
		{
			kBaseInfo.iStatus = 1;
			TPSTR2STDSTR(pTargetPlayer->GetOwnerCharName(), kBaseInfo.szCharName);
			kBaseInfo.iLevel = pTargetPlayer->GetLevel();
		}
		else
		{
			kBaseInfo.iStatus = 0;
			TPSTR2STDSTR(pkBasicInfo->GetCharName(), kBaseInfo.szCharName);
			kBaseInfo.iLevel = pkBasicInfo->GetLevel();
		}

		kBaseInfo.iCareer = pkBasicInfo->GetCareer();
		kBaseInfo.iCharType = pkBasicInfo->GetCharType();
		kBaseInfo.iWeaponType = pkBasicInfo->GetWeaponType();
		kBaseInfo.iScore = pkBasicInfo->GetScore();
		kBaseInfo.iBornCharType = pkBasicInfo->GetBornCharType();
		kBaseInfo.uiDegree = pkBasicInfo->GetDegree();
		kBaseInfo.beFriendWithEachOther = GetSocietyAsset()->IsInBeSociety(ST_FRIEND, kBaseInfo.uiCharID);
		kSyncMsg.m_kPlayerList.push_back(kBaseInfo);
	}
	SendMsgToClient(MGPT_SYNC_SOCIETY_DYNAMIC_INFO, &kSyncMsg);
	pkSocietyAsset->UpdateDirtyIDs();
}
void LC_ServerPlayer::ShareMultiuserTaskToGroup(int lTaskID)
{
}
//------------------------------------------------------------------------
void LC_ServerPlayer::ShareNormalTaskToGroup(int lTaskID)
{
	if (!IsInstance())
	{
		return;
	}
	LC_PlayerGroupBase* pkGroup = GetPlayerGroup();
	if (pkGroup == NULL)
	{
		return;
	}
	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	if (pkTaskManager == NULL)
	{
		return;
	}
	LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
	if (pkTask == NULL)
	{
		return ;
	}
	for (int i = 0; i < MAX_PLAYER_GROUP_MEMBER_LIST_SIZE; i++)
	{
		ResultType iResultType = RE_SUCCESS;
		LC_PlayerGroupEntry* pkMember = pkGroup->GetGroupEntryInMemberList(i);
		if (pkMember == NULL)
		{
			continue;
		}
		if (pkMember->GetValid() && pkMember->GetPlayer())
		{
			//发送网络应答
			LC_ServerPlayer* pkGroupPlayer = (LC_ServerPlayer*)pkMember->GetPlayer();
			if (pkGroupPlayer == NULL)
			{
				continue;
			}
			if (GetID() ==  pkGroupPlayer->GetID())
			{
				continue;
			}
			do
			{
				if (GetMapLogicID() != pkGroupPlayer->GetMapLogicID())
				{
					iResultType = RE_TASK_SHARE_NOT_IN_RANGE;
					break;
				}
				if (pkGroupPlayer->GetTaskMap()->GetPrcessingTaskCount() >= MAX_TASK_PROCESSING_COUNT)
				{
					iResultType = RE_TASK_SHARE_TASK_IS_FULL;
					break;
				}
				if (pkGroupPlayer->GetTaskMap()->IsInProcessingTaskMap(lTaskID))
				{
					iResultType = RE_TASK_SHARE_TASK_IS_PROCESS;
					break;
				}
				if (pkGroupPlayer->GetTaskMap()->IsInFinishedTaskMap(lTaskID))
				{
					iResultType = RE_TASK_SHARE_TASK_IS_FINISH;
					break;
				}
				iResultType = pkTask->CanStart(pkGroupPlayer);
				if (iResultType == RE_TASK_START_SUCCESS)
				{
					iResultType = RE_SUCCESS;
				}
				else
				{
					iResultType = RE_TASK_SHARE_CANT_ACCEPT_TASK;
				}

			}
			while (0);

			MG_RLT_ShareTask rltMsg;
			rltMsg.m_lResponderID =  pkGroupPlayer->GetID();
			rltMsg.m_lTaskID = lTaskID;
			rltMsg.m_lPublisherID = GetID();
			rltMsg.m_iResult = iResultType;
			TPSTR2STDSTR(GetOwnerCharName(), rltMsg.m_strPublisherName);
			TPSTR2STDSTR(pkGroupPlayer->GetOwnerCharName(), rltMsg.m_strResponderName);
			SendMsgToClient(MGPT_RLT_SHARE_TASK, &rltMsg);
			pkGroupPlayer->SendMsgToClient(MGPT_RLT_SHARE_TASK, &rltMsg);
		}
	}
}
//------------------------------------------------------------------------
//------------------------------------------------------------------------
void LC_ServerPlayer::ClearAssignTask(uint32_t uiAssignType)
{
	if (!IsInstance())
	{
		return;
	}
	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	if (NULL == pkTaskManager)
	{
		return;
	}
	if (NULL == m_pkTaskMap)
	{
		return;
	}
	LC_AssignTaskInfo* pkAssignInfo = m_pkTaskMap->GetAssignTaskInfo();

	if (pkAssignInfo->IsTaskAssigned(uiAssignType) == false)
	{
		return;
	}
	LC_TaskAssignEntry* pkEntry = pkTaskManager->GetTaskAssignEntry(uiAssignType);
	if (NULL == pkEntry)
	{
		return;
	}
	LC_ServerTaskMap* pkServerTaskMap = (LC_ServerTaskMap*)m_pkTaskMap;
	pkServerTaskMap->ClearAllTaskRecordOfType(pkEntry->_iTaskType, false);
	pkAssignInfo->ClearAssignTask(uiAssignType);
}
//------------------------------------------------------------------------
ResultType LC_ServerPlayer::CancleTaskOP(int lTaskID, int cancelType)
{
	if (!IsInstance())
	{
		return RE_FAIL;
	}

	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if (pkTaskManager == NULL)
	{
		return RE_FAIL;
	}

	LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
	if (pkTask == NULL)
	{
		return RE_FAIL;
	}

	ResultType iCancelResult = RE_SUCCESS;
	if (pkTask->IsGuildRelated() && !IsGetGuildData())
	{
		iCancelResult = RE_FAIL;
	}
	else
	{
		LC_TaskMap* pkTaskMap = GetTaskMap();
		if (pkTaskMap && pkTaskMap->IsInProcessingTaskMap(lTaskID) == false)
		{
			pkTaskMap->ClearTaskFail(lTaskID, pkTask->GetTaskIndex());
		}

		uint32_t uiAssignType = pkTaskManager->GetAssignType(pkTask->GetTaskType());
		LC_TaskAssignEntry* pkEntry = pkTaskManager->GetTaskAssignEntry(uiAssignType);

		if (pkEntry && pkEntry->_iCanCancel <= 0)
		{
			iCancelResult = RE_FAIL;
		}
		else
		{
			iCancelResult = CancelTask(lTaskID);
			if (iCancelResult == RE_TASK_CANCEL_SUCCESS)
			{
				if (cancelType == TCT_FAIL)
				{
					LC_TaskMap* pkTaskMap = GetTaskMap();
					if (pkTaskMap)
					{
						pkTaskMap->RecordTaskFail(lTaskID, pkTask->GetTaskIndex());
					}
				}
			}
		}
	}

	return iCancelResult;
}

void LC_ServerPlayer::AcceptTaskOP(int lTaskID, bool bManual)
{
	MG_RLT_AcceptTask rltMsg;
	rltMsg.m_lPlayerID = GetID();
	rltMsg.m_lTaskID = lTaskID;
	rltMsg.m_iResult = RE_ACCEPTTASK_ERORR_2;

	const unique_id_impl& instance = GetInstance();
	LC_TaskMap* pkTaskMap = GetTaskMap();
	if (pkTaskMap == NULL)
	{
		SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);

		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "AcceptTaskOP pkTaskMap is null! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			lTaskID, instance.detail(), instance.catagory(), GetUserID());
		return;
	}

	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
	if (pkTask == NULL)
	{
		SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);

		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "AcceptTaskOP not find lTaskID! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			lTaskID, instance.detail(), instance.catagory(), GetUserID());
		return;
	}

	rltMsg.m_iResult = CheckCanAccpetTask(pkTask);
	if(RE_SUCCESS != rltMsg.m_iResult)
	{
		SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "AcceptTaskOP CheckCanAccpetTask error! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, result:%d",
			lTaskID, instance.detail(), instance.catagory(), GetUserID(), rltMsg.m_iResult);
		return;
	}

	//判断接取任务需要的道具是否足够
	ResultType iStartResult = RE_SUCCESS;
	Utility::UT_SIMDataList kRawItems;
	Utility::ParseFmtString2DataIFs(pkTask->GetConsumeItem(), kRawItems);
	for(Utility::UT_SIMDataList::iterator it=kRawItems.begin(); it!=kRawItems.end(); ++it)
	{
		iStartResult = TryDeleteItem(it->GetItemId(), it->GetItemNum());
		if(RE_SUCCESS != iStartResult)
		{
			rltMsg.m_iResult = RE_REWARD_TASK_ITEM_NOT_ENOUGH;
			SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " AcceptTaskOP TryDeleteItem error! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, result:%d",
				lTaskID, instance.detail(), instance.catagory(), GetUserID(), iStartResult);
			return;
		}
	}

	LC_TaskTypeDataEntry* pkTypeDataEntry = pkTaskManager->GetTaskTypeDataEntry(pkTask->GetTaskType());
	if ((pkTask->GetTaskType()!= STT_REWARD_TASK&&pkTask->GetTaskType()!=STT_GAMESTORY) && pkTypeDataEntry && bManual && pkTypeDataEntry->_iManualDisable)
	{
		rltMsg.m_iResult = RE_FAIL;
		SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " AcceptTaskOP error! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, taskType:%d",
			lTaskID, instance.detail(), instance.catagory(), GetUserID(), pkTask->GetTaskType());
		return;
	}

	int lGameStoryID = pkTask->GetGameStoryID();
	if (lGameStoryID > 0)
	{
		iStartResult = SERVER_GET_GAMESTORY_MANAGER->CheckGameStoryEnterCondition(this, lGameStoryID);
	}
	if (iStartResult == RE_SUCCESS)
	{
		iStartResult = AcceptTask(lTaskID);
	}
	if (iStartResult == RE_TASK_START_SUCCESS)
	{
		if (lGameStoryID > 0)
		{
			GameStory::LC_StoryLogic_Manager* pkGameStoryManager = SERVER_GET_STORYLOGIC_MANAGER;
			if (pkGameStoryManager)
			{
				pkGameStoryManager->OnAcceptTask(this, pkTask);
			}
		}

		NoticeAcceptTask(pkTask);

		for(Utility::UT_SIMDataList::iterator it=kRawItems.begin(); it!=kRawItems.end(); ++it)
		{
			DeleteItem(it->GetItemId(), it->GetItemNum());
		}

		oss_role_task_start(this, pkTask, NULL, NULL);
		oss_360_log_task( pkTask->GetTaskID(), eOssLogTaskType_Start, this );
		LC_TaskMap* pkTaskMap = GetTaskMap();
		if (pkTaskMap)
		{
			pkTaskMap->ClearTaskFail(lTaskID, pkTask->GetTaskIndex());
		}

		if (GetLoginCount()==1 && pkTask->GetPreTaskID()<=0 && STT_MAIN_SCENARIO==pkTask->GetTaskType())
		{
			oss_login_step(GetCitizenship(), GetUserName(), EVENT_SERVER_REQ_ACCEPT_1st_TASK, GetPlayerPlatformType(), iStartResult);
		}
	}
	rltMsg.m_iResult = iStartResult;
	SendMsgToClient(MGPT_RLT_ACCEPT_TASK, &rltMsg);
}
//------------------------------------------------------------------------
ResultType LC_ServerPlayer::FinishTaskOP(int lTaskID, int iBonusMulti, bool bGoldenFinger/*=false*/)
{
	const unique_id_impl& instance = GetInstance();
	LC_TaskManager* pkTaskManager = LC_TaskManager::GetSingletonPtr();
	LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
	if (pkTask == NULL)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FinishTaskOP pkTask id null! lTaskID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d",
			lTaskID, instance.detail(), instance.catagory(), GetUserID());
		return RE_FAIL;
	}

	MG_RLT_FinishTask rltMsg;
	rltMsg.m_lPlayerID = GetID();
	rltMsg.m_lTaskID = lTaskID;
	rltMsg.m_iBonusItemIndex = -1;

	ResultType iFinishResult = FinishTask(lTaskID, iBonusMulti, bGoldenFinger);
	if (iFinishResult == RE_TASK_FINISH_SUCCESS)
	{
		if (pkTask->GetGameStoryID() > 0)
		{
			GameStory::LC_StoryLogic_Manager* pkGameStoryManager = SERVER_GET_STORYLOGIC_MANAGER;
			if (pkGameStoryManager)
			{
				pkGameStoryManager->OnFinishTask(this, pkTask);
			}
		}
		LC_TaskMap* pkTaskMap = GetTaskMap();
		if (pkTaskMap)
		{
			pkTaskMap->ClearTaskFail(lTaskID, pkTask->GetTaskIndex());

			UpdateTaskReachRecord(lTaskID);

			AddTaskHonorPoint(pkTask->GetChaptersPoint());

			//同步任务荣誉点数据
			SyncControllerPropertyToClient();		

			//限时活动事件
			TimeLimitEvent actEvent;
			actEvent.taskID = lTaskID;
			TimeLimitInfoEvent(actEvent);

			//更新任务章节完成进度
			TaskChapterRewardOP(pkTask->GetTaskGroupID());
		}

		//完成前置任务，要派发角色传记任务
		if(IsBiographyPreTask(lTaskID))
		{
			LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
			if(m_kOpenAbilityAsset.IsAbilityEnabled(LC_ABT_TASK, STT_BIOGRAPHY_TASK))
			{
				pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_BIOGRAPHY_TASK), false, PRETASK_ASSIGN, lTaskID);
			}
		}
	}
	rltMsg.m_iResult = iFinishResult;
	float currentTime = GET_PROCESS_TIME;
	SendMsgToClient(MGPT_RLT_FINISH_TASK, &rltMsg);
	SyncProcessingTaskMapToClient();

	return iFinishResult;
}
//完成任务
ResultType LC_ServerPlayer::FinishTask(int lTaskID, int iBonusMulti, bool bGoldenFinger)
{
	//OSS使用，临时
	int64_t lCurrentEXP = GetEXP();
	int64_t lUnbindCash = GetUnBindCash().GetMoney();
	attr_value_type lSp = GetSkillLevelupPoints();

	ResultType rslt = LC_PlayerBase::FinishTask(lTaskID, iBonusMulti, bGoldenFinger);
	if (RE_TASK_FINISH_SUCCESS == rslt)
	{
		LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
		LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
		uint32_t uiAssignType = pkTaskManager->GetAssignType(pkTask->GetTaskType());
		LC_TaskTypeDataEntry* pkTypeDataEntry = pkTaskManager->GetTaskTypeDataEntry(pkTask->GetTaskType());
		LC_TaskAssignEntry* pkEntry = pkTaskManager->GetTaskAssignEntry(uiAssignType);
		if (pkEntry)
		{
			pkTaskManager->ReplaceAssignTask(this, uiAssignType, lTaskID);
		}
		if (pkTypeDataEntry)
		{
			LC_CommonStatAsset& kCommonStatAsset = GetCommonStatAsset();
			LC_CommonStatEntry* pkCommonStatEntry = kCommonStatAsset.GetCommonStatEntry(pkTypeDataEntry->_iCommonStatID);
			if (pkCommonStatEntry)
			{
				pkCommonStatEntry->SetStatEntry(LC_CMN_STAT_ENTRY_KEY_DAY_FINISH, pkCommonStatEntry->GetStatEntry(LC_CMN_STAT_ENTRY_KEY_DAY_FINISH) + 1);
				kCommonStatAsset.ToRegFire(pkTypeDataEntry->_iCommonStatID, lTaskID);
			}
		}

		//检查绝技系统
		//GetGreatKungFuAsset().CheckKungFu(this);
		GetOpenAbilityAsset().OnTaskFinished(lTaskID);
		Activity::ACT_ScheduleDataManager* pkACTDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
		if (NULL != pkACTDataMgr)
		{
			pkACTDataMgr->OnTaskFinished(this, pkTask);
			if(pkTask->GetTaskFinishScheduleID())//非活动任务不更新进度
				pkACTDataMgr->OnFinishTaskAndAchievement(this, 1, lTaskID);
		}

		AchievementEvent kEvent;
		kEvent.SetConditionInfo(pkTask->GetTaskType());
		kEvent.SetNum(1);
		UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_FINISH_TASK_COUNT, kEvent);

		LC_BackPackEntryPtrList blist;
		make_new_item_info(blist, this);
		oss_role_task_finished(this, pkTask, blist, NULL, int32_t(GetUnBindCash().GetMoney() - lUnbindCash), (int32_t)(GetEXP() - lCurrentEXP), (int32_t)(GetSkillLevelupPoints() - lSp));
		oss_360_log_task(pkTask->GetTaskID(), eOssLogTaskType_Finish, this);
		BuddyChain_CalcCount();
	}
	return rslt;
}

//取消任务
ResultType LC_ServerPlayer::CancelTask(int lTaskID)
{
	ResultType rslt = LC_PlayerBase::CancelTask(lTaskID);
	if (RE_TASK_CANCEL_SUCCESS == rslt)
	{
		LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
		LC_Task* pkTask = pkTaskManager->GetTask(lTaskID);
		uint32_t uiAssignType = pkTaskManager->GetAssignType(pkTask->GetTaskType());
		LC_TaskAssignEntry* pkEntry = pkTaskManager->GetTaskAssignEntry(uiAssignType);
		if(pkEntry)
		{
			if(pkTask->GetTaskType() == STT_REWARD_TASK)
			{
				ModifyAcceptRewardTaskTimes(false);
			}
			pkTaskManager->ReplaceAssignTask(this, uiAssignType, lTaskID);
		}
		oss_role_task_cancel(this, pkTask, NULL, NULL);
		oss_360_log_task(pkTask->GetTaskID(), eOssLogTaskType_Cancel, this);
	}
	return rslt;
}

bool LC_ServerPlayer::RemoveAssignTaskByTaskID(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->RemoveAssignTask(taskID);
}

bool LC_ServerPlayer::RemoveFinishTaskByTaskID(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->RemoveTaskFinishRecord(taskID);
}

void LC_ServerPlayer::RemoveTaskByTaskIDVec(mem::set<int32_t>& taskIDs)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RemoveTaskByTaskIDVec(taskIDs);
	}

	for(mem::set<int32_t>::iterator it=taskIDs.begin(); it!=taskIDs.end(); ++it)
	{
		bool tag = RemoveFinishTaskByTaskID(*it);
		if(false == tag)
		{
			tag = RemoveProcessingTaskByTaskID(*it);	
		}
		if(false == tag)
		{
			RemoveAssignTaskByTaskID(*it);
		}
	}
}

bool LC_ServerPlayer::AssignTaskByTaskIDVec(mem::set<int32_t>& taskIDs)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AssignTaskByTaskIDVec(taskIDs);
	}

	LC_ServerTaskManager* pkTaskMgr = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskMgr)
	{
		return false;
	}

	bool tag = false;
	for(mem::set<int32_t>::iterator it=taskIDs.begin(); it!=taskIDs.end(); ++it)
	{
		tag = pkTaskMgr->AssignTaskByTaskID(this, *it);
	}

	return tag;
}

bool LC_ServerPlayer::CheckAcceptTaskCondition(int taskSystem, int taskID)
{
	bool tag = UT_ServerHelper::CheckTaskMatch(taskSystem, taskID);
	if(!tag)
	{
		return true;
	}

	switch(taskSystem)
	{
	case TaskSystemType_Sky:
		tag = SERVER_GET_RANK_MANAGER()->IsInRankTime();
		break;
	default:
		break;
	}

	return tag;
}

ResultType LC_ServerPlayer::CheckCanAccpetTask(LC_Task* pkTask)
{
	if(NULL == pkTask)
	{
		return RE_FAIL;
	}

	//检测任务接取时间是否有效
	if(false == UT_ServerHelper::CheckActivityVaild(pkTask->GetTaskAcceptScheduleID()))
	{
		return RE_ACTIVITY_NOT_VALID;
	}

	ResultType iStartResult = RE_SUCCESS;

	//针对活动类型的特化检测
	//活动任务(押镖任务)
	if(pkTask->GetTaskType()==STT_GAMESTORY && UT_ServerHelper::IsEscortTask(pkTask->GetTaskID()))
	{
		iStartResult = CheckAcceptEscortTask();
		if(RE_SUCCESS != iStartResult)
		{
			return iStartResult;
		}
	}
	else if(pkTask->GetTaskType() == STT_REWARD_TASK)
	{
		//悬赏任务，判断悬赏任务接取次数
		int times = GetAcceptRewardTaskTimes();
		if(times==-1 || times>=GetGlobalSetting.AcceptRewardTaskTimes)
		{
			return RE_REWARD_TASK_ACCPETTASK_NOT_ENOUGH;
		}
	}
	else
	{
		bool tag = CheckAcceptTaskCondition(TaskSystemType_Sky, pkTask->GetTaskID());
		if(!tag)
		{
			return RE_FAIL;
		}
	}

	return iStartResult;
}

int32_t LC_ServerPlayer::GetMainTaskFinishCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetMainTaskFinishCount();
	}

	return m_nMainTaskFinishCount;
}

void LC_ServerPlayer::UpdateTaskReachRecord(int lTaskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateTaskReachRecord(lTaskID);
	}

	CF_TaskList::DataEntry* pkTaskData = SafeGetCSVFileDataEntryPtr<CF_TaskList>(lTaskID);
	if(NULL!=pkTaskData && pkTaskData->_iTaskType==STT_MAIN_SCENARIO)
	{
		++m_nMainTaskFinishCount;
		SetFinishMainTaskID(lTaskID);
	}
}

ResultType LC_ServerPlayer::MainTaskReachRewardOP(int lTaskReachID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->MainTaskReachRewardOP(lTaskReachID);
	}

	CF_TaskReachRewards::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TaskReachRewards>(lTaskReachID);
	if(NULL == pkData)
	{
		return RE_ERROR_PARAM;
	}

	bool flag = IsInMainTaskReachRewardRecord(lTaskReachID);
	if(flag)
	{
		return RE_MAIN_TASK_REACH_REWARD_ALREADY_GET;
	}

	if(GetMainTaskFinishCount() < pkData->_iTaskCounts)
	{
		return RE_MAIN_TASK_REACH_NOT_FINISH;
	}

	vector<int> nParams;
	nParams.clear();
	nParams.push_back(lTaskReachID);

	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, MAINTASK_OPERATE, OPERATE_LOGTYPE2);
	//发奖
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_kReward, this, SYS_FUNC_TP_GET_MAIN_TASK_REACH_REWARD, lTaskReachID, mailTitle, mailDesc, false,false,false, nLogCode,nParams);
	if(RE_SUCCESS == res)
	{
		//更新
		UpdateMainTaskRewardRecord(lTaskReachID);
	}

	return res;
}

bool LC_ServerPlayer::IsInMainTaskReachRewardRecord(int lTaskReachID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->IsInMainTaskReachRewardRecord(lTaskReachID);
	}

	return m_nMainTaskReachRewardRecord.find(lTaskReachID) != m_nMainTaskReachRewardRecord.end();
}

void LC_ServerPlayer::UpdateMainTaskRewardRecord(int lTaskReachID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateMainTaskRewardRecord(lTaskReachID);
	}

	m_nMainTaskReachRewardRecord.insert(lTaskReachID);
}

void LC_ServerPlayer::SyncMainTaskReachRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncMainTaskReachRecord();
	}

	MG_SyncMainTaskReachReward syncMsg;
	for(mem::set<int32_t>::iterator it=m_nMainTaskReachRewardRecord.begin(); it!=m_nMainTaskReachRewardRecord.end(); ++it)
	{
		syncMsg.m_nMainTaskReachRewardID.push_back(*it);
	}
	SendMsgToClient(MGPT_SYNC_MAINTASKREACHREWARD, &syncMsg);
}

void LC_ServerPlayer::CheckTaskChapterReward()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	CF_TaskChapters::DataEntryMapExternIterator it = CF_TaskChapters::GetSingletonPtr()->GetIterator();
	while(it.HasMoreElements())
	{
		CF_TaskChapters::DataEntry* pkData = it.PeekNextValuePtr();
		if(IsInFinishedTaskMap(pkData->_iEndTaskID) && !IsInTaskChapterReward(pkData->_iChapterID))
		{
			TaskChapterRewardOP(pkData->_iChapterID);
		}
		it.MoveNext();
	}
}

bool LC_ServerPlayer::IsInTaskChapterReward(int chapterID)
{
	if(NULL == m_pkTaskMap)
	{
		return false;
	}

	return m_pkTaskMap->IsInTaskChapterReward(chapterID);
}

ResultType LC_ServerPlayer::TaskChapterRewardOP(int chapterID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->TaskChapterRewardOP(chapterID);
	}

	CF_TaskChapters::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TaskChapters>(chapterID);
	if(NULL == pkData)
	{
		return RE_ERROR_PARAM;
	}

	bool flg = IsInTaskChapterReward(chapterID);
	if(flg)
	{
		return RE_CHAPTER_REWARD_HAS_TAKED;
	}

	int endTaskID = pkData->_iEndTaskID;
	bool flag = IsInFinishedTaskMap(endTaskID);
	if(!flag)
	{
		return RE_CHAPTER_NOT_FINISH;
	}

	//领奖
	if(!pkData->_kReward.empty())
	{
		ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_kReward, this, SYS_FUNC_TP_GET_TASK_CHAPTER_REWARD, pkData->_iChapterID, "184;", "185;");
		if(RE_SUCCESS != res)
		{
			return RE_FAIL;
		}
	}

	AddEXP(pkData->_iExp, SYS_FUNC_TP_GET_TASK_CHAPTER_REWARD, pkData->_iChapterID);

	m_pkTaskMap->UpdateTaskChapterReward(pkData->_iChapterID);
	SyncTaskChapterRecord();

	return RE_SUCCESS;
}

CTaskExtraReward& LC_ServerPlayer::GetTaskExtraRewardAsset()
{
	return m_TaskExtraRewardAsset;
}

CRotaryTable& LC_ServerPlayer::GetRotaryTableAsset()
{
	return m_RotaryTableAsset;
}

void LC_ServerPlayer::UpdateRotaryTableVaildTimes(int32_t value)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateRotaryTableVaildTimes(value);
	}

	GetRotaryTableAsset().UpdateRotaryTableVaildTimes(this, value);
}

void LC_ServerPlayer::AddTaskExtraReward(LC_ItemsRewardList& itemList)
{
	if(itemList.empty())
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddTaskExtraReward(itemList);
	}

	MG_SyncTaskExtraReward syncMsg;
	syncMsg.m_nSyncType = SyncType_Delta;
	syncMsg.m_nSyncOP = SyncOP_Add;
	syncMsg.m_nRewardInfo.reserve(itemList.size());
	for(int i=0; i<itemList.size(); ++i)
	{
		const Utility::UT_SIMDataList& pkItem = *itemList[i].GetAllItemList();
		for(UT_SIMDataList::const_iterator it=pkItem.begin(); it!=pkItem.end(); ++it)
		{
			int itemID = it->IID();
			int itemNum = it->ParamA();
			int bindMode = it->ParamB();

			KeyValue_Base itemData;
			itemData.key = itemID;
			itemData.value = itemNum;
			syncMsg.m_nRewardInfo.push_back(itemData);

			GetTaskExtraRewardAsset().UpdateTaskExtraReward(itemID, itemNum, bindMode);
		}
	}

	SendMsgToClient(MGPT_SYNCTASKEXTRAREWARD, &syncMsg);
}

CNoviceTutorial& LC_ServerPlayer::GetNoviceTutorialAsset()
{
	return m_NoviceTutorialAsset;
}

CPlayerMapInfo& LC_ServerPlayer::GetPlayerMapInfoAsset()
{
	return m_PlayerMapInfoAsset;
}

CPlatformInfo& LC_ServerPlayer::GetPlayerPlatformInfoAsset()
{
	return m_PlayerPlatformInfoAsset;
}

CIDAsset& LC_ServerPlayer::GetIDAsset()
{
	return m_IDAsset;
}

CGuessAsset_Summit& LC_ServerPlayer::GetSummitGuessAsset()
{
	return m_GuessAsset_Summit;
} 

BuddySchemeMgr& LC_ServerPlayer::GetBuddySchemeMgr()
{
	return m_BuddySchemeMgr;
}

CQuickRaidAsset& LC_ServerPlayer::GetQuickRaidAsset()
{
	return m_QuickRaidAsset;
}

CNonpareilReturn& LC_ServerPlayer::GetNonpareilAsset()
{
	return m_NonpareilReturnAsset;
}

CDropTimes& LC_ServerPlayer::GetDropTimesAsset()
{
	return m_DropTimesAsset;
}

CYuanZhengPoint& LC_ServerPlayer::GetYuanZhengPointAsset()
{
	return m_YuanZhengPointAsset;
}

CDropTimes& LC_ServerPlayer::GetStarShipTimesAsset()
{
	return m_StarShipTimesAsset;
}

CRecoverTimes* LC_ServerPlayer::GetPKRecoverAssetByType(int32_t type)
{
	CRecoverTimes* pkPtr = NULL;
	switch(type)
	{
	case RecoverType_BossDrop:
		pkPtr = &GetDropTimesAsset();
		break;
	case RecoverType_YuanZhengPoint:
		pkPtr = &GetYuanZhengPointAsset();
		break;
	case RecoverType_StarShip:
		pkPtr = &GetStarShipTimesAsset();
		break;
	default:
		break;
	}

	return pkPtr;
}

CChargeProfit& LC_ServerPlayer::GetChargeProfitAsset()
{
	return m_ChargeProfit;
}

int32_t LC_ServerPlayer::GetCurrentRecoverTimes(int32_t type)
{
	CRecoverTimes* pkRecoverAsset = GetPKRecoverAssetByType(type);
	if(NULL == pkRecoverAsset)
	{
		return 0;
	}

	return pkRecoverAsset->GetCurrentTimes(this);
}

void LC_ServerPlayer::ReduceCurrentRecoverTimes(int32_t type)
{
	CRecoverTimes* pkRecoverAsset = GetPKRecoverAssetByType(type);
	if(NULL == pkRecoverAsset)
	{
		return;
	}

	pkRecoverAsset->ReduceTimes(this);
}

void LC_ServerPlayer::AddTaskHonorPoint(int taskHonorPoint)
{
	if(taskHonorPoint < 0)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddTaskHonorPoint(taskHonorPoint);
	}

	m_nTaskHonorPoints += taskHonorPoint;
}

int32_t LC_ServerPlayer::GetTaskHonorPoint()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetTaskHonorPoint();
	}

	return m_nTaskHonorPoints;
}

void LC_ServerPlayer::ModifyTaskRankInfo(int rankIndex)
{
	if(rankIndex<0)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ModifyTaskRankInfo(rankIndex);
	}

	m_nTaskRankIndex = rankIndex;
}

void LC_ServerPlayer::SyncTaskRankInfo(int index)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncTaskRankInfo(index);
	}

	int newRankIndex = index;
	if(-1 == newRankIndex)
	{
		newRankIndex = UT_ServerHelper::GetRankIndexByType(Rank_Type_FinishMainTaskID, GetInstance());
	}

	int oldRange = LC_Helper::GetTaskRankRange(m_nTaskRankIndex);
	int currentRange = LC_Helper::GetTaskRankRange(newRankIndex);
	if(currentRange > 0)
	{
		ModifyTaskRankInfo(newRankIndex);

		int deltaRange = currentRange-oldRange;
		int changeState = 0;
		if(deltaRange < 0)
		{
			changeState = -1;
		}
		else if(deltaRange > 0)
		{
			changeState = 1;
		}

		MG_SyncTaskRank msg;
		msg.m_nChangeState = changeState;
		msg.m_nCurrentTaskRank = currentRange;
		SendMsgToClient(MGPT_SYNC_TASKRANK, &msg);
	}
}

//------------------------------------------------------------------------
void LC_ServerPlayer::SetArenaData(PS_CharArenaInfo& arenaData)
{
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetAuctionSellData(const Protocol::PS_ClientAuctionSell& kAuctionSellData)
{
	m_kAuctionSellData		= kAuctionSellData;
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetMoveSpeed(int fMoveSpeed)
{
	if (fMoveSpeed == m_lMoveSpeed)
		return;
	LC_ActorBase::SetMoveSpeed(fMoveSpeed); 
}
//------------------------------------------------------------------------
void LC_ServerPlayer::AddHP(attr_value_type  lHP, bool isRecoverHP)
{
	if (lHP < 0)
	{
		return;
	}
	if (m_pAssignedBuddyInstance == NULL)
		return;
	attr_value_type oldHP = GetHP();
	attr_value_type maxHP = GetFinalAttributeMap()->GetAttribute(ATT_MAX_HP);
	if (oldHP == maxHP)
	{
		return;
	}
	lHP = UT_MathBase::MinInt64(oldHP + lHP, maxHP);
	m_dataChangeFlag.SetHPMP();
	SetHP(lHP);
	//LC_ActorBase::SetHP(lHP);
	if(isRecoverHP)
	{
		LC_ServerPlayer* pkCurrentPlayer = GetCurrentActivateBuddy();
		if(NULL == pkCurrentPlayer)
			return;

		if(m_iID == pkCurrentPlayer->GetID())
		{
			//当前主控buddy回血的时候，下发回血事件，用于客户端显示回血特效
			SK_ServerSkillEventManager* pkEventManager = SERVER_GET_SKILL_EVENT_MANAGER();
			SK_SkillEvent* pkEvent = pkEventManager->AllocEvent();
			if (NULL != pkEvent)
			{
				pkEvent->SetEventType(SETE_RECOVER);
				pkEvent->SetSrcActorID(GetID());
				pkEvent->SetDstActorID(GetID());
				pkEvent->SetLogicID(0);
				pkEvent->SetParam(SK_RecoverEvent::SEP_ITEM_ID, 0);
				pkEvent->SetParam(SK_RecoverEvent::SEP_RECOVER_TYPE, SK_RecoverEvent::SRT_HP);
				pkEvent->SetParam(SK_RecoverEvent::SEP_FINAL_RECOVER, lHP-oldHP);

				MG_PB<msg_define::skill_event> kSkillEventMsg;
				pkEvent->SetToProtocol(kSkillEventMsg.m_value);
				SendMsgToClient(MGPT_RLT_SKILL_EVENT, &kSkillEventMsg);
				pkEventManager->ProcImmediateEvent(pkEvent);
			}
		}
	}
}
//------------------------------------------------------------------------
void LC_ServerPlayer::AddMP(attr_value_type  value)
{
	if (value <= 0)
	{
		return;
	}
	attr_value_type old_value = GetMP();
	attr_value_type maxMP = GetFinalAttributeMap()->GetAttribute(ATT_MAX_MP);
	if (old_value == maxMP)
	{
		return;
	}
	value = UT_MathBase::MinInt64(old_value + value, maxMP);
	m_dataChangeFlag.SetHPMP();
	LC_ActorBase::SetMP(value);
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetHP(attr_value_type  lHP)
{
	attr_value_type maxHp = GetFinalAttributeMap()->GetAttribute(ATT_MAX_HP);
	lHP = lHP<maxHp ? lHP : maxHp;

	int nRetCode = false;
	if (m_pAssignedBuddyInstance == NULL)
		return;

	if (lHP <= 0 && (GetDenyDead() || GetDenyBuddyDead() ))
		lHP = 1;
	// 这里有 死亡事件 
	LC_ActorBase::SetHP(lHP);

	nRetCode = m_pAssignedBuddyInstance->SetHP(lHP);
	if (nRetCode)
	{
		m_dataChangeFlag.SetHPMP();
		SyncPropertyToClient();
		if(lHP <= 0)
		{
			SetDead(true);
		}
	}
	if (lHP == 0) //死亡
	{
		LC_ServerPlayerGroupManager* pkPlayerGroupManager = (LC_ServerPlayerGroupManager*)SERVER_GET_PLAYER_GROUP_MANAGER();
		pkPlayerGroupManager->UpdatePlayerState(GetInstance(), PLAYER_ON_LINE);
	}
	
}
attr_value_type LC_ServerPlayer::GetHP()
{
	attr_value_type nResult = -1;
	if ( m_pAssignedBuddyInstance == NULL )
		return nResult;

	nResult = m_pAssignedBuddyInstance->GetHP();
	return nResult;
}

//------------------------------------------------------------------------
void LC_ServerPlayer::SetActivetyBuddyFactionID(unsigned short usFactionID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->SetFactionID(usFactionID);
	}
}

void LC_ServerPlayer::SetFactionID(unsigned short usFactionID)
{
	unsigned short  oldFaction = GetFactionID();
	if (oldFaction != usFactionID)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetProperty();
	}
	LC_ActorBase::SetFactionID(usFactionID);
}

unsigned short LC_ServerPlayer::GetFactionID()
{
	return LC_PlayerBase::GetFactionID();
}

void LC_ServerPlayer::SetOldHP(attr_value_type lOldHP)
{
	if (m_pAssignedBuddyInstance == NULL)
		return;
	m_pAssignedBuddyInstance->SetOldHP(lOldHP);
}

attr_value_type LC_ServerPlayer::GetOldHP()
{
	if (m_pAssignedBuddyInstance == NULL)
		return -1;

	return m_pAssignedBuddyInstance->GetOldHP();
}

LC_ActorStateMap* LC_ServerPlayer::GetControllerStateMap()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return NULL;

	if (!IsMainController())
		return pOwner->GetControllerStateMap();

	return LC_ActorBase::GetControllerStateMap();
}
LC_ActorStateMap* LC_ServerPlayer::GetStateMapOnBuddy()
{
	if (m_pAssignedBuddyInstance == NULL)
		return NULL;

	return m_pAssignedBuddyInstance->GetStateMap();
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetMP(attr_value_type  lMP)
{
	int nRetCode = false;
	if (m_pAssignedBuddyInstance == NULL)
		return;

	nRetCode = m_pAssignedBuddyInstance->SetMP(lMP);
	if (nRetCode)
		m_dataChangeFlag.SetHPMP();

}
attr_value_type LC_ServerPlayer::GetMP()
{
	attr_value_type nResult = -1;
	if ( m_pAssignedBuddyInstance == NULL )
		return nResult;

	nResult = m_pAssignedBuddyInstance->GetMP();
	return nResult;
}
//------------------------------------------------------------------------
void	LC_ServerPlayer::FlushMessageDirtyFlag()
{
	m_dataChangeFlag.InitFlagForAllBuddy();
}

MC_DataDirtyFlag& LC_ServerPlayer::GetMessageDirtyFlag()
{
	return m_dataChangeFlag;
}
//------------------------------------------------------------------------
LC_ServerPlayer::ServerViewState LC_ServerPlayer::GetServerViewState()
{
	return m_serverViewState;
}
//------------------------------------------------------------------------
void LC_ServerPlayer::SetServerViewState(ServerViewState state, bool bAsBuddy)
{
	m_serverViewState = state;
}

//----------------------------------------------------------------------------
void LC_ServerPlayer::CheckTimePassValid(float fClientCurrentTime, float fServerCurrentTime, float fTolerateTime)
{
	if (fServerCurrentTime - m_fLastTimerCheckTime < 2.5f)
	{
		return;
	}
	if (0 != m_fLastClientCheckTime)
	{
		float fClientDeltaTime = fClientCurrentTime - m_fLastClientCheckTime;
		float fServerDeltaTime = fServerCurrentTime	- m_fLastServerCheckTime;
		if (fServerDeltaTime <= 0.0f)
		{
			return;
		}

	}
	m_fLastClientCheckTime = fClientCurrentTime;
	m_fLastServerCheckTime = fServerCurrentTime;
	m_fLastTimerCheckTime  = fServerCurrentTime;
	return;
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::RecountTime()
{
	m_fLastClientCheckTime = 0.0f;
	m_fLastServerCheckTime = 0.0f;
	m_fLastTimerCheckTime  = 0.0f;
	m_kLastMoveCheckLocation = UT_Vec3Int(0, 0, 0);
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::BeKickedOff()
{
	MG_Message kBody;
	kBody.m_iMessageID = RE_LOGIN_FAIL;
	SendMsgToClient(MGPT_MESSAGE, &kBody);
}
//----------------------------------------------------------------------------
int32_t LC_ServerPlayer::GetActiveServer()
{
	if ( m_nActiveServer_Cache != -1 )
		return m_nActiveServer_Cache;
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return LC_PlayerBase::GetActiveServer();

	if (!IsMainController())
	{
		m_nActiveServer_Cache = pOwnerPlayer->GetActiveServer();
		return m_nActiveServer_Cache;
	}
	m_nActiveServer_Cache = LC_PlayerBase::GetActiveServer();
	return m_nActiveServer_Cache;
}

int LC_ServerPlayer::GetCurrentLocationWithZ( Utility::UT_Vec3Int& location )
{
	if (this->GetControlType() == LC_ServerPlayer::eControlType_Player)
	{
		location = GetCurrentLocation();
		return true;
	}
	else
	{
		const LC_ServerPlayer * pkOwner = GetCurrentActivateBuddy();
		if (pkOwner == NULL)
		{
			location = GetCurrentLocation();
			return false;
		}
		const UT_Vec3Int & kOwnerLocation = pkOwner->GetCurrentLocation();
		const UT_Vec3Int & kMyLocation = GetCurrentLocation();
		//return UT_Vec3Int(kMyLocation.x, kMyLocation.y, kOwnerLocation.z);
		location = kMyLocation;
		location.z = kOwnerLocation.z;
		return true;
	}
}
//----------------------------------------------------------------------------
void LC_ServerPlayer::SetCurrentLocation(const Utility::UT_Vec3Int& rkLocation)
{
	const Utility::UT_Vec3Int& oldLocation = GetCurrentLocation();
	if (oldLocation == rkLocation)
		return;
	if (oldLocation.x != rkLocation.x ||
		oldLocation.y != rkLocation.y ||
		oldLocation.z != rkLocation.z)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetLocation();
		SetAIControlNotify(true);
	}
	int nDistance = UT_MathBase::LineLengthXYInt( GetTargetLocation(), rkLocation);
	if (m_nLastTargetDistance > 200 && m_nLastTargetDistance < nDistance)
	{
		//printf("maybe error\n");
	}
	m_nLastTargetDistance = nDistance;
	LC_ActorBase::SetCurrentLocation(rkLocation);
}

void LC_ServerPlayer::SetForwardDir(const Utility::UT_Vec2Float& rkDir)
{
	const Utility::UT_Vec2Float& olddir = GetForwardDir();
	if (olddir.x != rkDir.x ||
		olddir.y != rkDir.y)
	{
		if ( GetAIControl() )
		{
			SetAIControlNotify(true);
		}
		int32_t nDistance = UT_MathBase::LineLengthXYInt( m_kCurrentLocation, m_kTargetLocation );

		m_dataChangeFlag.GetBroadCastFlag().SetAngle();
		float fAng = UT_MathBase::GetZRotAngle(rkDir);
		LC_ActorBase::SetForwardDir(rkDir);
	}
}

void LC_ServerPlayer::SetCurrentLocation(int iX, int iY, int iZ)
{
	const Utility::UT_Vec3Int& oldLocation = GetCurrentLocation();
	if (oldLocation.x != iX ||
		oldLocation.y != iY ||
		oldLocation.z != iZ)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetLocation();
		SetAIControlNotify(true);
	}
	Utility::UT_Vec3Int newPos;
	newPos.x = iX;
	newPos.y = iY;
	newPos.z = iZ;
	int nDistance = UT_MathBase::LineLengthXYInt( newPos , GetTargetLocation());
	if (m_nLastTargetDistance > 0 && m_nLastTargetDistance < nDistance)
	{
		//printf("maybe error\n");
	}
	m_nLastTargetDistance = nDistance;
	LC_ActorBase::SetCurrentLocation(iX, iY, iZ);
}

bool LC_ServerPlayer::SetTargetLocation(const Utility::UT_Vec3Int& rkTargetLocation)
{
	const Utility::UT_Vec3Int& oldLocation = GetTargetLocation();
	if (oldLocation.x != rkTargetLocation.x ||
		oldLocation.y != rkTargetLocation.y ||
		oldLocation.z != rkTargetLocation.z)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetLocation();
		SetAIControlNotify(true);
	}
	int nDistance = UT_MathBase::LineLengthXYInt( GetCurrentLocation(), rkTargetLocation);
	if (m_nLastTargetDistance > 0 && m_nLastTargetDistance < nDistance)
	{
		//printf("maybe error\n");
	}
	m_nLastTargetDistance = nDistance;
	LC_ActorBase::SetTargetLocation(rkTargetLocation);
	return true;
}

void LC_ServerPlayer::SetForwardDirAngle(float fDirAngle)
{
	if ( GetAIControl() )
	{
		int32_t nCurDistance = UT_MathBase::LineLengthXYInt( m_kCurrentLocation, m_kTargetLocation );
		float fNow = GET_PROCESS_TIME;
		if ( nCurDistance > 0 && IS_SKILL_TYPE(GetCurrentStateType()) )
		{
			//SetTargetLocation(GetCurrentLocation());
		}
		SetAIControlNotify(true);
		//m_dataChangeFlag.GetBroadCastFlag().SetLocation();	//通过此接口改变的方向标记为位置变化，方向将与位置一起同步下去
	}
	int32_t nDistance = UT_MathBase::LineLengthXYInt( m_kCurrentLocation, m_kTargetLocation );

	m_dataChangeFlag.GetBroadCastFlag().SetAngle();
	LC_ActorBase::SetForwardDirAngle(fDirAngle);
}

void LC_ServerPlayer::RotateByUp(float fDeltaAngle)
{
	if (fDeltaAngle != 0)
	{
		//m_dataChangeFlag.GetBroadCastFlag().SetLocation();	//通过此接口改变的方向标记为位置变化，方向将与位置一起同步下去
		m_dataChangeFlag.GetBroadCastFlag().SetAngle();
		SetAIControlNotify(true);
		LC_ActorBase::RotateByUp(fDeltaAngle);
	}
}

void LC_ServerPlayer::SetSelectTargetID(object_id_type lID)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return LC_PlayerBase::SetSelectTargetID(lID);

	if(!IsMainController())
	{
		return pOwnerPlayer->SetSelectTargetID(lID);
	}

	return LC_Attacker::SetSelectTargetID(lID);
}

object_id_type LC_ServerPlayer::GetSelectTargetID()
{
	return LC_Attacker::GetSelectTargetID();
}


void LC_ServerPlayer::SetCurrentStateType(int iCurrentState)
{
	if (GetCurrentStateType() != iCurrentState)
	{
		LC_PlayerBase::SetCurrentStateType(iCurrentState);
		m_dataChangeFlag.GetBroadCastFlag().SetStateType();
	}
}

ResultType LC_ServerPlayer::EquipItemInPackage(int iPackType, int iEntryIndex, int32_t iEquipPackType, int& iEquipSlotIndex)
{
	return RE_FAIL;
}

void LC_ServerPlayer::SetCharTitle(const StringType& rkCharTitle)
{
	m_dataChangeFlag.GetBroadCastFlag().SetSocity();
	LC_PlayerBase::SetCharTitle(rkCharTitle);

	//称号变化的时候，广播MG_RefreshPlayerMainInfo，因为别的玩家要看到变化的称号
	MG_RefreshPlayerMainInfo broadCastMsg;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	LC_ServerPlayer* pkCurrentPlayer = GetCurrentActivateBuddy();
	if(NULL != pkCurrentPlayer && NULL != pkOwnerPlayer)
	{
		broadCastMsg.m_lCurrentPlayerID = pkCurrentPlayer->GetID();

		mem::vector<int32_t> vecBuddyIDs;
		pkOwnerPlayer->GetActivateBuddyIDs(vecBuddyIDs);
		for(int i=0;i<vecBuddyIDs.size();++i)
		{
			LC_ServerPlayer* pkBuddy = pkOwnerPlayer->GetActivateBuddyByID(vecBuddyIDs[i]);
			if(NULL != pkBuddy)
			{
				broadCastMsg.m_lActivePlayerIDs.push_back(pkBuddy->GetID());
			}
		}

		broadCastMsg.m_GuildName = pkOwnerPlayer->GetGuildName().c_str();
		LC_TitleAsset* pkTitleAsset = GetTitleAsset();

		int titleType = pkTitleAsset->GetCurrentTitleType();
		if(titleType == TNT_SYSTEM_TITLE)
		{
			broadCastMsg.m_TitleID = pkTitleAsset->GetCurrentTitle();
		}
		else
		{
			broadCastMsg.m_TitleID = 0;	
		}

		LC_VIPAsset& rVipAsset = pkOwnerPlayer->GetVIPAsset();
		broadCastMsg.m_VipLevel = rVipAsset.GetVIPLevel();
		broadCastMsg.m_iUiFlag = rVipAsset.GetUiFlag();

		pkOwnerPlayer->BroadCastToArea(MGPT_CONTROLLER_PLAYER_INFO, &broadCastMsg);
	}
}

int LC_ServerPlayer::GetFriendsNum()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	LC_SocietyAsset* pkSocietyAsset = pkOwnerPlayer->GetSocietyAsset();

	LC_FriendInfo* friends = pkSocietyAsset->GetFriendInfo();

	return friends->GetDetails().size();
}

int LC_ServerPlayer::GetJoinTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	return pkOwnerPlayer->GetArenaBattleAssert()->GetJoinTimes();
}

LC_PlayerGroupBase* LC_ServerPlayer::GetPlayerGroup()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPlayerGroup();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetPlayerGroup();
	}

	return LC_PlayerBase::GetPlayerGroup();
}

void LC_ServerPlayer::SetPlayerGroupIDType(uint32_t nGroupID, uint32_t nGroupType)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetPlayerGroupIDType(nGroupID, nGroupType);
	}

	uint32_t nOldGroupID = GetPlayerGroupID();
	uint32_t nOldGroupType = GetPlayerGroupType();
	if (nOldGroupID == nGroupID && nOldGroupType == nGroupType)
	{
		return;
	}
	setExtPropertyDirty();
	LC_PlayerBase::SetPlayerGroupIDType(nGroupID, nGroupType);

	if (nOldGroupType != nGroupType && nGroupID != INVALID_GROUP_ID && nOldGroupID != INVALID_GROUP_ID)
	{
		switch (nOldGroupType)
		{
		case E_PlayerTeamType_Local:
			{
				LC_ServerPlayerGroupManager* pkServerPlayerGroupManager = SERVER_GET_PLAYER_GROUP_MANAGER();
				if (pkServerPlayerGroupManager)
				{
					pkServerPlayerGroupManager->ClearPlayerFromGroup(this, nOldGroupID);
				}
			}
			break;
		case E_PlayerTeamType_Cross:
			{
				LC_ServerPlayerEnterLeaveManager* enterLeaveManager = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
				if (enterLeaveManager)
				{
					enterLeaveManager->DelCrossRealmTeamPlayerInfo(m_rTeamAssert.GetGlobalTeamID(), m_iID, true);
				}
			}
			break;
		}
	}
	if (nOldGroupType == E_PlayerTeamType_Cross)
	{
		SetPlayerGroupGlobalInfo(0, 0);
	}
}

void LC_ServerPlayer::SetPlayerGroupGlobalInfo(uint32_t mapTypeId, uint32_t nGlobalTeam)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetPlayerGroupGlobalInfo(mapTypeId, nGlobalTeam);
	}

	LC_PlayerBase::SetPlayerGroupGlobalInfo(mapTypeId, nGlobalTeam);
}

uint32_t LC_ServerPlayer::GetPlayerGroupID()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPlayerGroupID();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetPlayerGroupID();
	}

	return LC_PlayerBase::GetPlayerGroupID();
}

uint32_t LC_ServerPlayer::GetPlayerGroupType()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPlayerGroupType();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetPlayerGroupType();
	}

	return LC_PlayerBase::GetPlayerGroupType();
}

void LC_ServerPlayer::SetPlayerGroupCheifFlag(bool bFlag)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
	m_dataChangeFlag.GetBroadCastFlag().SetControllerProperty();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetPlayerGroupCheifFlag(bFlag);
	}

	return LC_PlayerBase::SetPlayerGroupCheifFlag(bFlag);
}

bool LC_ServerPlayer::GetPlayerGroupCheifFlag()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetPlayerGroupCheifFlag();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetPlayerGroupCheifFlag();
	}

	return LC_PlayerBase::GetPlayerGroupCheifFlag();
}

int LC_ServerPlayer::GetBeInviteGroupIDByIndex(int iIndex)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetBeInviteGroupIDByIndex(iIndex);

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetBeInviteGroupIDByIndex(iIndex);
	}

	return LC_PlayerBase::GetBeInviteGroupIDByIndex(iIndex);
}

void LC_ServerPlayer::SetBeInviteGroupIDByIndex(int iIndex, int lGroupID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetBeInviteGroupIDByIndex(iIndex, lGroupID);
	}

	LC_PlayerBase::SetBeInviteGroupIDByIndex(iIndex, lGroupID);
}

void LC_ServerPlayer::RemoveBeInviteGroupByID(int lGroupID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->RemoveBeInviteGroupByID(lGroupID);
	}

	LC_PlayerBase::RemoveBeInviteGroupByID(lGroupID);
}

bool LC_ServerPlayer::CheckGroupDistance(int lDistance)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->CheckGroupDistance(lDistance);
	}

	return LC_PlayerBase::CheckGroupDistance(lDistance);
}

void LC_ServerPlayer::setExtPropertyDirty()
{
	m_dataChangeFlag.GetBroadCastFlag().SetExtProperty();
}

void LC_ServerPlayer::ClearPlayerGroup(uint32_t nMapOpt, uint32_t nGroupOpt)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->ClearPlayerGroup(nMapOpt, nGroupOpt);
	}

	uint32_t nGroupID = GetPlayerGroupID();
	if (nGroupID == INVALID_GROUP_ID)
	{
		return;
	}
	uint32_t nGroupType = GetPlayerGroupType();
	if (nGroupType == E_PlayerTeamType_None || nGroupOpt == E_PlayerGroupLimit_None)
	{
		return;
	}
	if (nMapOpt == E_PlayerGroupMapOpt_InMap)		//进入地图，解散不匹配的组队状态
	{
		if ((nGroupType == E_PlayerTeamType_Local || nGroupType == E_PlayerTeamType_CLocal) && nGroupOpt != E_PlayerGroupLimit_Local)	//本服状态，跨服约束，解散本服
		{
			LC_ServerPlayerGroupManager* pkServerPlayerGroupManager = SERVER_GET_PLAYER_GROUP_MANAGER();
			if (pkServerPlayerGroupManager)
			{
				pkServerPlayerGroupManager->ClearPlayerFromGroup(this, nGroupID);
			}
		}
		if (nGroupType == E_PlayerTeamType_Cross && nGroupOpt != E_PlayerGroupLimit_Cross)	//跨服状态，本服约束，解散跨服
		{
			LC_ServerPlayerEnterLeaveManager* enterLeaveManager = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
			if (enterLeaveManager)
			{
				enterLeaveManager->DelCrossRealmTeamPlayerInfo(m_rTeamAssert.GetGlobalTeamID(), m_iID, true);
			}
		}
	}
	else if (nMapOpt == E_PlayerGroupMapOpt_OutMap || nMapOpt == E_PlayerGroupMapOpt_Clear)	//离开地图(无论如何)，解散需求的组队状态
	{
		if ((nGroupType == E_PlayerTeamType_Local || nGroupType == E_PlayerTeamType_CLocal) && (nGroupOpt == E_PlayerGroupLimit_Local || nGroupOpt == E_PlayerGroupLimit_All))	//本服状态，解散所有或者本服
		{
			LC_ServerPlayerGroupManager* pkServerPlayerGroupManager = SERVER_GET_PLAYER_GROUP_MANAGER();
			if (pkServerPlayerGroupManager)
			{
				pkServerPlayerGroupManager->ClearPlayerFromGroup(this, nGroupID);
			}
		}

		if (nGroupType == E_PlayerTeamType_Cross && (nGroupOpt == E_PlayerGroupLimit_Cross || nGroupOpt == E_PlayerGroupLimit_All))	//跨服状态，解散所有或者跨服
		{
			LC_ServerPlayerEnterLeaveManager* enterLeaveManager = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
			if (enterLeaveManager)
			{
				enterLeaveManager->DelCrossRealmTeamAllPlayerInfo(m_rTeamAssert.GetGlobalTeamID(), this, true);
			}
		}
	}
}

void LC_ServerPlayer::SetGuildID(uint64_t lGuildID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetGuildID(lGuildID);
	}

	m_dataChangeFlag.GetBroadCastFlag().SetSocity();
	m_dataChangeFlag.GetBroadCastFlag().SetControllerProperty();

	bool bInGuild = IsExistGuild();
	LC_PlayerBase::SetGuildID(lGuildID);
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if (IsExistGuild())
	{
		if (!bInGuild && m_kOpenAbilityAsset.IsAbilityEnabled(LC_ABT_TASK, STT_GUILD_TASK))
		{
			pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_GUILD_TASK));
		}
		if (IsGetGuildData() && !bInGuild)
		{
			GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_GUILDMONEY);
		}
	}
	else
	{
		if (bInGuild)
		{
			//退出公会
			SetSendGuildPresentInfoFlag(false);

			uint32_t timestamp = uint32_t(GET_CURRENT_TIMESTAMP_IN_MILISECONDS() / 1000);
			((LC_ServerTaskMap*)GetTaskMap())->CheckReset(timestamp, STT_GUILD_TASK, true);

			//退出公会，环数量-1  下次加入的时候，才会不变
			LC_TaskManager* pkTaskMgr = LC_TaskManager::GetSingletonPtr();
			LC_TaskMap* pkTaskMap = GetTaskMap();
			if(NULL!=pkTaskMgr && pkTaskMap!=NULL /*&& NULL!=pkAssignInfo*/)
			{
				LC_AssignTaskInfo* pkAssignInfo = pkTaskMap->GetAssignTaskInfo();
				uint32_t uiAssignType = pkTaskMgr->GetAssignType(STT_GUILD_TASK);
				LC_AssignTaskData*	assignData = pkAssignInfo->GetAssignTaskData(uiAssignType);
				if(NULL != assignData)
				{
					int around = assignData->GetRound();
					if(around > 0)
					{
						pkAssignInfo->SetRound(uiAssignType, around-1);
					}
				}
			}
		}
	}

	//设置公会id的时候，如果目前所在的地图要求公会pk模式则设置公会pk模式
	if(lGuildID != 0)
	{
		NotifyPlayerAddGuild();

		int mapResID = GetMapResID();
		CF_WorldMapList::DataEntry* enterMap = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapResID);
		if(NULL != enterMap && enterMap->_enterPKMode==PKM_SOCIETY)
		{
			GetPKRecorder()->SetPKMode(enterMap->_enterPKMode);
		}
	}
	else
	{
		int currentPkMode = GetPKRecorder()->GetPKMode();
		if(currentPkMode == PKM_SOCIETY)
		{
			GetPKRecorder()->SetPKMode(PKM_PEACE);
		}
	}
}

void LC_ServerPlayer::SetGuildName(const StringType& strGuildName)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetGuildName(strGuildName);
	}

	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
	m_dataChangeFlag.GetBroadCastFlag().SetControllerProperty();
	if ( LC_PlayerBase::GetGuildName() == strGuildName )
		return;

	LC_PlayerBase::SetGuildName(strGuildName);

	//公会名字变动的时候(加入公会/退出公会/修改公会名字)，广播MG_RefreshPlayerMainInfo，因为别的玩家要看到变化的公会名字
	MG_RefreshPlayerMainInfo broadCastMsg;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	LC_ServerPlayer* pkCurrentPlayer = GetCurrentActivateBuddy();
	if(NULL != pkCurrentPlayer && NULL != pkOwnerPlayer)
	{
		broadCastMsg.m_lCurrentPlayerID = pkCurrentPlayer->GetID();

		mem::vector<int32_t> vecBuddyIDs;
		pkOwnerPlayer->GetActivateBuddyIDs(vecBuddyIDs);
		for(int i=0;i<vecBuddyIDs.size();++i)
		{
			LC_ServerPlayer* pkBuddy = pkOwnerPlayer->GetActivateBuddyByID(vecBuddyIDs[i]);
			if(NULL != pkBuddy)
			{
				broadCastMsg.m_lActivePlayerIDs.push_back(pkBuddy->GetID());
			}
		}

		broadCastMsg.m_GuildName = pkOwnerPlayer->GetGuildName().c_str();
		LC_TitleAsset* pkTitleAsset = GetTitleAsset();

		int titleType = pkTitleAsset->GetCurrentTitleType();
		if(titleType == TNT_SYSTEM_TITLE)
		{
			broadCastMsg.m_TitleID = pkTitleAsset->GetCurrentTitle();
		}
		else
		{
			broadCastMsg.m_TitleID = 0;	
		}

		LC_VIPAsset& rVipAsset = pkOwnerPlayer->GetVIPAsset();
		broadCastMsg.m_VipLevel = rVipAsset.GetVIPLevel();
		broadCastMsg.m_iUiFlag = rVipAsset.GetUiFlag();

		pkOwnerPlayer->BroadCastToArea(MGPT_CONTROLLER_PLAYER_INFO, &broadCastMsg);
		pkOwnerPlayer->UpdatePlayerBaseDataToGroup();
		if ( GetbLoadFromSocietyFlag() )
			SaveCharPB(false);
	}
}

void LC_ServerPlayer::SetSkillFlag(int64_t llFlag, bool bFlag)
{
	if (GetSkillFlag(llFlag) != bFlag)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetFastProperty();
		LC_PlayerBase::SetSkillFlag(llFlag, bFlag);
	}
}

void LC_ServerPlayer::SetAllSkillFlag(int64_t llSkillFlag)
{
	if (GetAllSkillFlag() != llSkillFlag)
	{
		m_dataChangeFlag.GetBroadCastFlag().SetFastProperty();
		LC_PlayerBase::SetAllSkillFlag(llSkillFlag);
	}
}

void LC_ServerPlayer::SetBroadCastFlag(int nFlag)
{
	m_dataChangeFlag.GetBroadCastFlag().SetBroadCastFlag(nFlag);
}

void	LC_ServerPlayer::SetBroadCastFlagForce(int nFlag)
{
	m_dataChangeFlag.GetBroadCastFlag().SetBroadCastFlagForce(nFlag);
}

int32_t LC_ServerPlayer::GetTotalActivatedSkillCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return 0;
	if(!IsMainController())
		return pkOwnerPlayer->GetTotalActivatedSkillCount();

	return m_nTotalActivatedSkillCount;
}

int32_t LC_ServerPlayer::GetBuddyTotalActivatedSkillCountByBuddyID(int buddyID)
{
	LC_ServerPlayer* pkPlayer = GetOwnerPlayer();
	if(NULL == pkPlayer)
	{
		return -1;
	}

	if(!IsMainController())
	{
		return pkPlayer->GetBuddyTotalActivatedSkillCountByBuddyID(buddyID);
	}

	mem::map<int32_t, BuddyInstance*> ::iterator it = m_ppUsableBuddyInstance.find(buddyID);
	if(it == m_ppUsableBuddyInstance.end())
	{
		return -1;
	}

	BuddyInstance* pkBuddy = it->second;
	if(NULL == pkBuddy)
	{
		return -1;
	}

	return pkBuddy->GetTotalActivatedSkillCount();
}

void LC_ServerPlayer::OnIncActivatedSkillCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->OnIncActivatedSkillCount();


	m_nTotalActivatedSkillCount++;
	return;
}

void LC_ServerPlayer::OnNoticeActivatedSkillCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;
	if(!IsMainController())
		return pkOwnerPlayer->OnNoticeActivatedSkillCount();
	AchievementEvent kEvent;
	kEvent.SetNum(m_nTotalActivatedSkillCount);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ACTIVE_SKILL, kEvent);
}

int LC_ServerPlayer::ActivateSkill(int32_t nBuddyId, int32_t nSkillId, int32_t& nErrorCode)
{
	int nResult = false;
	MG_Reply_ActivateSkill msg;
	msg.m_nError = RE_SKILL_ACTIVATE_SUCCESS;
	msg.m_nParam = nBuddyId;
	msg.m_nParam2 = nSkillId;
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
	{
		msg.m_nError = RE_SKILL_ACTIVATE_SYSTEM;
		goto Exit0;
	}

	if(!IsMainController())
	{
		return pOwnerPlayer->ActivateSkill(nBuddyId, nSkillId, nErrorCode);
	}

	msg.m_nParam = 0;
	BuddyInstance* pInstance = GetBuddyInstanceByID(nBuddyId);
	if (pInstance == NULL)
	{
		msg.m_nError = RE_SKILL_ACTIVATE_NO_BUDDY;
		msg.m_nParam = nBuddyId;
		goto Exit0;
	}

	int nRet = pInstance->ActivateSkill(nSkillId);
	if (nRet != RE_SKILL_ACTIVATE_SUCCESS)
	{
		msg.m_nError = nRet;
		msg.m_nParam = nSkillId;
		goto Exit0;
	}

	OnNoticeActivatedSkillCount();
	pInstance->SyncBuddyRuneStarLevelInfo();

	nResult = true;
	msg.m_nParam = nBuddyId;
Exit0:
	SendMsgToClient(MGPT_RTL_ACTIVATE_SKILL, &msg);
	if (msg.m_nError == RE_SKILL_ACTIVATE_SUCCESS )
	{
		// Sync skill data
		pInstance->SyncSkillAsset();
	}
	nErrorCode = msg.m_nError;
	return nResult;
}

int LC_ServerPlayer::CheckActivateSkill(int32_t nBuddyId, int32_t nSkillId)
{
	int nResult = -1;

	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
	{
		return nResult;
	}

	if(!IsMainController())
	{
		return pOwnerPlayer->CheckActivateSkill(nBuddyId, nSkillId);
	}

	BuddyInstance* pInstance = GetBuddyInstanceByID(nBuddyId);
	if (pInstance == NULL)
	{
		return nResult;
	}

	nResult = pInstance->CheckActivateSkill(nSkillId);

	return nResult;
}

int LC_ServerPlayer::GetSkillUsableCount( int32_t nBuddyId, int32_t nSkillId, bool bSelfOwner )
{
	int nResult = -1;
	if (!bSelfOwner)
	{
		LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
		if (pOwnerPlayer == NULL)
			return nResult;
		if(!IsMainController())
			return pOwnerPlayer->GetSkillUsableCount(nBuddyId, nSkillId);
	}
	nResult = GetSkillUsableCountImpl(nBuddyId, nSkillId);
	return nResult;
}

int LC_ServerPlayer::ModifySkillMaxUsableCount( int32_t nBuddyId, int32_t nSkillId, int32_t nUsableCount )
{
	int nResult = -1;
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
	{
		return nResult;
	}

	if(!IsMainController())
	{
		return pOwnerPlayer->ModifySkillMaxUsableCount(nBuddyId, nSkillId, nUsableCount);
	}

	nResult = ModifySkillMaxUsableCountImpl(nBuddyId, nSkillId, nUsableCount);

	return nResult;
}

// skill usable count
int LC_ServerPlayer::ModifySkillUsableCount( int32_t nBuddyId, int32_t nSkillId, int32_t nUsableCount, bool bSelfOwner )
{
	int nResult = -1;
	if (!bSelfOwner)
	{
		LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
		if (pOwnerPlayer == NULL)
		{
			return nResult;
		}

		if(!IsMainController())
		{
			return pOwnerPlayer->ModifySkillUsableCount(nBuddyId, nSkillId, nUsableCount);
		}
	}

	nResult = ModifySkillUsableCountImpl(nBuddyId, nSkillId, nUsableCount);

	return nResult;
}

int LC_ServerPlayer::ModifySkillMaxUsableCountImpl(int32_t nBuddyId, int32_t nSkillId, int32_t nUsableCount)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return false;
	if(!IsMainController())
		return pkOwnerPlayer->ModifySkillMaxUsableCountImpl( nBuddyId, nSkillId, nUsableCount);

	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		return false;

	int nResult = pInstance->ModifySkillMaxUsableCount(nSkillId, nUsableCount);
	return nResult;
}

int32_t LC_ServerPlayer::GetSkillUsableCountImpl(int32_t nBuddyId, int32_t nSkillId)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return 0;
	if(!IsMainController())
		return pkOwnerPlayer->GetSkillUsableCountImpl( nBuddyId, nSkillId);
	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		return false;
	int nResult = pInstance->GetSkillUsableCount(nSkillId, this);
	return nResult;
}

int32_t LC_ServerPlayer::GetSkillEnableUsableCountImpl(int32_t nBuddyId, int32_t nSkillId)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return false;
	if(!IsMainController())
		return pkOwnerPlayer->GetSkillEnableUsableCountImpl( nBuddyId, nSkillId);

	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		return false;

	int nResult = pInstance->GetSkillEnableUsableCount(nSkillId, this);
	return nResult;
}

int32_t LC_ServerPlayer::GetSkillMaxUsableCountImpl(int32_t nBuddyId, int32_t nSkillId)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return false;
	if(!IsMainController())
		return pkOwnerPlayer->GetSkillMaxUsableCountImpl( nBuddyId, nSkillId);

	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		return false;

	int nResult = pInstance->GetSkillMaxUsableCount(nSkillId);
	return nResult;
}

int LC_ServerPlayer::ModifySkillUsableCountImpl(int32_t nBuddyId, int32_t nSkillId, int32_t nUsableCount)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return -1;
	if(!IsMainController())
		return pkOwnerPlayer->ModifySkillUsableCountImpl( nBuddyId, nSkillId,nUsableCount);


	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		return -1;

	int nResult = pInstance->ModifySkillUsableCount(nSkillId, nUsableCount, this);
	return nResult;
}

int LC_ServerPlayer::GetSkillMaxUsableCount( int32_t nBuddyId, int32_t nSkillId, bool bSelfOwner )
{
	int nResult = -1;
	if ( !bSelfOwner )
	{
		LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
		if (pOwnerPlayer == NULL)
		{
			return nResult;
		}

		if(!IsMainController())
		{
			return pOwnerPlayer->GetSkillMaxUsableCount(nBuddyId, nSkillId);
		}
	}

	nResult = GetSkillMaxUsableCountImpl(nBuddyId, nSkillId);

	return nResult;
}

int LC_ServerPlayer::GetSkillEnableUsableCount( int32_t nBuddyId, int32_t nSkillId, bool bSelfOwner )
{
	int nResult = -1;
	if ( !bSelfOwner )
	{
		LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
		if (pOwnerPlayer == NULL)
		{
			return nResult;
		}

		if(!IsMainController())
		{
			return pOwnerPlayer->GetSkillMaxUsableCount(nBuddyId, nSkillId);
		}
	}

	nResult = GetSkillEnableUsableCountImpl(nBuddyId, nSkillId);

	return nResult;
}

int LC_ServerPlayer::ModifySkillUsableCount_Self( int32_t nSkillId, int32_t nUsableCount )
{
	int nResult = -1;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;

	nResult = m_pAssignedBuddyInstance->ModifySkillUsableCount(nSkillId, nUsableCount);

	return nResult;
}

int LC_ServerPlayer::GetSkillUsableCount_Self( int32_t nSkillId )
{
	int nResult = -1;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;

	nResult = m_pAssignedBuddyInstance->GetSkillUsableCount(nSkillId);

	return nResult;
}

int LC_ServerPlayer::ModifySkillMaxUsableCount_Self( int32_t nSkillId, int32_t nUsableCount )
{
	int nResult = -1;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;

	nResult = m_pAssignedBuddyInstance->ModifySkillMaxUsableCount(nSkillId, nUsableCount);

	return nResult;
}

int LC_ServerPlayer::GetSkillMaxUsableCount_Self( int32_t nSkillId )
{
	int nResult = -1;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;

	nResult = m_pAssignedBuddyInstance->GetSkillMaxUsableCount(nSkillId);

	return nResult;
}

int LC_ServerPlayer::SyncSingleSkillCDInfo(int32_t nBuddyId, int32_t nSkillId, float fCDTime)
{
	MG_Sync_SingleSkillCD data;
	data.m_nBuddyId = nBuddyId;
	data.m_nSkillId = nSkillId;
	data.m_nCDTime = fCDTime * 1000;

	SendMsgToClient(MGPT_SYNC_SINGLE_SKILL_CD, &data);
	return true;
}

int LC_ServerPlayer::UpdateSkillAsset(float fCurrentTime, float fDeltaTime)
{
	return true;
}

uint64_t LC_ServerPlayer::GetGuildID()
{
	return LC_PlayerBase::GetGuildID();
}


const StringType& LC_ServerPlayer::GetGuildName()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetGuildName();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetGuildName();
	}

	return LC_PlayerBase::GetGuildName();
}

const StringType& LC_ServerPlayer::GetGuildName_utf8()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetGuildName_utf8();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetGuildName_utf8();
	}

	return LC_PlayerBase::GetGuildName_utf8();
}

bool LC_ServerPlayer::IsExistGuild()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->IsExistGuild();
	}

	return LC_PlayerBase::IsExistGuild();
}

LC_VIPAsset& LC_ServerPlayer::GetVIPAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetVIPAsset();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetVIPAsset();
	}

	return LC_PlayerBase::GetVIPAsset();
}

uint32_t LC_ServerPlayer::GetAddRateToVip()
{
	uint32_t ret = 0;
	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	if (pkGuildManager)
	{
		LC_ServerGuildInfo* p_GuildInfo = pkGuildManager->GetGuildInfoByID(GetGuildID());
		if(p_GuildInfo)
			ret += p_GuildInfo->GetGuildTowerVipRate();
	}
	int vipLevel = GetVIPLevel();
	LC_VIPCmnManager* pkMgr = LC_VIPCmnManager::GetSingletonPtr();
	if(NULL != pkMgr)
	{
		LC_VIPProfitDataEntry* pkDataEntry = pkMgr->GetVIPProfitDataEntry(VIP_PROFIT_VIP_ADD_RATE);
		if(NULL !=pkDataEntry)
			ret += pkDataEntry->GetValue(vipLevel, false);
	}
	return ret;
}

LC_AssistAsset& LC_ServerPlayer::GetAssistAsset()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return LC_PlayerBase::GetAssistAsset();

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetAssistAsset();
	}

	return LC_PlayerBase::GetAssistAsset();
}

int LC_ServerPlayer::GetServerID()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetServerID();
	}

	return LC_PlayerBase::GetServerID();
}

void LC_ServerPlayer::SetServerID(int nID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetServerID(nID);
	}

	return LC_PlayerBase::SetServerID(nID);
}

bool LC_ServerPlayer::IsCashEnough(MoneyType llCash, int iCashType)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->IsCashEnough(llCash, iCashType);
	}

	if (iCashType < CT_BIND_CASH || iCashType > CT_CASH_COUNT || llCash < 0)
	{
		return false;
	}

	bool res = false;
	switch (iCashType)
	{
	case CT_BIND_YUANBAO:
		{
			res = GetUnBindYuanBao().GetMoney() + GetBindYuanBao().GetMoney() >= llCash ? true: false;
		}
		break;
	case CT_WAREHOUSE_UNBIND_CASH:
		{
			res = GetPackAsset()->GetWarehousePack().m_kUnBindCash.GetMoney() >= llCash ? true : false;
		}
		break;
	case CT_GUILD_MONEY:
		{
			res = GetGuildMoney() >= llCash ? true : false;
		}
		break;
	default:
		{
			res = GetCashNumByCashType((CashType)iCashType)>=llCash ? true : false;
		}
		break;
	}

	return res;
}

void LC_ServerPlayer::SetPlaceCanPK(bool pk)
{
	if (pk == m_PlaceCanPK)
	{
		return;
	}
	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
	LC_PlayerBase::SetPlaceCanPK(pk);
}

void LC_ServerPlayer::Offline()
{
	m_offlingTime = GET_PROCESS_TIME;
	if (!m_isOffline)
	{
		AsyncUpdateToDBServer();
	}
	m_isOffline = true;
	SetSession(NULL);
}

void LC_ServerPlayer::Online()
{
	m_isOffline = false;
	m_offlingTime = 0;
	RefreshDataFlag();
	RecountTime();
}
bool LC_ServerPlayer::IsOffline()
{
	return m_isOffline;
}
float LC_ServerPlayer::GetOfflineTime()
{
	return m_offlingTime;
}
void LC_ServerPlayer::ClientLoading()
{
	int mapLogicID = GetMapLogicID();
	
	//m_clientLoading字段，只有指挥官用
	if(IsMainController())
	{
		m_clientLoading = true;
	}
	
	m_loadTime = GET_PROCESS_TIME;
}

#define NEWBIE_TASK_ID 1000177

bool LC_ServerPlayer::FirstEnterWorld()
{
	if (AutoEnterBornRaid)
	{
		return false;
	}
	LC_WorldLocationAsset* pkWorldLocationAsset = GetWorldLocationAsset();

	for (int32_t i = 0; i < WLT_MAX; ++i)
	{
		LC_WorldLocationAssetEntry* pkEntry = pkWorldLocationAsset->GetWorldLocationAssetEntryByIndex(i);
		if (pkEntry && pkEntry->GetValid() && pkEntry->GetMapResID())
		{
			return false;
		}
	}
	Utility::UT_Vec3Int pos(0, 0, 0);
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	pkWorldManager->RequestChangePlayerLocation(this, LMIOT_FIRST_ENTER_TRANSCRIPTION, 0, GetFirstMapID(), pos);
	return true;
}

void LC_ServerPlayer::ClientLoadFinished()
{
	m_clientLoading = false;
}

bool LC_ServerPlayer::IsClientLoading()
{
	return m_clientLoading;
}

float LC_ServerPlayer::GetLoadingStartTime()
{
	return m_loadTime;
}

bool LC_ServerPlayer::IsNormalQuit()
{
	return m_normalQuit;
}

void LC_ServerPlayer::SetNormalQuit(bool quit)
{
	m_normalQuit = quit;
}

void LC_ServerPlayer::RefreshDataFlag()
{
	//更新玩家视野
	GetMessageDirtyFlag().GetUniCastFlag().SetNpcEnterOrLeave();
	GetMessageDirtyFlag().GetUniCastFlag().SetPlayerEnterOrLeave();
	GetFOVMap()->UpdateAllPlayersIDEnterInFov();
	GetFOVMap()->UpdateAllNPCIDEnterInFov();
}
//------------------------------------------------------------------------------------------
void LC_ServerPlayer::UpdateGameStoryContent(float fCurrentTime, float fDeltaTime)
{}
//------------------------------------------------------------------------------------------
void LC_ServerPlayer::UpdateOpenBag(float fCurrentTime, float fDeltaTime)
{
	LC_OpenBagAsset& asset = GetOpenBagAssert();
	LC_BasicPack& pack = GetPackAsset()->GetBasicPack();
	int now_size = pack.GetSize();

	if (now_size >= MAX_BASIC_PACK_COUNT)
	{
		return;
	}

	OpenAssetParam* param = asset.GetParam();
	int mini_size = param->FreeSlotCount();

	if (now_size < mini_size)
	{
		pack.SetSize(mini_size);
		asset.UpdateParam(mini_size);
		return;
	}
	else
	{
		int32_t now = (int32_t)GET_CURRENT_TIMESTAMP_IN_SECONDS();
		if (now >= asset.GetNextOpenTime())
		{
			pack.SetSize(now_size + 1);
			SyncBackPackToClient(PACK_TYPE_BASIC);
			asset.UpdateParam(now_size + 1);
			MG_Common sucMsg;
			sucMsg.set("slot", now_size + 1);

			SendMsgToClient(MGPT_NOTIFY_AUTO_OPEN_BAG_SLOT, &sucMsg);
			return;
		}
	}
}

//------------------------------------------------------------------------------------------
void LC_ServerPlayer::UpdateChangeServerCDTime(float fCurrentTime)
{
	if (!IsInstance())
	{
		return;
	}

	if (m_fChangeServerCDTime <= 0.0f)
	{
		return;
	}
	if (m_fLastUpdateChangeServerTime <= 0.0f)
	{
		m_fLastUpdateChangeServerTime = fCurrentTime;
	}
	m_fLastUpdateChangeServerTime = UT_MathBase::Min(m_fLastUpdateChangeServerTime, fCurrentTime);
	float fDeltaTime = UT_MathBase::Max(0.0f, fCurrentTime - m_fLastUpdateChangeServerTime);
	m_fChangeServerCDTime = UT_MathBase::Max(0.0f, m_fChangeServerCDTime - (fDeltaTime / 60.0f));
	m_fLastUpdateChangeServerTime = fCurrentTime;
}
void LC_ServerPlayer::CancelCurrentSkill()
{
	int current_state_typeid = GetCurrentStateType();
	if (IS_SKILL_TYPE(current_state_typeid))
	{
		InterruptSkill(GET_PROCESS_TIME, current_state_typeid, SKI_FORCE);
	}
}

//------------------------------------------------------------------------------------------
bool LC_ServerPlayer::CheckTranscriptionValidity()
{
	if (m_lMapLogicType > MT_TRANSCRIPTION_BEGIN && m_lMapLogicType < MT_TRANSCRIPTION_END)
	{
		return true;
	}
	return false;
}
//------------------------------------------------------------------------------------------
int LC_ServerPlayer::GetCurrentEquipItem(int iEquipType, bool bConsiderFashion /* = false */)
{
	if (iEquipType < 0 || iEquipType >= MAX_EQUIP_SLOT_SIZE)
	{
		return 0;
	}
	uint32_t iItemID = 0;
	WeaponType iWeaponType = GetCurrentBandWeapon();
	if (bConsiderFashion && GetIsShowFashion())
	{
		LC_FashionBagAsset& kFashionBag = GetFashionBagAsset();
		switch (iEquipType)
		{
		case ET_HEAD:
			iItemID = kFashionBag.GetShowFashionItems(FT_HEAD, iWeaponType);
			break;
		case ET_BODY:
			iItemID = kFashionBag.GetShowFashionItems(FT_BODY, iWeaponType);
			break;
		case ET_FOOT:
			iItemID = kFashionBag.GetShowFashionItems(FT_FOOT, iWeaponType);
			break;
		case ET_WEAPON:
			iItemID = kFashionBag.GetShowFashionItems(FT_WEAPON, iWeaponType);
			break;
		default:
			break;
		}
	}
	if (iItemID > 0)
	{
		return iItemID;
	}

	const LC_BackPackEntry& rkEntry = GetCommandEquipPack().GetEquipData(iEquipType);
	if (rkEntry.GetBackPackValueByType(LPSFET_VALID))
	{
		return rkEntry.GetBackPackValueByType(LPSFET_TYPE_ID);
	}
	return 0;
}
//------------------------------------------------------------------------------------------
bool LC_ServerPlayer::CheckSyncMoveValid(const UT_Vec3Int& rkSyncLocation)
{
	float fCurrentTime = GET_PROCESS_TIME;
	if (m_fLastSyncMoveTime < 0.0f
		|| IS_SKILL_TYPE(GetCurrentStateType())	//技能阶段
		|| this->GetSkillFlag(SK_FLY)		//跳跃阶段
		)
	{
		m_fLastSyncMoveTime = fCurrentTime;
		m_kLastMoveCheckLocation = rkSyncLocation;
		return true;
	}

	float fDeltaTime = fCurrentTime - m_fLastSyncMoveTime + 0.2f;
	if (fDeltaTime < 2.0f)
	{
		return true;
	}
	m_fLastSyncMoveTime = fCurrentTime;

	fDeltaTime = UT_MathBase::Min(2.0f, fDeltaTime);//2
	int lSyncMoveDistance = UT_MathBase::LineLengthXYInt(rkSyncLocation, m_kLastMoveCheckLocation);
	int lMoveSpeed = (int)GetFinalAttributeMap()->GetAttribute(ATT_MOVE_SPEED);//500
	lMoveSpeed = UT_MathBase::MaxInt((int)CHAR_MOVE_SPEED, lMoveSpeed);
	float fMoveSpeedUpRate = Long2Float(lSyncMoveDistance) / (lMoveSpeed * fDeltaTime);//   N  >2000

	if (fMoveSpeedUpRate > 1.2f)
	{

	}

	if (fMoveSpeedUpRate > 3.0f)		//客户端加速过度，需要校正
	{
		//return false;
	}
	m_kLastMoveCheckLocation = rkSyncLocation;
	return true;
}
//------------------------------------------------------------------------------------------
#define			MAX_DISASSEM_ITEM_COUNT		10
ResultType LC_ServerPlayer::AddDropByDisassemble( int nDisassemId, bool bCached, int nCount )
{
	ResultType iResult = RE_FAIL;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return iResult;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->AddDropByDisassemble(nDisassemId, bCached, nCount);
	}

	LC_ServerItemFlopManager* pkServerItemFlopManager = LC_ServerItemFlopManager::GetSingletonPtr();
	if (NULL == pkServerItemFlopManager)
		return RE_ITEM_SYSTEM_ERROR;

	LC_PackAsset* pkPackAsset = GetPackAsset();
	if (NULL == pkPackAsset)
		return RE_ITEM_SYSTEM_ERROR;

	LC_ItemFlopInfoList kItemFlopList;
	int					iPackType = PACK_TYPE_UNDEFINE;
	int					lItemID = 0;
	int					lItemCount = 0;
	int					itemBindMode = 0;

	GameLogic::LC_RewardItemsExtend kExtend;

	kExtend.SetBind(0);
	kExtend.SetChoice(0);
	pkServerItemFlopManager->GenerateItemFlopInfoOnDisassemble(kItemFlopList, this, nDisassemId, &kExtend);

	LC_ItemFlopInfo* pkItemFlopInfo = kItemFlopList.GetItemFlopInfoByIndex(0);
	if (NULL == pkItemFlopInfo)
		return RE_ITEM_SYSTEM_ERROR;

	CF_ItemDisassembleUseFunc* pkFunc = CF_ItemDisassembleUseFunc::GetSingletonPtr();
	CF_ItemDisassembleUseFunc::DataEntry* pkFuncEntry = pkFunc->GetEntryPtr(nDisassemId);
	if (pkFuncEntry == NULL)
		return RE_ITEM_SYSTEM_ERROR;

	LC_BackPackEntryList& rkBackEntryList = pkItemFlopInfo->GetBackPackEntryList();
	if (rkBackEntryList.empty())
		return RE_SUCCESS;

	LC_BackPackEntryListIter IterBe = rkBackEntryList.begin();
	LC_BackPackEntryListIter IterEd = rkBackEntryList.end();

	PackOperateInfoList objOPList;
	objOPList.clear();

	for (; IterBe != IterEd;)
	{
		LC_BackPackEntry& rkBackPackEntry = *IterBe;
		lItemID		= rkBackPackEntry.GetBackPackValueByType(LPSFET_TYPE_ID);
		lItemCount	= rkBackPackEntry.GetBackPackValueByType(LPSFET_OVERLAP_COUNT);
		itemBindMode = rkBackPackEntry.GetBackPackValueByType(LPSFET_BINDMODE);

		iPackType = PACK_TYPE_BASIC;
		PackOperateInfo objData;
		objData.Reset();
		objData.m_iOPType = OPT_ADD_ITEM;
		objData.m_bMerger  = true;
		objData.m_iPackType  = iPackType;
		objData.m_bOPEntry = true;
		objData.m_kPackEntry.Clone(rkBackPackEntry);
		objOPList.push_back(objData);

		++IterBe;
	}

	if ( bCached )
	{
		return RE_SUCCESS;
	}

	return LC_Helper::DoItemOPs(this, objOPList, SYS_FUNC_TP_ITEM_DISASSEMBLE, nDisassemId);//pkPackAsset->ExecutePackOP(objOPList,true);
}

void LC_ServerPlayer::SetShapeShiftInfo(int lNewShapeShiftTypeID)
{
	int lOldShapeShiftTypeID = GetShapeShiftCharTypeID();
	if (lNewShapeShiftTypeID == lOldShapeShiftTypeID)
	{
		return;
	}
	bool bOldFlag = GetShapeShiftFlag();
	bool bNewShift = false;
	if (lNewShapeShiftTypeID > 0 && lNewShapeShiftTypeID != GetCharType())
	{
		bNewShift = true;
	}
	else
	{
		lNewShapeShiftTypeID = 0;
	}
	SetShapeShiftFlag(bNewShift);
	SetShapeShiftCharTypeID(lNewShapeShiftTypeID);
	SyncShapeShiftInfo();

	if (bOldFlag)
	{
		RemoveShapeShiftForbidAction(lOldShapeShiftTypeID);
	}
	if (bNewShift)
	{
		AddShapeShiftForbidAction(lNewShapeShiftTypeID);
	}
}

void LC_ServerPlayer::AddShapeShiftForbidAction(int lShapeShiftTypeID)
{
	if (m_bAddShapeShiftForbidAction)
	{
		return;
	}
	m_bAddShapeShiftForbidAction = true;

	int lAttackSkillID = 0;
	CF_CharType* pkCharType = CF_CharType::GetSingletonPtr();
	CF_CharType::DataEntry* pkCharData = pkCharType->GetEntryPtr(lShapeShiftTypeID);
	if (pkCharData)
	{
		lAttackSkillID = CSVHelper::GetCharSkillID(pkCharData, 1);
	}

}

void LC_ServerPlayer::RemoveShapeShiftForbidAction(int lShapeShiftTypeID)
{
	if (m_bAddShapeShiftForbidAction == false)
	{
		return;
	}
	m_bAddShapeShiftForbidAction = false;
	int lAttackSkillID = 0;
	CF_CharType* pkCharType = CF_CharType::GetSingletonPtr();
	CF_CharType::DataEntry* pkCharData = pkCharType->GetEntryPtr(lShapeShiftTypeID);
	if (pkCharData)
	{
		lAttackSkillID = CSVHelper::GetCharSkillID(pkCharData, 1);
	}

}

void LC_ServerPlayer::CostItemEndurance(bool bDead, int lSkillID, bool bSrc)
{
}

void LC_ServerPlayer::BroadcastChangeName()
{
	uint64_t id = GetInstance();
	const StringType& name = GetOwnerCharName();

	MG_SyncModifyCharName sync;
	sync.m_nCharID = id;
	sync.m_nNewCharName = TPSTR2STDSTR(name);

	mem::vector<unique_id_type> BeFriendIDs;
	GetSocietyAsset()->GetBeFriendID(BeFriendIDs);
	for(int i=0; i<BeFriendIDs.size(); ++i)
	{		
		LC_ServerPlayerManager* pkServerPlayerManager = SERVER_GET_PLAYER_MANAGER();
		LC_ServerPlayer* friendPlayer = (LC_ServerPlayer*)(pkServerPlayerManager->FindPlayer(BeFriendIDs[i]));
		if (!friendPlayer)
		{
			continue;
		}

		friendPlayer->SendMsgToClient(MGPT_SYNCMODIFYCHARNAME, &sync);
	}
}

void LC_ServerPlayer::TickOwnerMP( float fCurrent )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->TickOwnerMP( fCurrent);
	float fInternalDelta = fCurrent - m_fOwnerMPTimer;
	if ( fInternalDelta >= GetGlobalSetting.fOwnerMPResumeTimer )
	{
		float fCur = GET_PROCESS_TIME;
		ModifyOwnerMPLite(GetGlobalSetting.nOwnerMPResumeValue);
		m_fOwnerMPTimer = fCurrent + fInternalDelta - GetGlobalSetting.fOwnerMPResumeTimer;
	}
}

int32_t LC_ServerPlayer::GetOwnerMaxMP()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return 0;

	if (!IsMainController())
		return pOwner->GetOwnerMaxMP();

	int nResult = LC_PlayerBase::GetOwnerMaxMP();

	return nResult;
}

void LC_ServerPlayer::SetOwnerMaxMP( int32_t nValue )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->SetOwnerMaxMP( nValue );	

	LC_PlayerBase::SetOwnerMaxMP(nValue);
	return;
}

void LC_ServerPlayer::ModifyOwnerMaxMP( int32_t nDeltaValue )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->ModifyOwnerMaxMP(nDeltaValue);

	LC_PlayerBase::ModifyOwnerMaxMP(nDeltaValue);
	return;
}

int32_t LC_ServerPlayer::GetOwnerMP()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return 0;

	if (!IsMainController())
		return pOwner->GetOwnerMP();

	int nResult = LC_PlayerBase::GetOwnerMP();
	return nResult;
}

void LC_ServerPlayer::SetOwnerMP( int32_t nValue )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->SetOwnerMP(nValue);

	LC_PlayerBase::SetOwnerMP(nValue);

	return;
}

void LC_ServerPlayer::ModifyOwnerMP_Impl( int32_t nDeltaValue )
{
	int32_t nOrig = LC_PlayerBase::GetOwnerMP();
	LC_PlayerBase::ModifyOwnerMP(nDeltaValue);
	int32_t nCur = LC_PlayerBase::GetOwnerMP();
	int32_t nMax = LC_PlayerBase::GetOwnerMaxMP();
	//GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "TickOwnerMP=>ModifyOwnerMP_Impl player: %u Delta: %d cur: %d max: %d", m_iID , nDeltaValue, nCur, nMax);
	if (nOrig == nCur)
		return;

	// Sync
	SyncOwnerMP_Impl(nCur, nMax);
}

void LC_ServerPlayer::ModifyOwnerMPLite( int32_t nDeltaValue )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->ModifyOwnerMPLite( nDeltaValue);

	ModifyOwnerMP_Impl(nDeltaValue);
}

// framework make sure this function will never be called with non-controller player.
void LC_ServerPlayer::ModifyOwnerMP( int32_t nDeltaValue )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->ModifyOwnerMP( nDeltaValue );

	ModifyOwnerMP_Impl(nDeltaValue);
	return;
}

void LC_ServerPlayer::SyncOwnerMP()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->SyncOwnerMP();

	int32_t nCur = LC_PlayerBase::GetOwnerMP();
	int32_t nMax = LC_PlayerBase::GetOwnerMaxMP();

	SyncOwnerMP_Impl(nCur, nMax);
}

void LC_ServerPlayer::SyncOwnerMP_Impl(int32_t nCur, int32_t nMax)
{
	MG_SyncCommanderMP sync;
	sync.m_nCur = nCur;
	sync.m_nMax = nMax;

	float fCurrent = GET_PROCESS_TIME;

	//GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "TickOwnerMP=>ModifyOwnerMP_Impl=>SyncOwnerMP_Impl player: %u now: %f cur: %d max: %d", m_iID , fCurrent, nCur, nMax);

	SendMsgToClient(MGPT_SYNC_OWNER_MP_INFO, &sync);	
}

void  LC_ServerPlayer::_updatePlayerRecover(float fCurrentTime)
{
	float fTimeElapse = fCurrentTime - m_fLastRecover;	

	int64_t nCurHP = GetHP();
	if (nCurHP <= 0)
		return;
	bool ismainController = IsMainController();

	if (fTimeElapse >= GetGlobalSetting.fHPResumeTimer  )
	{
		m_fLastRecover = fCurrentTime;

		int64_t recover_value = 0;
		float fRate = 1.00f;
		if( GetPKRecorder()->GetFightState() )
			fRate = GetGlobalSetting.fHPResumeRateInCombat;
		//
		// 策划要求，全天候无差别，按这个机制回血
		// 下次加入全局配置：战斗状态回血百分比
		recover_value = (int)GetFinalAttributeMap()->GetAttribute(ATT_HP_RECOVER);
		recover_value *= fRate;

		if (recover_value >= 0)
		{
			AddHP(recover_value, true);
		}
		AddHP(0);
		recover_value = (int)GetFinalAttributeMap()->GetAttribute(ATT_STM_RECOVER_RATE);
		AddStamina((int32_t)recover_value);

		recover_value = (int)GetFinalAttributeMap()->GetAttribute(ATT_AMM_RECOVER_RATE);
		AddBowAmount((int32_t)recover_value);
	}
	// 跳闪值
	if (m_JumpDodgeTimer.IsExpired())
	{
		if (m_JumpDodgePoint < MAX_JUMP_DODGE_POINT)
		{
			++m_JumpDodgePoint;
			UpdateDirtyFlag(DIRTY_FLAG_PROPERTY);
		}
	}
}

void LC_ServerPlayer::AddCourageState()
{
	return;
	if (!IsInstance())
	{
		return;
	}

	ResultType eResult = this->ActiveSkillState(31000301, 1800, GetID(), 0, 0, 0, 0, 0);
	if (eResult == RE_SKILL_STATE_ADD_SUCCESS)
	{
		//通知客户端
		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_STATE_GET_COURAGE);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
			SendGameEvent(pkGameEvent);
			pkEventManager->FreeGameEvent(pkGameEvent);
		}
	}
}

ResultType LC_ServerPlayer::EquipVehicleEquipment(int iPackType, int iEntryIndex, int iVSlotIndex)
{
	return RE_FAIL;
}

ResultType LC_ServerPlayer::UnEquipVehicleEquipment(int iVSlotIndex)
{
	return RE_FAIL;
}

void LC_ServerPlayer::AddFriendShip(object_id_type lCharID, int iFriendShip)
{

}

void LC_ServerPlayer::NoticeFriendOffline()
{
	if (!IsInstance())
	{
		return;
	}

	MG_RLT_FriendOfflineNotice rltMsg;
	LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	if (!pkPlayerManager)
	{
		return;
	}
	LC_SocietyAsset* pkSocietyAsset = GetSocietyAsset();
	LC_FriendInfo* pkFriendInfo = pkSocietyAsset->GetFriendInfo();

	FriendDetailInfoMap::iterator it = pkFriendInfo->GetDetails().begin();
	for (int i = 0; it != pkFriendInfo->GetDetails().end() && i < MAX_FRIEND_NUM; ++i, ++it)
	{
		LC_FriendDetailInfo& rkFriendInfo = it->second;
		{
			LC_ServerPlayer* pkFriendTemp = static_cast<LC_ServerPlayer*>(pkPlayerManager->FindPlayer(rkFriendInfo.GetCharID()));
			if (pkFriendTemp && !pkFriendTemp->IsOffline())
			{
				MG_RLT_FriendOfflineNotice kNoticeMsg;
				kNoticeMsg.m_lFriendID = GetInstance();
				pkFriendTemp->SendMsgToClient(MGPT_RLT_FRIEND_OFFLINE_NOTICE, &kNoticeMsg);
			}
		}
	}
}

void LC_ServerPlayer::UpdateSocietyAsset(GameLogic::LC_SocietyBasicInfo& rkBaseInfo)
{
	if (!IsInstance())
	{
		return;
	}
	GetSocietyAsset()->UpdateSocietyBaseInfo(ST_FRIEND, rkBaseInfo);
}
//----------------------------------------------------------
void LC_ServerPlayer::AddSystemTitle(int iTitleID)
{
	if (!IsInstance())
	{
		return;
	}
	CF_SystemTitleList* pkTitleList = CF_SystemTitleList::GetSingletonPtr();

	CF_SystemTitleList::DataEntry* pkEntry = pkTitleList->GetEntryPtr(iTitleID);
	if (!pkEntry)
	{
		return;
	}

	uint32_t curTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	//如果称号不存在，才添加新称号
	if (!m_kTitleAsset.IsHoldSystemTitle(iTitleID))
	{
		//检测称号对平台的限制
		bool tag = pkEntry->_sPlatform.empty() ? true : false;
		if(!tag)
		{
			for(int i=0; i<pkEntry->_sPlatform.size(); ++i)
			{
				if(GetPlayerPlatformInfoAsset().CheckPlatformTypeMatch(pkEntry->_sPlatform[i]))
				{
					tag = true;
					break;
				}
			}
		}

		if(!tag)
		{
			return;
		}

		ResultType iResult = m_kTitleAsset.AddSystemTitle(iTitleID, curTime);
		if (RE_SUCCESS != iResult)
		{
			return;
		}

		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		{
			LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
			if (pkGameEvent != NULL)
			{
				pkGameEvent->SetEventType(GLET_ADD_SYSTEM_TITlE);
				pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
				pkGameEvent->SetEventParam(EP_ADD_SYSTEM_TITLE_PLAYER_ID, GetID());
				pkGameEvent->SetEventParam(EP_ADD_SYSTEM_TITLE_ID, iTitleID);
				pkEventManager->InsertGameEvent(pkGameEvent);
			}
		}

		UT_ServerHelper::_GameNoticeFmort noticeFmort;
		noticeFmort.SetMsgID(49);
		noticeFmort.AddTitleName(iTitleID);
		UT_ServerHelper::BrocastNoticeMsg(noticeFmort, 0, this);

		if (m_kTitleAsset.GetCurrentTitleType() == TNT_NONE_TITLE)
		{
			SetSystemTitle(iTitleID);
		}
		//添加 新的 系统 称号 成功
		GetCommanderAttrMgr().RefreshSysTitleAttributeMap(this, false);
	}
	else if (pkEntry->_iPeriod > 0)
	{
		m_kTitleAsset.ResetPeriodSystemTitle(iTitleID, curTime);
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::RemoveSystemTitleMsg(int iTitleID)
{
	UT_ServerHelper::_GameNoticeFmort noticeFmort;
	noticeFmort.SetMsgID(43);
	noticeFmort.AddString(GetOwnerCharName());
	noticeFmort.AddTitleName(iTitleID);
	UT_ServerHelper::BrocastNoticeMsg(noticeFmort, 0, this);
}
//----------------------------------------------------------
void LC_ServerPlayer::RemoveSystemTitle(int iTitleID, uint32_t removetime)
{
	if (!IsInstance())
	{
		return;
	}
	if (m_kTitleAsset.IsHoldSystemTitle(iTitleID))
	{
		ResultType iResult = m_kTitleAsset.RemoveSystemTitle(iTitleID, removetime);
		if (RE_SUCCESS == iResult)
		{
			//删除 系统 称号 成功
			GetCommanderAttrMgr().RefreshSysTitleAttributeMap(this, false);
			RemoveSystemTitleMsg(iTitleID);
			LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
			{
				LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
				if (pkGameEvent != NULL)
				{
					pkGameEvent->SetEventType(GLET_REMOVE_SYSTEM_TITlE);
					pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
					pkGameEvent->SetEventParam(EP_REMOVE_SYSTEM_TITLE_PLAYER_ID, GetID());
					pkGameEvent->SetEventParam(EP_REMOVE_SYSTEM_TITLE_ID, iTitleID);
					pkEventManager->InsertGameEvent(pkGameEvent);
				}
			}
		}
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::CheckInbornTitle(void)
{
	if (!IsInstance())
	{
		return;
	}
	LC_SystemTitleManager* pkMgr = LC_SystemTitleManager::GetSingletonPtr();
	if (!pkMgr)
	{
		return;
	}
	uint32_t timestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	mem::vector<int32_t> kInbornTitles = pkMgr->GetInbornTitles();
	for (size_t i = 0; i < kInbornTitles.size(); ++i)
	{
		int32_t iTitleID = kInbornTitles.at(i);
		if (!m_kTitleAsset.IsHoldSystemTitle(iTitleID))
		{
			AddSystemTitle(iTitleID);
		}
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::SetSystemTitle(int iTitleID)
{
	if (!IsInstance())
	{
		return;
	}
	if (m_kTitleAsset.IsHoldSystemTitle(iTitleID))
	{
		CF_SystemTitleList* pkTitleList = CF_SystemTitleList::GetSingletonPtr();

		CF_SystemTitleList::DataEntry* pkEntry = pkTitleList->GetEntryPtr(iTitleID);
		if (pkEntry == NULL)
		{
			return;
		}
		m_kTitleAsset.SetCurrentTitle(pkEntry->_iTypeID, pkEntry->_iID);
		StringType Title = m_kTitleAsset.GetTitle(pkEntry->_iTypeID, pkEntry->_iID);
		SetCharTitle(Title);
		SetChangeTitleFlag(true);
		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		{
			LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
			if (pkGameEvent != NULL)
			{
				pkGameEvent->SetEventType(GLET_CHANGE_SYSTEM_TITLE);
				pkGameEvent->SetEventParam(EP_CHANGE_SYSTEM_TITlE_PLAYER_ID, GetID());
				pkGameEvent->SetEventParam(EP_CHANGE_SYSTEM_TITlE_ID, iTitleID);
				pkEventManager->InsertGameEvent(pkGameEvent);
			}
		}
	}
}
//----------------------------------------------------------
void LC_ServerPlayer::SetFightState(bool bPVPFightState, bool bPVEFightState)
{
	//更新战斗状态
	bool bFightState = bPVPFightState || bPVEFightState;
	float now_sec = GET_PROCESS_TIME;
	if (now_sec - m_fFightStateBeginTime < 1.5f && !bFightState)
	{
		return;
	}
	if (GetPKRecorder()->GetFightState() != bFightState)
	{
		if (GetPKRecorder()->GetFightState() == true && bFightState == false)
		{
			if (m_fFightOutBeginTime != 0.0f && now_sec - m_fFightOutBeginTime < 5.0f)
			{
				return   ;
			}
			else if (m_fFightOutBeginTime == 0.0f)
			{
				m_fFightOutBeginTime = now_sec;
				return ;
			}
		}
		//记录进入战斗的时间
		if (bFightState)
		{
			m_fFightStateBeginTime = now_sec;
		}
		m_dataChangeFlag.GetBroadCastFlag().SetProperty();

		m_RunSpeedUpDirty = true;
	}
	m_fFightOutBeginTime = 0.0f;
	GetPKRecorder()->SetFightState(bPVPFightState, bPVEFightState);
}
//----------------------------------------------------------
void LC_ServerPlayer::UpdateItemLog(uint32_t lServerTime)
{
	if (!IsInstance())
	{
		return;
	}
	if (lServerTime < (uint32_t)m_iLastUpdateItemLogTime + 3600)
	{
		return;
	}
	m_iLastUpdateItemLogTime = lServerTime;
	GfxWriteFmtLog(LOG_ITEM_FILELINE, LOG_SWITCH_ITEM, "uniquie item info dump begin", GetInstance());
	m_kPackAsset.PrintAllUniqueIDItem();
	GfxWriteFmtLog(LOG_ITEM_FILELINE, LOG_SWITCH_ITEM, "uniquie item info dump end", GetInstance());
}
//------------------------------------------------------------------------
ResultType	LC_ServerPlayer::ConsumeItemsInPackageByIndex(int iPackType, int iEntryIndex, int iConsumeNum,int nLogCode, const vector<int>& nParams)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;

	if(!IsMainController())
	{
		return 	m_pOwnerPlayer->ConsumeItemsInPackageByIndex(iPackType, iEntryIndex, iConsumeNum, nLogCode, nParams);
	}

	if (!IsInstance())
	{
		return RE_FAIL;
	}
	LC_BackPackEntry* pkEntry = m_kPackAsset.GetBackPackEntry(iPackType, iEntryIndex);
	if (NULL == pkEntry || !pkEntry->GetBackPackValueByType(LPSFET_VALID))
	{
		return RE_ITEM_INVALID;
	}
	int lItemTypeID					= pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
	int lOverlapCount					= pkEntry->GetBackPackValueByType(LPSFET_OVERLAP_COUNT);
	LC_ItemFactoryBase* pkItemFactory	= LC_ItemFactoryBase::GetSingletonPtr();
	LC_ItemBase* pkItem					= pkItemFactory->RequestItem(lItemTypeID);
	if (NULL == pkItem)
	{
		return RE_ITEM_INVALID;
	}

	if (pkItem->GetUseMultiple() > 1)
	{
		DeleteItem(lItemTypeID, iConsumeNum);
		goto Exit0;
	}

	uint32_t usCurrentUseCount	= pkEntry->GetBackPackValueByType(LPSFET_USED_COUNT);
	int lCanConsumeTmp = pkItem->GetMaxUseCount() - usCurrentUseCount;
	if (lOverlapCount > 1)
	{
		lCanConsumeTmp = lCanConsumeTmp + (lOverlapCount - 1) * pkItem->GetMaxUseCount();
	}
	if (lCanConsumeTmp < iConsumeNum)
	{
		return RE_ITEM_INVALID;
	}
	if (pkItem->GetMaxUseCount() > 0)
	{
		usCurrentUseCount += iConsumeNum;
		pkEntry->SetBackPackValueByType(LPSFET_USED_COUNT, usCurrentUseCount);
		m_kPackAsset.UpdateDirtyFlag(iPackType);
	}
	if (!pkItem->GetUseCountLimit().empty())
	{
		LC_CommonStatAsset& kCmnAsset = GetCommonStatAsset();
		Utility::UT_SIMDataList::const_iterator cit = pkItem->GetUseCountLimit().begin();
		for (; cit != pkItem->GetUseCountLimit().end(); ++cit)
		{
			LC_CommonStatBasic* pkStatBasic = kCmnAsset.GetCommonStatBasic(cit->ID());
			if (pkStatBasic)
			{
				pkStatBasic->RegItemStat(pkItem->GetUseCountLimitKey(), pkStatBasic->GetItemStat(pkItem->GetUseCountLimitKey()) + iConsumeNum);
				kCmnAsset.UpdateDirtyFlag();
			}
		}
	}
	if (pkItem->IsCountDestroy())
	{
		if (0 < pkItem->GetMaxUseCount() && usCurrentUseCount >= (uint32_t)pkItem->GetMaxUseCount())
		{
			int iDeleteNUM = (int)(usCurrentUseCount / pkItem->GetMaxUseCount());
			int iLeftUserCount = usCurrentUseCount - iDeleteNUM * pkItem->GetMaxUseCount();

			PackOperateInfoList objOPList;
			PackOperateInfo objData;
			objData.Reset();

			objData.m_iOPType		= OPT_DELETE_ITEM_BY_INDEX;
			objData.m_bOPEntry		= false;
			objData.m_iPackType		= iPackType;
			objData.m_iIndex		= iEntryIndex;
			objData.m_lCount		= iDeleteNUM;
			objData.m_lItemID       = lItemTypeID;
			objOPList.push_back(objData);

			int iResult = LC_Helper::DoItemOPs(this, objOPList, SYS_FUNC_TP_ITEM_USE, 0, true, true, nLogCode, nParams);
			if (RE_SUCCESS != iResult)
			{
				return RE_ITEM_INVALID;
			}

			if (pkEntry->GetBackPackValueByType(LPSFET_VALID))
			{
				pkEntry->SetBackPackValueByType(LPSFET_USED_COUNT, iLeftUserCount);
			}
		}
	}

	UpdateDirtyFlag(DIRTY_FLAG_SHORTCUT);

Exit0:
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	if (NULL == pkGameEvent)
	{
		return RE_SUCCESS;
	}
	pkGameEvent->SetEventType(GLET_USE_ITEM);
	pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_NONE);
	pkGameEvent->SetEventParam(EP_USE_ITEM_PLAYER_ID, GetID());
	pkGameEvent->SetEventParam(EP_USE_ITEM_TYPE_ID, lItemTypeID);
	pkGameEvent->SetEventParam(EP_USE_ITEM_MAP_ID, GetMapResID());
	pkEventManager->InsertGameEvent(pkGameEvent);
	return RE_SUCCESS;
}
//----------------------------------------------------------
ResultType LC_ServerPlayer::ConsumeItemsInPackageByID(int lItemID, int iConsumeNum)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;;

	if(!IsMainController())
	{
		return 	m_pOwnerPlayer->ConsumeItemsInPackageByID(lItemID, iConsumeNum);
	}

	if (!IsInstance())
	{
		return RE_FAIL;
	}

	LC_ItemFactoryBase* pkItemFactory = LC_ItemFactoryBase::GetSingletonPtr();
	LC_ItemBase* pkItem = pkItemFactory->RequestItem(lItemID);
	if (!pkItem)
	{
		return RE_ITEM_INVALID;
	}
	if (!pkItem->IsCountDestroy())
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ConsumeItemsInPackageByID-errro [%d], c_cid:%d, c_citizenship:%d, c_uid:%d", lItemID,  instance.detail(), instance.catagory(), GetUserID());
		return RE_SUCCESS;
	}

	int iPackType		= GetWhichPackAutoPut(lItemID);
	int iPackCapacity	= m_kPackAsset.GetPackSize(iPackType);
	int iCanConsumeNum	= 0;
	int iDeleteEnterNum = 0;

	int iLastEntryIndex			= -1;
	int iLastEntrySetUseCount	= 0;

	PackOperateInfoList objOPList;
	for (int i = 0; i < iPackCapacity; ++i)
	{
		LC_BackPackEntry* pkEntry = m_kPackAsset.GetBackPackEntry(iPackType, i);
		if (NULL == pkEntry)
		{
			continue;
		}
		if (!pkEntry->GetBackPackValueByType(LPSFET_VALID))
		{
			continue;
		}
		if (pkEntry->GetBackPackValueByType(LPSFET_LOCKED))
		{
			continue;
		}
		if (pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID) != lItemID)
		{
			continue;
		}
		int lCurrentUseCount = pkEntry->GetBackPackValueByType(LPSFET_USED_COUNT);
		int lOverlapCount = pkEntry->GetBackPackValueByType(LPSFET_OVERLAP_COUNT);
		if (pkItem->GetMaxUseCount() <= 0)
		{
			continue;
		}
		if (lCurrentUseCount >= pkItem->GetMaxUseCount())
		{
			continue;
		}
		int lCanConsumeTmp = pkItem->GetMaxUseCount() - lCurrentUseCount;
		if (lOverlapCount > 1)
		{
			lCanConsumeTmp = lCanConsumeTmp + (lOverlapCount - 1) * pkItem->GetMaxUseCount();
		}
		if (iConsumeNum - iCanConsumeNum > lCanConsumeTmp)
		{
			iCanConsumeNum	= iCanConsumeNum + lCanConsumeTmp;
			iDeleteEnterNum	= pkEntry->GetBackPackValueByType(LPSFET_OVERLAP_COUNT);

			PackOperateInfo objData;
			objData.Reset();
			objData.m_iOPType	= OPT_DELETE_ITEM_BY_INDEX;
			objData.m_bOPEntry	= false;
			objData.m_iPackType = iPackType;
			objData.m_iIndex	= i;
			objData.m_lCount	= iDeleteEnterNum;
			objOPList.push_back(objData);
		}
		else
		{
			iLastEntryIndex			= i;
			iDeleteEnterNum			= int((iConsumeNum - iCanConsumeNum) / pkItem->GetMaxUseCount());
			iLastEntrySetUseCount	= lCurrentUseCount + int((iConsumeNum - iCanConsumeNum) % pkItem->GetMaxUseCount()); //设置剩余使用次数
			if (iLastEntrySetUseCount >= pkItem->GetMaxUseCount())
			{
				iLastEntrySetUseCount -= pkItem->GetMaxUseCount();
				iDeleteEnterNum++;
			}

			if (iDeleteEnterNum == lOverlapCount)
			{
				iLastEntryIndex = -1;
			}

			iCanConsumeNum = iConsumeNum;
			if (iDeleteEnterNum > 0)
			{
				PackOperateInfo objData;
				objData.Reset();
				objData.m_iOPType	= OPT_DELETE_ITEM_BY_INDEX;
				objData.m_bOPEntry	= false;
				objData.m_iPackType = iPackType;
				objData.m_iIndex	= i;
				objData.m_lCount	= iDeleteEnterNum;
				objOPList.push_back(objData);
			}
			break;
		}
	}

	if (iConsumeNum > iCanConsumeNum)
	{
		return RE_FAIL;
	}
	if (objOPList.empty() && iLastEntrySetUseCount < 0)
	{
		return RE_FAIL;
	}
	if (!objOPList.empty())
	{
		int iResult = m_kPackAsset.ExecutePackOP(objOPList, true);
		if (RE_SUCCESS != iResult)
		{
			return RE_FAIL;
		}
	}

	if (iLastEntryIndex >= 0)
	{
		LC_BackPackEntry* pkLastEntry = m_kPackAsset.GetBackPackEntry(iPackType, iLastEntryIndex);
		if (NULL == pkLastEntry)
		{
			return RE_FAIL;
		}
		if (!pkLastEntry->GetBackPackValueByType(LPSFET_VALID) || pkLastEntry->GetBackPackValueByType(LPSFET_LOCKED))
		{
			return RE_FAIL;
		}
		if (pkLastEntry->GetBackPackValueByType(LPSFET_TYPE_ID) != lItemID)
		{
			return RE_FAIL;
		}
		int nRemainCount = GetPackAsset()->GetItemCountInPack(PACK_TYPE_BASIC, pkLastEntry->GetBackPackValueByType(LPSFET_TYPE_ID));
		pkLastEntry->SetBackPackValueByType(LPSFET_USED_COUNT, iLastEntrySetUseCount);
		m_kPackAsset.UpdateDirtyFlag(iPackType);
	}
	UpdateDirtyFlag(DIRTY_FLAG_SHORTCUT);
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_USE_ITEM);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_NONE);
			pkGameEvent->SetEventParam(EP_USE_ITEM_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_USE_ITEM_TYPE_ID, lItemID);
			pkGameEvent->SetEventParam(EP_USE_ITEM_MAP_ID, GetMapResID());
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	SyncBackPackToClient(PACK_TYPE_BASIC);
	return RE_SUCCESS;
}
void LC_ServerPlayer::_notifyItemTimelimit(LC_BackPackEntry* pkEntry, int32_t deletTime, int32_t curentTime)
{
	if (!IsInstance())
	{
		return;
	}
	if (NULL == pkEntry)
	{
		return;
	}
	MG_Message rltMsg;
	int32_t uiLeftTime = (deletTime - curentTime);
	int32_t uiLeftMin = uiLeftTime / 60;
	if (uiLeftMin <= 60 && uiLeftMin >= 59)
	{
		rltMsg.m_iMessageID = RE_ITEM_TIME_LIMIT_NOTIFY;
		rltMsg.m_iParameter1 = pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
		rltMsg.m_iParameter2 = 60;
		SendMsgToClient(MGPT_MESSAGE, &rltMsg);
	}
	if (uiLeftMin <= 30 && uiLeftMin >= 29)
	{
		rltMsg.m_iMessageID = RE_ITEM_TIME_LIMIT_NOTIFY;
		rltMsg.m_iParameter1 = pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
		rltMsg.m_iParameter2 = 30;
		SendMsgToClient(MGPT_MESSAGE, &rltMsg);
	}
	if (uiLeftMin <= 10 && uiLeftMin >= 9)
	{
		rltMsg.m_iMessageID = RE_ITEM_TIME_LIMIT_NOTIFY;
		rltMsg.m_iParameter1 = pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
		rltMsg.m_iParameter2 = 10;
		SendMsgToClient(MGPT_MESSAGE, &rltMsg);
	}
	if (uiLeftMin <= 1 && uiLeftMin >= 0)
	{
		rltMsg.m_iMessageID = RE_ITEM_TIME_LIMIT_NOTIFY;
		rltMsg.m_iParameter1 = pkEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
		rltMsg.m_iParameter2 = 1;
		SendMsgToClient(MGPT_MESSAGE, &rltMsg);
	}
}

void LC_ServerPlayer::ReduceTranscriptionEnterTimes(int resid)
{

}

bool LC_ServerPlayer::RemovePlayerOrder(std::string& strRedisPrefixPlayerAdd,const std::string& strOrderId)
{
	Utility::Redis_Handler* pkRedisHandler = GetGameServerApp()->GetRedisHandler();
	if (NULL == pkRedisHandler)
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "RemovePlayerOrder pkRedisHandler id null! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}
	ResultType iRet = RE_SUCCESS;
	UT_REDIS_CMD(iRet, pkRedisHandler, hdel, strRedisPrefixPlayerAdd, strOrderId);
	if (iRet != RE_SUCCESS )
		return false;
	return true;
}
bool LC_ServerPlayer::ModifyOrderStatusAnd(std::string& strRedisPrefixOrderId,const std::string& strOrderId)
{
	const unique_id_impl& instance = GetInstance();
	Utility::Redis_Handler* pkRedisHandler = GetGameServerApp()->GetRedisHandler();
	if (NULL == pkRedisHandler)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " ModifyOrderStatusAnd pkRedisHandler is null! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}

	ResultType iRet = RE_SUCCESS;
	UT_REDIS_CMD_BEGIN(iRet, pkRedisHandler);
	redispp::StringReply kResultReply = pkRedisConn->hget(strRedisPrefixOrderId, strOrderId);
	if (kResultReply.result())
	{
		std::string strValue = kResultReply;
		std::string errorMsg;
		Order_info order_info;
		if (boost::ajson::load_from_buff(order_info, strValue.c_str(), errorMsg))
		{
			if(0 == order_info.status)
			{
				// 更新状态
				order_info.status = 1;
				order_info.receiveTimeStamp = time(NULL);

				stringstream strBuff;
				if ( true == boost::ajson::save_to_buff(order_info, strBuff))
				{
					ResultType iRet2 = RE_SUCCESS;
					UT_REDIS_CMD_BEGIN(iRet, pkRedisHandler)
						pkRedisConn->hset(strRedisPrefixOrderId,strOrderId, strBuff.str());
					UT_REDIS_CMD_END(iRet, pkRedisHandler)
						if(RE_SUCCESS == iRet2)
							return true;
				}
				else
				{
					GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ModifyOrderStatusAnd save_to_buff(order_info, strBuff) false! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
						instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
				}
			}
			else
			{
				GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ModifyOrderStatusAnd 1==order_info.status false! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s",
					instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
			}
		}
		else
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ModifyOrderStatusAnd boost::ajson::load_from_buff(order_info, strValue.c_str(), errorMsg) failed! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s",
				instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		}
	}
	else
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " ModifyOrderStatusAnd not had order! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
	}
	UT_REDIS_CMD_END(iRet, pkRedisHandler)
		return false;
}

int32_t LC_ServerPlayer::FetchSinglePay( const std::string& strOrderId )
{
	FetchSinglePayImpl( strOrderId );
	return true;
}

int32_t LC_ServerPlayer::FetchSinglePayImpl(const std::string& strOrderId)
{
	const unique_id_impl& instance = GetInstance();
	Utility::Redis_Handler* pkRedisHandler = GetGameServerApp()->GetRedisHandler();
	if (NULL == pkRedisHandler)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchSinglePayImpl NULL==pkRedisHandler! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s",
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}
	unique_id_type nCharId = GetCharUqID();
	unique_id_impl nCharIdImpl = nCharId;
	ResultType rslt = RE_SUCCESS;
	redispp::StringReply kCodeDefineReply;
	std::string& sRedisServerPrefix = GetGameServerApp()->GetRedisServerPredix(nCharIdImpl.catagory())  + PLATFORM_360_RECHARGE + boost::lexical_cast<std::string>(nCharIdImpl.detail());
	UT_REDIS_CMD_WITH_REPLY(rslt, pkRedisHandler, kCodeDefineReply, hget, sRedisServerPrefix, strOrderId);
	std::string reply;
	if (rslt != RE_SUCCESS || !kCodeDefineReply.result())
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchSinglePayImpl  rslt != RE_SUCCESS || !kCodeDefineReply.result()  c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s",
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}
	if( false == RemovePlayerOrder(sRedisServerPrefix,strOrderId))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchSinglePayImpl  hdel  redis error! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}
	// 更改 :0_10010000:109:360_operation_recharge:orderId status 状态  设置为已领取 1
	std::string& strRedisPrefixOrderId = GetGameServerApp()->GetRedisServerPredix(nCharIdImpl.catagory()) + PLATFORM_360_RECHARGE_ORDER_ID;
	if( false == ModifyOrderStatusAnd(strRedisPrefixOrderId,strOrderId))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchSinglePayImpl  modify OrderStatus redis error! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
			instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
		return false;
	}
	reply = kCodeDefineReply;
	uint64_t nMoney = boost::lexical_cast<uint64_t>(reply);
	return Charge((int32_t)nMoney, SYS_FUNC_TP_CHARGE,strOrderId);
}

int32_t LC_ServerPlayer::FetchAllPay()
{
	FetchAllPayImpl();
	return true;
}

int32_t LC_ServerPlayer::FetchAllPayImpl()
{
	const unique_id_impl& instance = GetInstance();
	Utility::Redis_Handler* pkRedisHandler = GetGameServerApp()->GetRedisHandler();
	if (NULL == pkRedisHandler)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchAllPayImpl  NULL == pkRedisHandler! c_cid:%d, c_citizenship:%d, c_uid:%d", 
			instance.detail(), instance.catagory(), GetUserID());
		return false;
	}
	unique_id_type nCharId = GetCharUqID();
	unique_id_impl nCharIdImpl = nCharId;
	ResultType rslt = RE_SUCCESS;
	std::string& sRedisServerPrefix = GetGameServerApp()->GetRedisServerPredix(nCharIdImpl.catagory())  + PLATFORM_360_RECHARGE + boost::lexical_cast<std::string>(nCharIdImpl.detail());
	std::string& strRedisPrefixOrderId = GetGameServerApp()->GetRedisServerPredix(nCharIdImpl.catagory()) + PLATFORM_360_RECHARGE_ORDER_ID;
	redispp::MultiBulkEnumerator kReplys;
	int32_t ret;
	UT_REDIS_CMD_WITH_REPLY(ret, pkRedisHandler, kReplys, hgetAll, sRedisServerPrefix);
	if ( ret != 0 )
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchAllPayImpl  UT_REDIS_CMD_WITH_REPLY ret error! c_cid:%d, c_citizenship:%d, c_uid:%d, ret:%d",
			instance.detail(), instance.catagory(), GetUserID(), ret);
		return false;
	}
	std::string str;
	uint64_t nMoney = 0;
	int nIndex = 0;
	bool addFlag1 = false;
	bool addFlag2 = false;
	std::string strOrderId = "";
	while (kReplys.next(&str))
	{
		uint64_t nTempMoney = 0;	
		if ( nIndex % 2 == 0 )
		{
			addFlag1 = false;
			addFlag2 = false;
			// order_id
			// Remove
			strOrderId = str;
			if( false == RemovePlayerOrder(sRedisServerPrefix,strOrderId))
			{
				GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchAllPayImpl  hdel  redis error !!!  c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s", 
					instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
				continue;
			}
			else
			{
				addFlag1 =true;
			}
			// 更改 :0_10010000:109:360_operation_recharge:orderId status 状态  设置为已领取 1
			if( false == ModifyOrderStatusAnd(strRedisPrefixOrderId,strOrderId))
			{
				GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, " FetchAllPayImpl  modify OrderStatus redis error! c_cid:%d, c_citizenship:%d, c_uid:%d, strOrderId:%s",
					instance.detail(), instance.catagory(), GetUserID(), strOrderId.c_str());
				continue;
			}
			else
			{
				addFlag2 =true;
			}
		}
		else
		{
			//money
			nTempMoney = boost::lexical_cast<uint64_t>(str);
			if( addFlag1 && addFlag2)
			{
				GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, " FetchAllPayImpl  add money!  c_cid:%d, c_citizenship:%d, c_uid:%d, nTempMoney:%ld, nMoney:%ld, nIndex:%ld, strOrderId:%s",
					instance.detail(), instance.catagory(), GetUserID(), nTempMoney, nMoney, nIndex, strOrderId.c_str());
				nMoney += nTempMoney;
				Charge((int32_t)nTempMoney, SYS_FUNC_TP_CHARGE,strOrderId);
				addFlag1 = false;
				addFlag2 = false;
			}
		}
		nIndex++;
	}
	return nMoney;
}

static bool checkSkill(const LC_SkillAssetEntry& entry, LC_SkillTriggerEntry& t_entry , SK_Factory* pkSkillFactory)
{
	t_entry.Reset();
	if (entry.GetValid())
	{
		int type_id = entry.GetTypeID();
		if (is_normal_attack_skill(type_id))
		{
			t_entry.SetSkillTypeID(type_id);
			t_entry.SetType(STTY_TIME);
			t_entry.SetPriority(1);
			t_entry.SetLifeTime(60.0);
			t_entry.SetData1(0);
			t_entry.SetData2(0);
			t_entry.SetData3(0);
			t_entry.SetCDTime(0.0);
			t_entry.SetValid(true);
			return true;
		}
	}
	return false;
}

static void AddNormalHandAttack(const LC_SkillCategoryData& kCatagoryData , SK_Factory* pkSkillFactory , LC_ActorSkillTrigger* sk , int char_type)
{
	static int snHandSkillIds[] = 
	{
#if 1
		22000001,
		22100001,
		22200001,
		22300001,
		22400001,
		22600001,
		22500001,
		22700001,
		22014001,
		22020001,
		22030001,
#endif

#if 0
		22001001,
		22101001,
		22201001,
		22301001,
		22402001,
		22601001,
		22501001,
		22701001,
		22011001,
		22021001,
		22031001,
		22041001,
#endif
	};
	LC_SkillTriggerEntry t_entry;
	{
		int nSkillIdSize = sizeof(snHandSkillIds) / sizeof(int);

		int32_t nSkillId = SKILL_MAN_NORMAL_ATTACK_HAND;
		if (char_type >= 1 && char_type <= nSkillIdSize)
		{
			nSkillId = snHandSkillIds[char_type - 1];
		}

		t_entry.SetSkillTypeID(nSkillId);
		t_entry.SetType(STTY_TIME);
		t_entry.SetPriority(1);
		//t_entry.SetLifeTime(60.0);
		t_entry.SetLifeTime(600.0);
		t_entry.SetData1(0);
		t_entry.SetData2(0);
		t_entry.SetData3(0);
		t_entry.SetCDTime(0.0);
		t_entry.SetValid(true);
		sk->AddSkill(t_entry);
	}
}

static void checkSkillAssert(const LC_SkillCategoryData& kCatagoryData , SK_Factory* pkSkillFactory , LC_ActorSkillTrigger* sk)
{
	LC_SkillTriggerEntry t_entry;
	const LC_SkillIDVector& kSlots = kCatagoryData.GetSkillSlots();
	int nCount = 0;
	for (int i=0;i<(int)kSlots.size();i++)
	{
		if (kSlots[i] <= 0)
		{
			continue;
		}
		const LC_SkillAssetEntry* pkentry = kCatagoryData.GetSkillAssetEntry(i);
		if(pkentry == NULL || pkentry->GetValid() == false)
		{
			continue;
		}
		if (checkSkill(*pkentry, t_entry, pkSkillFactory))
		{
			sk->AddSkill(t_entry);
		}

	}
}

static void checkShortcutBar(LC_ShortcutBar& asset , SK_Factory* pkSkillFactory , LC_ActorSkillTrigger* sk)
{
	LC_SkillTriggerEntry t_entry;
	for (int i = 0 ; i < MAX_SINGLE_SHORTCUTBAR_SLOT_COUNT ; ++i)
	{
		LC_ShortcutEntry* entry = asset.GetShortcutEntry(1, i);
		if (entry)
		{
			int type_id = entry->GetTypeID();
			if (IS_SKILL_TYPE(type_id))
			{
				SK_SkillExecute* pkSkill = pkSkillFactory->RequestSkillExcute(type_id);
				if (pkSkill)
				{
					if (pkSkill->GetProperty_DamageType() == 2)
					{
						t_entry.SetSkillTypeID(type_id);
						t_entry.SetType(STTY_TIME);
						t_entry.SetPriority(1);
						t_entry.SetLifeTime(60.0);
						t_entry.SetData1(0);
						t_entry.SetData2(0);
						t_entry.SetData3(0);
						t_entry.SetCDTime(pkSkill->GetProperty_CoolDownTime());
						t_entry.SetValid(true);
						sk->AddSkill(t_entry);
					}
				}
			}
		}
	}
}

bool LC_ServerPlayer::NotifyStateEnd(int iEndState, float fCurrentTime, float fDeltaTime)
{
	m_pkSMController->NotifyStateEnd(this, iEndState, fCurrentTime, fDeltaTime);
	return LC_PlayerBase::NotifyStateEnd(iEndState, fCurrentTime, fDeltaTime);
}

void LC_ServerPlayer::FinishPlayerCloneLoad(int nIndex, bool isSoloDuleRobot, uint32_t schemeType, uint32_t groupID)
{
	static LC_ServerWorldManager* inst = SERVER_GET_WORLD_MANAGER();

	//竞技场的机器人不需要InitGameData
	if(!isSoloDuleRobot)
	{
		InitGameData();
	}
	else
	{
		//竞技场机器人只需要计算一次战力
		//TODO
	}

	//填充血量
	LC_ActorAttributeMap* pkAttributeMap = GetFinalAttributeMap();

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	LC_AsAControlee& lee = pOwner->GetAsAControlee();
	Utility::UT_Vec3Int initPos = lee.InitPosition();
	uint32_t nTimeLen = lee.Timelen();
	int32_t nMapLogicId = lee.MapLogicID();
	ModifyOffsetLocationByIndex(nIndex, initPos, 1);
	SetCurrentLocation(initPos);
	SetTargetLocation(initPos);
	SetSpawnLocation(initPos);
	SetLastTranslateTime(GET_PROCESS_TIME);
	SetSurvivalTime(nTimeLen);
	SetSurvivalStartTime(GET_PROCESS_TIME);
	SetSpawnTime(GET_PROCESS_TIME);
	LC_SkillAssetData* data = GetSkillAsset()->GetSkillAssetData();
	LC_ShortcutBar* bardata = GetShortcutBar();
	LC_ActorSkillTrigger* sk =	GetSkillTrigger();
	SK_Factory* pkSkillFactory = SK_Factory::GetSingletonPtr();

	const LC_SkillCategoryMap& kCatagoryMap = data->GetSkillCatagoryMap();

	LC_SkillCategoryMap::const_iterator cit = kCatagoryMap.find((skill_cat_type)SKILL_TYPE_SECT);

	AddNormalHandAttack(cit->second, pkSkillFactory, sk, GetCharType());
	checkSkillAssert(cit->second, pkSkillFactory, sk);

	if(NULL != bardata)
	{
		checkShortcutBar(*bardata, pkSkillFactory, sk);
	}

	//处理公会等信息
	LC_ServerGuildManager::GetSingletonPtr()->CharEnter(this);

	//满血满魔
	long lHP = (long)(pkAttributeMap->GetAttribute(ATT_MAX_HP));
	SetHP(lHP);

	inst->AddObjectToMap(nMapLogicId, this);


	

	PostEnterMap(schemeType,groupID);
}

void LC_ServerPlayer::ExecuteSummonFinishHandle()
{
	if (m_SummonFinishHandle != NULL)
	{
		m_SummonFinishHandle(this);
	}
}
void LC_ServerPlayer::SetSessionOnlineTime( uint32_t nTime )
{
	m_nSessionOnlineTime = nTime;
}

uint32_t LC_ServerPlayer::GetSessionOnlineTime()
{
	return GET_PROCESS_TIME - m_nSessionOnlineTime;
}

bool	LC_ServerPlayer::CheckUnSummorSoon(float current_time)
{
	if (!IsInstance())
	{
		if (m_lSurvivalTime > 0)
		{
			if (current_time - m_fSurvivalStartTime > (m_lSurvivalTime - 1.0))
			{
				return true;
			}
		}
	}
	return false;
}

bool	LC_ServerPlayer::CheckUnSummor(float current_time)
{
	if (!IsInstance())
	{
		if (GetDead() && !LC_Helper::isInArena(this))
		{
			return true;
		}
		if (m_lSurvivalTime > 0)
		{
			if (current_time - m_fSurvivalStartTime > m_lSurvivalTime)
			{
				return true;
			}
		}
	}
	return false;
}

//--------------------------------------------------------
void LC_ServerPlayer::SetMoveLineTargetLocation(const Utility::UT_Vec3Int& kLocation)
{
	m_kMoveLineTargetLocation = kLocation;
}

//--------------------------------------------------------

// Buddy
LC_ServerPlayer* LC_ServerPlayer::GetOwnerPlayer()
{
	if (m_pOwnerPlayer_Cache == NULL)
		m_pOwnerPlayer_Cache = GetOwnerPlayer_Impl();
	return m_pOwnerPlayer_Cache;
}

LC_ServerPlayer* LC_ServerPlayer::GetOwnerPlayer_Impl()
{
	if (m_nOwnerPlayerId == 0)
		return NULL;
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerPlayer* pOwner = (LC_ServerPlayer*)pkWorldManager->FindObject(m_nOwnerPlayerId);
	IF_A_NA_PLAYER(pOwner) 
	{
		//GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "LC_ServerPlayer::GetOwnerPlayer_Impl error! pOwner is NULL objid: %d", m_nOwnerPlayerId);
		return NULL;
	}
	if ( false == pOwner->IsMainController() )
		pOwner->SetMainController(true);
	return pOwner;
}



object_id_type LC_ServerPlayer::GetOwnerPlayerId()
{
	return m_nOwnerPlayerId;
}

bool LC_ServerPlayer::SetOwnerPlayerId(object_id_type nObjId)
{
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerPlayer* pOwner = (LC_ServerPlayer*)pkWorldManager->FindObject(nObjId);
	if (pOwner == NULL)
		return false;

	if (m_kPackAsset.GetController() == NULL)
		m_kPackAsset.SetController(pOwner);
	m_nOwnerPlayerId = nObjId;
	if (!pOwner->IsMainController())
		pOwner->SetMainController(true);

	return true;
}

BuddyInstance* LC_ServerPlayer::CreateSingleBuddyInstance( const CSVFile::CF_Buddy::DataEntry* pTemplate, bool bCreate)
{
	BuddyInstance* pResult = NULL;
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.find(pTemplate->_cID);
	if (it != m_ppUsableBuddyInstance.end() &&  it->second != NULL)
	{
		pResult = it->second;
		return pResult;
	}
	pResult = LoadBuddyData_SingleInstance(pTemplate, bCreate);
	if (pResult == NULL)
	{
		return pResult;
	}

	m_ppUsableBuddyInstance.insert(std::make_pair(pTemplate->_cID, pResult));

	if(bCreate)
	{
		SetProfilePictureFlag(pTemplate->_cID, true);
	}

	return pResult;
}

void LC_ServerPlayer::GetBuddyRecords(mem::vector<GameLogic::BuddyInfo>& records)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if ( pkOwnerPlayer == NULL )
		return;

	mem::map<int32_t, BuddyInstance*>::iterator it = pkOwnerPlayer->m_ppUsableBuddyInstance.begin();
	for(; it!=pkOwnerPlayer->m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
			continue;

		GameLogic::BuddyInfo buddy;
		buddy.buddyID = pkBuddy->GetTemplateID();
		buddy.buddyLevel = pkBuddy->GetLevel();
		buddy.buddyStarLevel = pkBuddy->GetStarLevel();
		buddy.buddyQuailty = pkBuddy->GetQuality();
		buddy.EquipSlotLevel_HEAD = pkBuddy->GetEquipSlotLevelBySlotIndex(ET_HEAD);
		buddy.EquipSlotLevel_BODY = pkBuddy->GetEquipSlotLevelBySlotIndex(ET_BODY);
		buddy.EquipSlotLevel_FOOT = pkBuddy->GetEquipSlotLevelBySlotIndex(ET_FOOT);
		buddy.EquipSlotLevel_NECKLACE = pkBuddy->GetEquipSlotLevelBySlotIndex(ET_NECKLACE);
		buddy.EquipSlotTotalLevel = pkBuddy->GetEquipSlotTotalLevel();

		buddy.EquipSlotStarLevel_HEAD = pkBuddy->GetEquipSlotStarLevelBySlotIndex(ET_HEAD);
		buddy.EquipSlotStarLevel_BODY = pkBuddy->GetEquipSlotStarLevelBySlotIndex(ET_BODY);
		buddy.EquipSlotStarLevel_FOOT = pkBuddy->GetEquipSlotStarLevelBySlotIndex(ET_FOOT);
		buddy.EquipSlotStarLevel_NECKLACE = pkBuddy->GetEquipSlotStarLevelBySlotIndex(ET_NECKLACE);

		records.push_back(buddy);
	}
}

int LC_ServerPlayer::GetActivateBuddyCount()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return 0;

	if (!IsMainController())
		return pOwner->GetActivateBuddyCount();
	return m_nAllocatedActivateBuddyCount;
}

int LC_ServerPlayer::GetUnlockedActivateBuddyCount()
{
	return m_nUnlockedActivateBuddyCount;
}

//m_nActivateBuddyInSceneCount
int LC_ServerPlayer::IncActivateBuddyInSceneCount()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->IncActivateBuddyInSceneCount();
	}
	m_nActivateBuddyInSceneCount++;
	if ( m_nActivateBuddyInSceneCount >= m_nAllocatedActivateBuddyCount )
	{
		SetDirtyFlag(DIRTY_FLAG_PROPERTY, true);
	}
	return true;
}


int LC_ServerPlayer::IncUnlockedActivateBuddyCount()
{
	if ( m_nUnlockedActivateBuddyCount < MAX_ACTIVE_BUDDY_NUM )
		m_nUnlockedActivateBuddyCount++;

	return m_nUnlockedActivateBuddyCount;
}

void LC_ServerPlayer::InitUnlockedActivateBuddyCount()
{
	m_nUnlockedActivateBuddyCount = 1;
}

void LC_ServerPlayer::OnRefreshPlayerLevel_UnlockActivateBuddy(bool loginIn)
{
	int32_t nLevel = GetLevel();
	CF_BuddyUnlock* pConfig = CF_BuddyUnlock::GetSingletonPtr();

	int32_t nOrigCount = m_nUnlockedActivateBuddyCount;
	CF_BuddyUnlock::DataEntryMapExternIterator it = pConfig->GetIterator();
	while( it.HasMoreElements() )
	{
		const CF_BuddyUnlock::DataEntry* pkData = it.PeekNextValuePtr();
		if (pkData->_UnlockLevel <= nLevel && m_nUnlockedActivateBuddyCount < pkData->_iID + 1)
			m_nUnlockedActivateBuddyCount = pkData->_iID + 1;

		it.MoveNext();
	}

	if(!loginIn && nOrigCount!=m_nUnlockedActivateBuddyCount)
	{
		SyncBuddyData_ActivateCount();
	}
}

BuddyInstance* LC_ServerPlayer::GetBuddyInstanceByID(int32_t nID)
{
	BuddyInstance* pResult = NULL;
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.find(nID);
	if ( it != m_ppUsableBuddyInstance.end() )
		pResult = it->second;
	return pResult;
}

BuddyInstance* LC_ServerPlayer::GetAssignedBuddyInstance()
{
	return m_pAssignedBuddyInstance;
}
void LC_ServerPlayer::SyncBuddyAttribute()
{
	if(m_pAssignedBuddyInstance)
		m_pAssignedBuddyInstance->SyncBuddyAttributes(SPAT_BuddyAllAttr,*(m_pAssignedBuddyInstance->GetNewFinalAttributeMap()), false, m_pAssignedBuddyInstance->GetBuddyAttrMgr().GetBuddyCombatScoreByType(BCST_FinalBuddy), 0);
}
void LC_ServerPlayer::SetOpenLevelCheat(bool bFlag)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
		return pOwner->SetOpenLevelCheat(bFlag);

	return LC_PlayerBase::SetOpenLevelCheat(bFlag);
}

bool LC_ServerPlayer::GetOpenLevelCheat()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->GetOpenLevelCheat();

	return LC_PlayerBase::GetOpenLevelCheat();
}


bool LC_ServerPlayer::CheckBuddyControllerUpdate_Fight(float fCurrent, float fDeltaTime)
{
	if ( fCurrent - m_fLastBuddyControllerUpdate_Fight > fDeltaTime )
		return true;

	return false;
}

void LC_ServerPlayer::SetBuddyControllerUpdate_Fight(float fCurrent)
{
	m_fLastBuddyControllerUpdate_Fight = fCurrent;
}

void LC_ServerPlayer::SetFollowBaseLocation(const Utility::UT_Vec3Int& rkLocation)
{
	m_kBaseFollowLocation = rkLocation;
}

const Utility::UT_Vec3Int& LC_ServerPlayer::GetFollowBaseLocation()
{
	return m_kBaseFollowLocation;
}

void LC_ServerPlayer::SetFollowBaseTargetLocation(const Utility::UT_Vec3Int& rkLocation)
{
	m_kBaseTargetFollowLocation = rkLocation;
}

const Utility::UT_Vec3Int& LC_ServerPlayer::GetFollowBaseTargetLocation()
{
	return m_kBaseTargetFollowLocation;
}

void LC_ServerPlayer::SetFollowLocation(const Utility::UT_Vec3Int& rkLocation, bool bCombat, object_id_type nTargetId)
{
	m_kFollowLocation = rkLocation;
	m_bFollowMode_Combat = bCombat;
	m_nFollowTargetObjId = nTargetId;
}

bool LC_ServerPlayer::GetFollowMode_Combat()
{
	return m_bFollowMode_Combat;
}

object_id_type LC_ServerPlayer::GetFollowTargetObjectId()
{
	return m_nFollowTargetObjId;
}

const Utility::UT_Vec3Int& LC_ServerPlayer::GetFollowLocation()
{
	return m_kFollowLocation;
}

void LC_ServerPlayer::_TryRecoverDeadState()
{
	//return;
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
		return pOwner->_TryRecoverDeadState();

	if ( m_bRecoverFromSoloPlay == false || m_bSoloDulePlay == true)
		return;

	m_bRecoverFromSoloPlay = false;
#if 1

	SetOwnerReliveFlag_Recover(true);
	ReliveAllBuddy(RELIVE_NOW, true);
	SetOwnerReliveFlag_Recover(false);
#endif
}

void LC_ServerPlayer::_UpdateForBuddyDebug(float fCurrent, float fDeltaTime)
{
	// 这个函数不需要任意player都可以调用
	// 并且正式逻辑不需要
	if (m_bBuddyAIParam_DebugMode == false)
		return;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->_UpdateForBuddyDebug( fCurrent,fDeltaTime);
	LC_ServerPlayer* pCurrentBuddy = pkOwnerPlayer->GetActivateBuddyByIndex(m_nCurrentBuddyIndex);
	IF_A_NA_PLAYER(pCurrentBuddy) 
		return;

	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		if (m_nCurrentBuddyIndex == i)
			continue;
		LC_ServerPlayer* pResultPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		object_id_type nBuddyId = pResultPlayer->m_iID;
		int nDistance = UT_MathBase::LineLengthXYInt( pResultPlayer->GetCurrentLocation() , pCurrentBuddy->GetCurrentLocation());
		Utility::UT_Vec3Int srcPos = pCurrentBuddy->GetCurrentLocation();
		Utility::UT_Vec3Int dstPos = pResultPlayer->GetCurrentLocation();

	}
}

// pBuddyActor follow this..
bool LC_ServerPlayer::CalcAdvanceFollowLocationImpl( LC_ServerPlayer* pBuddyActor, int nRelativeIndex, int nRadius, Utility::UT_Vec3Int& rkResult )
{
	if ( nRelativeIndex < eRelativeIndex_A || nRelativeIndex > eRelativeIndex_B )
		return false;


	// If base did not change, just return.
	if (m_kCurrentLocation == pBuddyActor->GetFollowBaseLocation())
	{

		rkResult = pBuddyActor->GetFollowBaseTargetLocation();
		return true;
	}


	rkResult = UT_MathBase::FixInCircleInt( m_kCurrentLocation, GetForwardDirAngle(), GetGlobalSetting.nStopFollowDistance, nRelativeIndex, GetGlobalSetting.nBuddyFollowAngle );
	pBuddyActor->SetFollowBaseLocation(m_kCurrentLocation);
	pBuddyActor->SetFollowBaseTargetLocation(rkResult);
	int nDistance = UT_MathBase::LineLengthXYInt( m_kCurrentLocation , rkResult);
	// Check with path finder
	PF_ServerPathManager* pathmanager=PF_ServerPathManager::GetSingletonPtr();
	if (pathmanager==NULL)
	{
		return true;
	}
	int nMapResId = GetMapResID();
	int nRetryCount = 0;
	while (!pathmanager->IsPosValid(nMapResId,rkResult))
	{
		nRetryCount++;
		UT_PathFindHelp::GenRandomPosInCircle2(nMapResId, rkResult,GetGlobalSetting.nMaxBuddyFollowDistance,rkResult);
		if (nRetryCount > 10)
			break;
	}

	return true;
}

bool LC_ServerPlayer::CalcAdvanceFollowLocation( LC_ActorBase* pBuddyActor, int nRadius, Utility::UT_Vec3Int& rkResult )
{
	object_id_type nOwnerId = pBuddyActor->GetOwnerObjectID();
	if (nOwnerId != GetOwnerObjectID())
		return false;

	if ( pBuddyActor->GetType() != LOT_PLAYER )
		return false;

	float fNow = GET_PROCESS_TIME;
	// pBuddyActor 尝试跟随 this
	LC_ServerPlayer* pBuddyPlayer = (LC_ServerPlayer*)pBuddyActor;
	int nRelativeIndex = GetBuddyRelativeIndex(pBuddyPlayer->m_nIndexAsBuddy);
	bool bRet = CalcAdvanceFollowLocationImpl( pBuddyPlayer, nRelativeIndex, nRadius, rkResult );	

	return bRet;
}

void LC_ServerPlayer::SetBuddyLocation( Utility::UT_Vec3Int& pos )
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;
	m_pOwnerPlayer->SetBuddyLocationImpl(pos);
}

void LC_ServerPlayer::SetBuddyLocationImpl(Utility::UT_Vec3Int& pos)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->SetBuddyLocationImpl( pos);

	LC_ServerPlayer* pCurrentBuddy = pkOwnerPlayer->GetActivateBuddyByIndex(m_nCurrentBuddyIndex);
	IF_A_NA_PLAYER(pCurrentBuddy) 
		return;

	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		if (m_nCurrentBuddyIndex == i)
			continue;
		LC_ServerPlayer* pResultPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		
		Utility::UT_Vec3Int dstPos;
		bool bRet = pCurrentBuddy->CalcAdvanceFollowLocation(pResultPlayer, GetGlobalSetting.nStopFollowDistance, dstPos );
		if (bRet == false)
			continue;
		pResultPlayer->SetCurrentLocation(dstPos);
		pResultPlayer->SetTargetLocation(dstPos);
		pResultPlayer->SetLastMoveCheckLocation(dstPos);
		pResultPlayer->SetSyncPlayerMove(false);
	}
}

void LC_ServerPlayer::ResetAllBuddyAIParam()
{
	m_bBuddyAIParam_ForceFollowMode = false;
	m_bBuddyAIParam_DebugMode = false;
	m_bBuddyAIParam_AttackMode = false;
	m_bBuddyAIParam_ControllerDebugMode = false;
	m_bBuddyAIParam_FollowAttackMode = false;
}

void LC_ServerPlayer::SetBuddyAIParam_ForceFollowMode( bool bFlag )
{
	m_bBuddyAIParam_ForceFollowMode = bFlag;
}

bool LC_ServerPlayer::GetBuddyAIParam_ForceFollowMode()
{
	return m_bBuddyAIParam_ForceFollowMode;
}

void LC_ServerPlayer::SetBuddyAIParam_AttackMode( bool bFlag )
{
	m_bBuddyAIParam_AttackMode = bFlag;
}

bool LC_ServerPlayer::GetBuddyAIParam_AttackMode()
{
	return m_bBuddyAIParam_AttackMode;
}

void LC_ServerPlayer::SetBuddyAIParam_DebugMode( bool bFlag )
{
	m_bBuddyAIParam_DebugMode = bFlag;
}

void LC_ServerPlayer::SetBuddyAIParam_FollowAttackMode( bool bFlag )
{
	m_bBuddyAIParam_FollowAttackMode = bFlag;
}

bool LC_ServerPlayer::GetBuddyAIParam_FollowAttackMode()
{
	return m_bBuddyAIParam_FollowAttackMode;
}

bool LC_ServerPlayer::GetBuddyAIParam_DebugMode()
{
	return m_bBuddyAIParam_DebugMode;
}

LC_ServerPlayer::BUDDY_ACTION_TYPE LC_ServerPlayer::GetBuddyActionType()
{
	return m_eBuddyActionType;
}

int LC_ServerPlayer::SetBuddyActionType(BUDDY_ACTION_TYPE nType)
{
	return 1;
}

int LC_ServerPlayer::GetBuddyControllerDebugMode(int nIndex)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return -1;
	if (!IsMainController())
		return pOwner->GetBuddyControllerDebugMode(nIndex);

	if (nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM)
		return -1;

	LC_ServerPlayer* pBuddy = pOwner->GetActivateBuddyByIndex(nIndex);
	IF_A_NA_PLAYER(pBuddy) 
		return -1;

	return pBuddy->m_bBuddyAIParam_ControllerDebugMode;

}

void LC_ServerPlayer::SetBuddyControllerDebugMode(int nIndex, int nMode)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return;
	if (!IsMainController())
		return pOwner->SetBuddyControllerDebugMode(nIndex, nMode);
	if (nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM)
		return;
	LC_ServerPlayer* pBuddy = GetActivateBuddyByIndex(nIndex);
	IF_A_NA_PLAYER(pBuddy)
		return;
	pBuddy->m_bBuddyAIParam_ControllerDebugMode = nMode;
}

void LC_ServerPlayer::SetDenyMove(bool bFlag)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_ActorBase::SetDenyMove(bFlag);

	if (!IsMainController())
	{
		return pOwner->SetDenyMove( bFlag );
	}

	return LC_ActorBase::SetDenyMove(bFlag);
}

bool LC_ServerPlayer::GetDenyMove()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_ActorBase::GetDenyMove();

	if (!IsMainController())
	{
		return pOwner->GetDenyMove();
	}

	return LC_ActorBase::GetDenyMove();
}

bool LC_ServerPlayer::EnableGuildFightTowerBuff()
{
	for(int i=0; i<GetGlobalSetting.GuildFightTowerBuffMapId.size(); ++i)
	{
		int MapId = GetGlobalSetting.GuildFightTowerBuffMapId[i];
		if(m_lMapResID == MapId)
			return true;
	}
	return false;
}

void LC_ServerPlayer::SetMouseLocation(const Utility::UT_Vec3Int& rkLocation)
{
	m_kMouseLocation = rkLocation;
}

const Utility::UT_Vec3Int& LC_ServerPlayer::GetMouseLocation()
{
	return m_kMouseLocation;
}

void LC_ServerPlayer::SetDenyDead(bool bDenyDead)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_ActorBase::SetDenyDead(bDenyDead);

	if (!IsMainController())
	{
		return pOwner->SetDenyDead( bDenyDead );
	}

	return LC_ActorBase::SetDenyDead(bDenyDead);
}

bool LC_ServerPlayer::GetDenyDead()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_ActorBase::GetDenyDead();

	if (!IsMainController())
	{
		return pOwner->GetDenyDead();
	}

	return LC_ActorBase::GetDenyDead();
}


void LC_ServerPlayer::UpdateBuddyAction( float fCurrent, float fDelta )
{

}

int LC_ServerPlayer::EnterBuddyAction( BUDDY_ACTION_TYPE nType )
{
	return true;
}

int LC_ServerPlayer::LeaveBuddyAction( BUDDY_ACTION_TYPE nType )
{
	return true;
}

int LC_ServerPlayer::GetBuddyAbsoluteIndex()
{
	return m_nIndexAsBuddy;
}

int LC_ServerPlayer::GetBuddyRelativeIndex( int nBuddyIndex )
{
	int nResult = eRelativeIndex_Error;
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return nResult;

	if (nBuddyIndex < 0 || nBuddyIndex >= MAX_ACTIVE_BUDDY_NUM)
		return nResult;
	switch (nBuddyIndex)
	{
	case 0:
		nResult = eRelativeIndex_A;
		break;
	case 1:
		{
			if (nBuddyIndex > m_pOwnerPlayer->m_nCurrentBuddyIndex)
				nResult = eRelativeIndex_A;
			if (nBuddyIndex < m_pOwnerPlayer->m_nCurrentBuddyIndex)
				nResult = eRelativeIndex_B;
		}
		break;
	case 2:
		nResult = eRelativeIndex_B;
		break;
	default:
		break;
	}

	return nResult;
}

bool LC_ServerPlayer::GetLogicCombatFlag()
{
	return m_bLogicCombatFlag_Cache;
}

void LC_ServerPlayer::SetLogicCombatFlag( bool bFlag )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;
	if (!IsMainController())
		return pOwner->SetLogicCombatFlag( bFlag );

	m_bLogicCombatFlag = bFlag;
	m_bLogicCombatFlag_Cache = bFlag;
}

LC_ServerPlayer* LC_ServerPlayer::GetActivateBuddyByIndex(uint32_t nIndex)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		IF_A_NA_PLAYER(pOwner) 
			return NULL;
		return pOwner->GetActivateBuddyByIndex(nIndex);
	}
	if (nIndex >= MAX_ACTIVE_BUDDY_NUM || nIndex >= m_ppActivateBuddyDataPtr.size())
		return NULL;
	return m_ppActivateBuddyDataPtr[nIndex];
}

LC_ServerPlayer* LC_ServerPlayer::GetActivateBuddyByID(uint32_t nBuddyID)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		IF_A_NA_PLAYER(pOwner) 
			return NULL;
		return pOwner->GetActivateBuddyByID(nBuddyID);
	}
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM ; i++ )
	{
		LC_ServerPlayer* pResult = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResult) 
			continue;
		if(pResult->m_nBuddyTemplateId == nBuddyID)
			return pResult;
	}
	return NULL;
}

void LC_ServerPlayer::GetAllBuddyPtrPlayer(std::vector<LC_ServerPlayer*>& vecBuddyPtrPlayer)
{
	if (!IsMainController())
		return;
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM ; i++ )
	{
		LC_ServerPlayer* pResult = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResult) 
			continue;
		vecBuddyPtrPlayer.push_back(pResult);
	}
}
bool LC_ServerPlayer::GetActivateBuddyPtr(LC_ActorPtrList& vecPtrList)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner)
	{
		LC_ActorBase::GetActivateBuddyPtr(vecPtrList);
		return false;
	}

	vecPtrList.clear();
	mem::vector<int32_t> vecBuddyIDs;
	pOwner->GetActivateBuddyIDs( vecBuddyIDs);
	for (int i = 0; i < vecBuddyIDs.size(); i++)
	{
		LC_ServerPlayer* pBuddy = pOwner->GetActivateBuddyByID(vecBuddyIDs[i]);
		if (pBuddy == NULL)
			continue;
		vecPtrList.push_back(pBuddy);
	}
	return true;
}

void LC_ServerPlayer::GetAllBuddyInstnace(mem::vector<BuddyInstance*>& vecAllBuddys)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
	{
		return pOwner->GetAllBuddyInstnace( vecAllBuddys );
	}
	vecAllBuddys.clear();
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		BuddyInstance* pData = it->second;
		if ( pData )
			vecAllBuddys.push_back( pData );
	}

	return;
}

void LC_ServerPlayer::GetActivateBuddyIDs(std::vector<int32_t>& vecBuddyIDs)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
	{
		return pOwner->GetActivateBuddyIDs( vecBuddyIDs );
	}
	for ( int i = 0; i < m_ppActivateBuddyTemplateId.size(); i++)
	{
		if ( m_ppActivateBuddyTemplateId[i] == INVALID_ACTOR_ID )
			continue;
		vecBuddyIDs.push_back(m_ppActivateBuddyTemplateId[i]);
	}

	return;
}

void LC_ServerPlayer::GetActivateBuddyIDs(mem::vector<int32_t>& vecBuddyIDs)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
	{
		return pOwner->GetActivateBuddyIDs( vecBuddyIDs );
	}
	for ( int i = 0; i < m_ppActivateBuddyTemplateId.size(); i++)
	{
		if ( m_ppActivateBuddyTemplateId[i] == INVALID_ACTOR_ID )
			continue;
		vecBuddyIDs.push_back(m_ppActivateBuddyTemplateId[i]);
	}

	return;
}

const mem::map<int32_t, BuddyInstance*>*LC_ServerPlayer::GetUsableBuddyMap()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return NULL;
	if (!IsMainController())
		return pOwner->GetUsableBuddyMap();
	return &m_ppUsableBuddyInstance;
}


int32_t LC_ServerPlayer::GetCurrentActivateBuddyID()
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer) 
		return 0;
	if (!IsMainController())
		return pOwnerPlayer->GetCurrentActivateBuddyID();
	if (m_ppActivateBuddyDataPtr.size() == 0)
		return 0;
	LC_ServerPlayer* pResultPlayer = pOwnerPlayer->GetActivateBuddyByIndex(m_nCurrentBuddyIndex);
	IF_A_NA_PLAYER(pResultPlayer) 
		return 0;
	return pResultPlayer->GetBuddyID();
}

LC_ServerPlayer* LC_ServerPlayer::GetCurrentActivateBuddy()
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer) 
		return NULL;
	if (!IsMainController())
		return pOwnerPlayer->GetCurrentActivateBuddy();
	if (m_ppActivateBuddyDataPtr.size() == 0)
		return NULL;
	LC_ServerPlayer* pResultPlayer = pOwnerPlayer->GetActivateBuddyByIndex(m_nCurrentBuddyIndex);
	IF_A_NA_PLAYER(pResultPlayer) 
		return NULL;
	return pResultPlayer;
}

LC_ServerPlayer* LC_ServerPlayer::GetNormalCurrentActivateBuddy()
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer) 
		return NULL;
	if (!IsMainController())
		return pOwnerPlayer->GetNormalCurrentActivateBuddy();
	if (m_ppActivateBuddyDataPtr.size() == 0)
		return NULL;
	LC_ServerPlayer* pResultPlayer = pOwnerPlayer->GetActivateBuddyByIndex(0);
	IF_A_NA_PLAYER(pResultPlayer) 
		return NULL;
	return pResultPlayer;
}

int32_t LC_ServerPlayer::GetCurrentActivateBuddyIndex()
{
	return m_nCurrentBuddyIndex;
}

bool LC_ServerPlayer::IsActivateBuddy(int32_t buddyCID)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer)
	{
		return false;
	}

	if (!IsMainController())
	{
		return pOwnerPlayer->IsActivateBuddy(buddyCID);
	}

	for(int i=0; i<m_ppActivateBuddyDataPtr.size(); ++i)
	{
		LC_ServerPlayer* pkPlayer = m_ppActivateBuddyDataPtr[i];
		IF_A_NA_PLAYER(pkPlayer)
		{
			continue;
		}

		BuddyInstance* pkBuddy = pkPlayer->GetAssignedBuddyInstance();
		if(NULL!=pkBuddy && pkBuddy->GetTemplateID()==buddyCID)
		{
			return true;
		}
	}
	
	return false;
}

bool LC_ServerPlayer::IsCurrentActivateBuddy()
{
	return (this == GetCurrentActivateBuddy());
}

SingleBuddyData* LC_ServerPlayer::GetUsableBuddyByTemplateID(int32_t nTemplateId)
{
	SingleBuddyData* pResult = NULL;
	for (int i = 0; i < m_ppUsableBuddyData.size(); i++)
	{
		if (nTemplateId == m_ppUsableBuddyData[i].nBuddyTemplateId && m_ppUsableBuddyData[i].bUnlock == true)
		{
			pResult = &m_ppUsableBuddyData[i];
			break;
		}
	}
	return pResult;
}

bool LC_ServerPlayer::CheckUnlockedBuddyByTemplateID(int32_t nTemplateId)
{
	bool bResult = false;
	//return false;
	if (CheckUsableBuddyByTemplateID(nTemplateId))
		bResult = true;
	if (CheckActivateBuddyByTemplateID(nTemplateId))
		bResult = true;

	return bResult;
}

bool LC_ServerPlayer::CheckUsableBuddyByTemplateID(int32_t nTemplateId)
{
	mem::map<int32_t, SingleBuddyData>::iterator it = m_ppUsableBuddyData.find(nTemplateId);
	if ( it == m_ppUsableBuddyData.end() )
		return false;
	else
	{
		if ( it->second.bUnlock == true )
			return true;
		else
			return false;
	}

}

bool LC_ServerPlayer::CheckActivateBuddyByTemplateID(int32_t nTemplateId)
{
	if (nTemplateId == INVALID_ACTOR_ID)
		return false;
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM && i < m_ppActivateBuddyTemplateId.size(); i++ )
	{
		if ( nTemplateId == m_ppActivateBuddyTemplateId[i] )
			return true;
	}
	return false;
}

void LC_ServerPlayer::SetControlType(PLAYER_CONTROL_TYPE nType)
{
	if ( nType == m_nPlayerControlType )
		return;

	if (nType != eControlType_Buddy && nType != eControlType_Player)
		return;

	m_nPlayerControlType = nType;
	switch (m_nPlayerControlType)
	{
	case eControlType_Player:
		SwitchSMToPlayer();
		break;
	case eControlType_Buddy:
		SwitchSMToBuddy();
		break;
	default:
		break;
	}
}

int LC_ServerPlayer::SetBuddyLevel(int lLevel)
{
	int nResult = false;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;
	return nResult;
}

int32_t LC_ServerPlayer::GetBuddyLevel()
{
	int32_t nResult = 0;

	if (m_pAssignedBuddyInstance == NULL)
		return nResult;
	nResult = m_pAssignedBuddyInstance->GetLevel();
	return nResult;
}

int32_t LC_ServerPlayer::GetBuddyID()
{
	return m_nBuddyTemplateId;
}

void LC_ServerPlayer::OnRefreshBuddyLevel( int32_t nBuddyId, int nCurLevel)
{
	InitDataAsBuddy(m_nBuddyTemplateId, false);
	SingleBuddyData* pData = GetUsableBuddyByTemplateID( nBuddyId );
	if (pData)
	{
		pData->nLevel = nCurLevel;
	}
}

int LC_ServerPlayer::TryBuddyLevelUp( int32_t nBuddyId )
{
	int nResult = false;
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		goto Exit0;

	if ( !IsMainController() )
		return pOwner->TryBuddyLevelUp(nBuddyId);

	BuddyInstance* pInstance = GetBuddyInstanceByID( nBuddyId );
	if (pInstance == NULL)
		goto Exit0;
	nResult = pInstance->TryManualLevelUp();
Exit0:
	MG_RLT_BuddyManualLevelUp result;
	result.m_nBuddyID = nBuddyId;
	result.m_nErrorCode = nResult;
	SendMsgToClient(MGPT_RTL_BUDDY_MANUAL_LEVEL_UP, &result);
	return nResult;
}

int32_t LC_ServerPlayer::UpgradeBuddyInstanceStar(int32_t nBuddyID)
{
	mem::map<int, int, std::greater<int32_t> > records;
	int32_t nResult = false;
	BuddyInstance* pInstance = NULL;
	int32_t nErrorCode = RE_BUDDY_ERROR_NO_INSTANCE;

	CF_BuddyUpgrade::DataEntry* pCfg = NULL;
	CF_BuddyUpgrade::DataEntry* pNextCfg = NULL;
	int32_t nCurLevel = 0;
	int32_t nNextLevel = 0;
	Utility::UT_SIMDataList kItemReq;

	Utility::UT_SIMDataList::iterator it;

	MG_RLT_BuddyStarUpgrade data;
	data.m_nErrorCode = nErrorCode;
	data.m_nBuddyID = nBuddyID;
	data.m_lPlayerID = GetID();
	LC_ServerPlayer* pOwner = GetOwnerPlayer();

	vector<int> nParams;
	nParams.clear();

	if (pOwner == NULL)
		goto Exit0;

	pInstance = GetBuddyInstanceByID(nBuddyID);
	if (pInstance == NULL)
		goto Exit0;
	if(pInstance->GetLevel() < GetGlobalSetting.BuddyStarLevelLimit)
		goto Exit0;
	nCurLevel = pInstance->GetStarLevel();
	nNextLevel = nCurLevel + 1;
	CF_Buddy::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Buddy>(nBuddyID);
	if(NULL == pkData)
	{
		return RE_BUDDY_ERROR_BUY_NO_TEMPLATE;
	}

	if ( nNextLevel > pkData->_MaxLevel )
	{
		return RE_BUDDY_ERROR_STAR_NO_LEVEL;
	}

	pCfg = const_cast<CSVFile::CF_BuddyUpgrade::DataEntry*>(BuddyHelper::GetBuddyUpgradeData(nBuddyID, nCurLevel ));
	pNextCfg = const_cast<CSVFile::CF_BuddyUpgrade::DataEntry*>(BuddyHelper::GetBuddyUpgradeData(nBuddyID, nNextLevel));
	if (pCfg == NULL || pNextCfg == NULL)
	{
		data.m_nErrorCode = RE_BUDDY_ERROR_STAR_NO_LEVEL;
		goto Exit0;
	}

	Utility::ParseFmtString2DataIFs(pCfg->_needitem, kItemReq);
	int32_t nAppendixItem = pCfg->_SpareItems;
	int32_t nAppendixCount = 0;
	int nFoundCount = 0;
	bool bItemLess = false;
	it = kItemReq.begin();
	// Item Checking..
	for (; it != kItemReq.end(); ++it)
	{
		UT_SIMDataInfo info = *it;
		int32_t nItemId = info.GetSkillID();
		int32_t nItemCount = info.GetSkillEnableLevel();
		nFoundCount = GetPackAsset()->GetItemCountInPack(PACK_TYPE_BASIC, nItemId);
		if ( nFoundCount < nItemCount )
		{
			int nAppendixCountNeed = nItemCount - nFoundCount;
			if ( nAppendixItem != INVALID_ITEM_ID )
			{
				nAppendixCount = GetPackAsset()->GetItemCountInPack(PACK_TYPE_BASIC, nAppendixItem);
				if ( nAppendixCount < nAppendixCountNeed )
				{
					bItemLess = true;
				}
				else
				{
					nAppendixCount = nAppendixCountNeed;
				}
			}
			else
			{
				bItemLess = true;
			}

			if ( bItemLess )
			{
				data.m_nErrorCode = RE_BUDDY_ERROR_STAR_NO_RESOURCE;
				goto Exit0;
			}
		}
		else
		{
			nFoundCount = nItemCount;
		}
	}

	// Money Checking
	if ( GetUnBindCash().GetMoney() < pCfg->_needgold )
	{
		data.m_nErrorCode = RE_UNBIND_CASH_NOT_ENOUGH;
		goto Exit0;
	}
	//埋点日志
	nParams.push_back(nBuddyID);
	nParams.push_back(nCurLevel);
	nParams.push_back(nNextLevel);
	int32_t nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, BUDDY_OPERATE, OPERATE_LOGTYPE3);
	// Item Reducing
	it = kItemReq.begin();
	for (; it != kItemReq.end(); ++it)
	{
		UT_SIMDataInfo info = *it;
		int32_t nItemId = info.GetSkillID();
		DeleteItem(nItemId, nFoundCount,nLogCode, nParams);
	}

	if (nAppendixCount > 0 && nAppendixItem > 0)
	{
		DeleteItem(nAppendixItem, nAppendixCount, nLogCode, nParams);
	}

	// Mondy Reducing
	ReduceCash(pCfg->_needgold, CT_UNBIND_CASH, SYS_FUNC_TP_BUDDY_STAR_LEVEL, nBuddyID,nLogCode, nParams);
	// just a impl.
	pInstance->DoUpgradeStar();

	if (pInstance->IsBind())
		BroadcastBuddyStarLevel(pInstance->GetAssignedPlayerId(), nBuddyID, pInstance->GetStarLevel());

	data.m_nErrorCode = RE_BUDDY_ERROR_STAR_OK;
	pInstance->GetBuddyAttrMgr().RefreshLevelAttrMap(this,pInstance);
	pInstance->GetBuddyAttrMgr().RefreshHeroAllAttributeMap(this,pInstance);
	//刷新此英雄 提供的灵魂链属性
	pInstance->GetBuddyAttrMgr().RefreshHeroGiveToOtherCoreAttrMap(this);
	//刷新灵魂链上玩家获得灵魂链属性
	RefreshChainBuddyCoreAttrByOnChain(pInstance->GetTemplateID(), false, SPART_Buddy_1);
	pInstance->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this,pInstance, false, SPART_Buddy_1);
Exit0:

	SendMsgToClient(MGPT_RLT_BUDDY_STAR_UPGRADE, &data);
	nResult = true;
	return nResult;
}

void LC_ServerPlayer::OnRefreshPlayerLevel(bool loginIn)
{
	// Refresh buddy to update level
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;
	OnRefreshPlayerLevel_UnlockActivateBuddy(loginIn);
	OnRefreshPlayerLevel_UnlockSkillBookSlot(loginIn);
}

LC_ServerPlayer::PLAYER_CONTROL_TYPE LC_ServerPlayer::GetControlType()
{
	return m_nPlayerControlType;
}
void LC_ServerPlayer::UpdateHpAndSetDeadState()
{
	if (GetHP() > 0 && GetDead() == true)
	{
		OnBuddyRelive(GetID());
		SetDead(false);
	}
}

int LC_ServerPlayer::PushBuddyInstance(LC_ServerPlayer* pBuddy, int nIndex, bool bCreation)
{
	if (pBuddy == NULL)
		return false;
	if (nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM )
		return false;
	int nRetCode = pBuddy->InitBuddyInstanceData(NULL, nIndex, bCreation);
	if (nRetCode == false)
		return false;
	if(!bCreation)
	{
		attr_value_type iMAXHP = pBuddy->GetFinalAttributeMap()->GetAttribute(ATT_MAX_HP);
		pBuddy->SetHP(iMAXHP);
		UpdateHpAndSetDeadState();
	}

	if (m_ppActivateBuddyDataPtr[nIndex] == NULL)
		m_nAllocatedActivateBuddyCount++;
	m_ppActivateBuddyDataPtr[nIndex] = pBuddy;
	m_ppActivateBuddyObjectId[nIndex] = pBuddy->GetID();
	return true;
}

int LC_ServerPlayer::InitBuddyInstanceData(BuddyInstance* pBuddy, int nIndex, bool bCreation)
{
	if ( nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM )
		return false;
	int32_t nBuddyTid = GetOwnerPlayer()->m_ppActivateBuddyTemplateId[nIndex];
	if (nBuddyTid == INVALID_ACTOR_ID)
		return false;
	m_kCharType.set(nBuddyTid);
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == false)
		return false;
	m_pAssignedBuddyInstance = pOwner->GetBuddyInstanceByID(nBuddyTid);
	if (m_pAssignedBuddyInstance == NULL)
		return false;
	m_pDynamicSkillAsset = m_pAssignedBuddyInstance->GetSkillAsset();
	m_nIndexAsBuddy = nIndex;
	m_pAssignedBuddyInstance->InitInstanceData();
	InitBuddyLogicData_ServerPlayer(pBuddy, nBuddyTid);
	//pBuddy
	InitDataAsBuddy(nBuddyTid, bCreation);
	// sync to BuddyInstance
	// impl first, refactory later.
	return true;
}

void LC_ServerPlayer::SetCurrentOpBuddy(int32_t nBuddyId)
{
	m_nCurrentOpBuddyId = nBuddyId;
}

bool LC_ServerPlayer::AddExpWithGamePlay(attr_value_type lExp, int32_t eSrcType, int lSrcTypeID, bool bIgnoreEXPRate)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->AddExpWithGamePlay(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}

	AddEXP(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	AddExpToActivateBuddy(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	return true;
}

void LC_ServerPlayer::AddExpToActivateBuddy( attr_value_type lExp, int32_t eSrcType, int lSrcTypeID, bool bIgnoreEXPRate)
{
	if (!IsInstance())
		return;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->AddExpToActivateBuddy(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}

	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		if (m_ppActivateBuddyTemplateId[i] == INVALID_ACTOR_ID)
			continue;
		AddExpToActivateBuddyByID(m_ppActivateBuddyTemplateId[i], lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}
}

bool LC_ServerPlayer::AddExpToActivateBuddyByID( int32_t nBuddyID, attr_value_type lExp, int32_t eSrcType, int lSrcTypeID, bool bIgnoreEXPRate)
{
	if (!IsInstance())
		return false;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->AddExpToActivateBuddyByID(nBuddyID, lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.find(nBuddyID);
	if (it == m_ppUsableBuddyInstance.end())
		return false;

	BuddyInstance* pInstance = it->second;
	if (pInstance == NULL)
		return false;

	return pInstance->AddExp(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
}

void LC_ServerPlayer::AddExpToAllBuddyInstance( attr_value_type lExp, int32_t eSrcType, int lSrcTypeID, bool bIgnoreEXPRate )
{
	if (!IsInstance())
		return;

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->AddExpToAllBuddyInstance(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ; it != m_ppUsableBuddyInstance.end() ; ++it )
	{
		BuddyInstance* pInstance = it->second;
		if (pInstance)
			pInstance->AddExp(lExp, eSrcType, lSrcTypeID, bIgnoreEXPRate);
	}
}

int64_t LC_ServerPlayer::GetDetalExp(int32_t buddyID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->GetDetalExp(buddyID);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.find(buddyID);
	if (it == m_ppUsableBuddyInstance.end())
		return 0;

	BuddyInstance* pInstance = it->second;
	if (pInstance == NULL)
		return 0;

	return pInstance->GetDetalExp();
}

float LC_ServerPlayer::GetLastCastSkillTime()
{
	return m_fLastCastSkillTime;
}

//////////////////////////////////////////////////////////////////////////

static std::vector<int>	s_vecRoll(8, 0);

void LC_ServerPlayer::RollNextSkill()
{
	if (m_pAssignedBuddyInstance == NULL)
		return;
	if (GetDead() == true)
		return;
	if (m_pNextSkillEntry)
		return;

	LC_SkillAssetData* pkSkillAsset = m_pAssignedBuddyInstance->GetSkillAsset()->GetSkillAssetData();
	if ( GetGlobalSetting.nBuddySkillRollIndex >= 0 )
	{
		m_pNextSkillEntry = pkSkillAsset->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, GetGlobalSetting.nBuddySkillRollIndex);
		return;
	}

	int nSize = pkSkillAsset->GetSkillCount((skill_cat_type)SKILL_TYPE_SECT);
	std::vector<int> & vecRoll = s_vecRoll;
	vecRoll.clear();
	for (int i = 0; i < nSize; i++)
	{
		vecRoll.push_back(i);
	}

	// begin shuffle
	nSize = vecRoll.size();
	for (int i = 1; i < nSize - 1; i++ )
	{
		int nCurMaxIdx = nSize - i;
		//printf( "curmaxidx: %d\n", nCurMaxIdx );
		int nRand = rand() % (nCurMaxIdx + 1) ;
		// 以下两行避免普攻参与随机竞争
		if (nRand == 0)
			nRand = 1;
		//printf( "curRandIdx: %d\n", nRand );
		std::swap( vecRoll[nRand], vecRoll[nCurMaxIdx] );
	}
	// end shuffle

	SK_Factory * pSKFactory = SK_Factory::GetSingletonPtr();
	float fCurrent = GET_PROCESS_TIME;
	nSize = vecRoll.size();
	for ( int i = nSize - 1; i >= 0; i-- )
	{
		LC_SkillAssetEntry* pNextSkillEntry= pkSkillAsset->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, i);
		if (pNextSkillEntry == NULL)
			continue;

		SK_SkillExecute* pSkill = pSKFactory->RequestSkillExcute(pNextSkillEntry->GetTypeID());
		if (pSkill)
		{
			ResultType iResult = CheckExecuteSkill(fCurrent, pSkill, 0);
			if (iResult != RE_SKILL_USABLE_COUNT_LIMIT)
			{
				m_pNextSkillEntry = pNextSkillEntry;
				break;
			}
		}
	}
	return;
}

void LC_ServerPlayer::ClearNextSkill()
{
	m_pNextSkillEntry = NULL;
}

LC_SkillAssetEntry* LC_ServerPlayer::GetNextSkill()
{
	return m_pNextSkillEntry;
}

uint64_t LC_ServerPlayer::GetAllBuddyEquipCombatScore()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetAllBuddyEquipCombatScore();
	}

	uint64_t score = 0;
	BuddyInstance* pInstance = NULL;
	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		pInstance = it->second;
		if (pInstance == NULL)
			continue;

		score += pInstance->GetBuddyEquipCombatScore();
	}

	return score;
}

ResultType LC_ServerPlayer::SetProfilePictureID(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{	
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetProfilePictureID(id);
	}

	if(m_nProfilePictureID == id)
	{
		return RE_SUCCESS;
	}

	if(!IsRobot())
	{
		//检测id是否可用
		mem::map<int32_t, bool>::iterator findIt = m_nProfilePictureRecord.find(id);
		if(findIt == m_nProfilePictureRecord.end())
		{
			return RE_FAIL;
		}
	}

	m_nProfilePictureID = id;

	if(!IsRobot())
	{
		SyncControllerPropertyToClient();
		//更新guildMember的指挥官头像id
		UpdateGuildMemberInfo(false, true);
		UpdatePlayerBaseDataToGroup();
	}

	return RE_SUCCESS;
}

int32_t LC_ServerPlayer::GetProfilePictureID()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{	
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetProfilePictureID();
	}

	return m_nProfilePictureID;
}

void LC_ServerPlayer::SyncProfilePictureRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{	
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncProfilePictureRecord();
	}

	MG_SyncProfilePictureRecord msg;
	for(mem::map<int32_t, bool>::iterator it=m_nProfilePictureRecord.begin(); it!=m_nProfilePictureRecord.end(); ++it)
	{
		msg.m_nProfilePictureRecord.insert(std::make_pair(it->first, it->second));
	}

	SendMsgToClient(MGPT_SYNCPROFILEPICTURERECORD, &msg);
}

ResultType LC_ServerPlayer::SetProfilePictureFlag(int id, bool tag)
{
	bool flag = false;
	mem::map<int32_t, bool>::iterator findIt=m_nProfilePictureRecord.find(id);
	if(findIt == m_nProfilePictureRecord.end() && true==tag)
	{
		flag = true;
		m_nProfilePictureRecord.insert(std::make_pair(id, tag));
	}
	else if(findIt!=m_nProfilePictureRecord.end() && findIt->second==true && false==tag)
	{
		flag = true;
		findIt->second = false;
	}

	if(true == flag)
	{
		SyncProfilePictureRecord();
		return RE_SUCCESS;
	}

	return RE_FAIL;
}

ResultType LC_ServerPlayer::SetCurrentCommanderTitleFrameID(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{	
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetCurrentCommanderTitleFrameID(id);
	}

	if(m_nCurrentCommanderTitleFrameID == id)
	{
		return RE_SUCCESS;
	}

	mem::map<int32_t, bool>::iterator findIt = m_nCommanderTitleFrameIDRecord.find(id);
	if(findIt == m_nCommanderTitleFrameIDRecord.end())
	{
		return RE_FAIL;
	}

	m_nCurrentCommanderTitleFrameID = id;

	SetBroadCastFlag(LC_PlayerBase::E_DirtyFlag_ControllerProperty);
	SyncControllerPropertyToClient();

	//更新guildMember的指挥官头像框id
	UpdateGuildMemberInfo(false, true);
	UpdatePlayerBaseDataToGroup();

	return RE_SUCCESS;
}

int32_t LC_ServerPlayer::GetCurrentCommanderTitleFrameID()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{	
		return -1;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetCurrentCommanderTitleFrameID();
	}

	return m_nCurrentCommanderTitleFrameID;
}

bool LC_ServerPlayer::ActivateCommanderTitleFrameID(int id)
{
	CF_HeadFrame::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_HeadFrame>(id);
	if(NULL == pkData)
	{
		return false;
	}

	mem::map<int32_t, bool>::iterator findIt = m_nCommanderTitleFrameIDRecord.find(id);
	if(findIt != m_nCommanderTitleFrameIDRecord.end())
	{
		return true;
	}

	m_nCommanderTitleFrameIDRecord.insert(std::make_pair(id, true));
	//头像框新增--埋点
	vector<uint64_t> nParams;
	nParams.clear();
	nParams.push_back(id);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, PICTUREFRAME_OPERATE,OPERATE_LOGTYPE1);
	RecordOperateLog(this,BASE_OPERATE,nLogCode,nParams);
	SyncCommanderTitleFrameRecord();

	return true;
}

void LC_ServerPlayer::SyncCommanderTitleFrameRecord()
{
	MG_SyncCommanderTitleRecord msg;
	for(mem::map<int32_t, bool>::iterator it=m_nCommanderTitleFrameIDRecord.begin(); it!=m_nCommanderTitleFrameIDRecord.end(); ++it)
	{
		msg.m_nCommanderTitleRecord.insert(std::make_pair(it->first, it->second));
	}

	if(!msg.m_nCommanderTitleRecord.empty())
	{
		SendMsgToClient(MGPT_SYNCCOMMANDERTITLERECORD, &msg);
	}
}

ResultType LC_ServerPlayer::SetCommanderTitleFlag(int id)
{
	mem::map<int32_t, bool>::iterator findIt=m_nCommanderTitleFrameIDRecord.find(id);
	if(findIt != m_nCommanderTitleFrameIDRecord.end() && findIt->second)
	{
		findIt->second = false;
		SyncCommanderTitleFrameRecord();

		return RE_SUCCESS;
	}

	return RE_FAIL;
}

void LC_ServerPlayer::AddSubSkill(int subType, int skillID)
{
	mem::map<int, mem::set<int> >::iterator findIt = m_nSubSkillID.find(subType);
	if(findIt == m_nSubSkillID.end())
	{
		mem::set<int> skillIDVec;
		skillIDVec.insert(skillID);
		m_nSubSkillID.insert(std::make_pair(subType, skillIDVec));
	}
	else
	{
		findIt->second.insert(skillID);
	}

	RefreshSubSkillScore(subType);
	SyncCommanderAttributeToClient(SPAT_CommanderAllAttr,*(GetCommanderAttrMgr().GetCommanderAllAttributeMap()), false, GetControllerCombatScore());
	RefreshAllHeroAllNewFinalAttrMap(false);
}

void LC_ServerPlayer::RefreshAllSubSkillScore()
{
	uint64_t nValue = 0;
	int arr[] = {CST_VehicleSkillScore, CST_DevaeyeSkillScore, CST_WingSkillScore};
	for(uint32_t i=0; i<sizeof(arr)/sizeof(arr[0]); ++i)
	{
		nValue += GetCommanderAttrMgr().GetCommanderCombatScoreByType(arr[i]);
	}

	GetCommanderAttrMgr().SetCommanderCombatScoreByType(this, CST_SubSkillScore,nValue);
}

void LC_ServerPlayer::RefreshSubSkillScore(int subType)
{
	mem::map<int, mem::set<int> >::iterator findIt = m_nSubSkillID.find(subType);
	if(findIt == m_nSubSkillID.end())
	{
		return;
	}

	int combatScoreType = UT_ServerHelper::GetSubCombatType(subType);
	if(combatScoreType < 0)
	{
		return;
	}

	uint64_t nValue = 0;
	for(mem::set<int>::iterator kIt=findIt->second.begin(); kIt!=findIt->second.end(); ++kIt)
	{
		CF_SkillSpecialAttrib::DataEntry* pkDetail = SafeGetCSVFileDataEntryPtr<CF_SkillSpecialAttrib>(*kIt);
		if (NULL != pkDetail)
		{
			nValue += pkDetail->_lCombatScore;
		}
	}

	int subTypeArr[] = {LC_SUB_TP_VEHICLE, LC_SUB_TP_DEVA_EYE, LC_SUB_TP_MUHUN};
	int arr[] = {CST_VehicleSkillScore, CST_DevaeyeSkillScore, CST_WingSkillScore};
	int brr[] = {CST_Vehicle, CST_Devaeye, CST_Wing};

	uint32_t index = -1;
	for(uint32_t i=0; i<sizeof(subTypeArr)/sizeof(subTypeArr[0]); ++i)
	{
		if(subTypeArr[i] == subType)
		{
			index = i;
			break;
		}
	}

	if(-1 == index)
	{
		return;
	}

	uint64_t skillScore = GetCommanderAttrMgr().GetCommanderCombatScoreByType(arr[index]);
	uint64_t baseScore = GetCommanderAttrMgr().GetCommanderCombatScoreByType(brr[index]);

	AchievementEvent kEvent;
	kEvent.SetConditionInfo(subTypeArr[index]);
	kEvent.SetNum(baseScore+skillScore);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SUB_COMBATSCORE, kEvent);

	GetCommanderAttrMgr().SetCommanderCombatScoreByType(this, combatScoreType, nValue);

	RefreshAllSubSkillScore();
}

void LC_ServerPlayer::LoadSubSkillInfo(const ::char_data_define::PBSubSkillInfo& data)
{
	m_nSubSkillID.clear();
	for(int i=0; i<data.subskilldata_size(); ++i)
	{
		int subType = data.subskilldata(i).subtype();
		mem::set<int> skillID;
		for(int j=0; j<data.subskilldata(i).subskillid_size(); ++j)
		{
			skillID.insert(data.subskilldata(i).subskillid(j));
		}
		m_nSubSkillID.insert(std::make_pair(subType, skillID));
	}
}

void LC_ServerPlayer::SaveSubSkillInfo(::char_data_define::PBSubSkillInfo* pkData)
{
	if(NULL == pkData)
	{
		return;
	}

	for(mem::map<int, mem::set<int> >::iterator it=m_nSubSkillID.begin(); it!=m_nSubSkillID.end(); ++it)
	{
		::char_data_define::PBSubSkillData* pkInfo = pkData->add_subskilldata();
		if(NULL == pkInfo)
		{
			break;
		}

		pkInfo->set_subtype(it->first);
		for(mem::set<int>::iterator kIt = it->second.begin(); kIt!=it->second.end(); ++kIt)
		{
			pkInfo->add_subskillid(*kIt);
		}
	}
}

void LC_ServerPlayer::LoginLearnSubSkillInfo()
{
	for(mem::map<int, mem::set<int> >::iterator it=m_nSubSkillID.begin(); it!=m_nSubSkillID.end(); ++it)
	{
		int32_t iSlotIdx = -1;
		for(mem::set<int>::iterator kIt=it->second.begin(); kIt!=it->second.end(); ++kIt)
		{
			LearnSkillToController(*kIt, iSlotIdx);
		}
		RefreshSubSkillScore(it->first);
	}
}

bool LC_ServerPlayer::GetAttackFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAttackFlag();
	}

	return m_nAttackFlag;
}

void LC_ServerPlayer::SetAttackFlag(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetAttackFlag(tag);
	}

	m_nAttackFlag = tag;
}

void LC_ServerPlayer::ForceUpdateDamageData(bool syncClient)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	static LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* pkLogic = (LC_ServerMapLogic_Place*)pkWorldManager->GetMapLogic(GetMapLogicID());
	if(NULL == pkLogic)
	{
		return;
	}

	SetAttackFlag(false);

	pkLogic->ForceUpdateDamageData(this, syncClient);
}

ResultType LC_ServerPlayer::ActivityGuildBossMap(int mapID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ActivityGuildBossMap(mapID);
	}

	uint64_t guildID = GetGuildID();
	if(INVALID_GUILD_ID == guildID)
	{
		return RE_GUILDMAP_ERROR_1;
	}

	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	if(NULL == pkGuildManager)
	{
		return RE_FAIL;
	}

	LC_ServerGuildInfo* pkGuild = pkGuildManager->GetGuildInfoByID(guildID);
	if(NULL == pkGuild)
	{
		return RE_FAIL;
	}

	//检测权限
	if(false == pkGuild->IsLeader(GetInstance()))
	{
		return RE_GUILDMAP_ERROR_2;
	}

	//检测公会地图是否已经开了
	int state = pkGuild->GetGuildMapBossState(mapID);
	if(GuildBossState_Alive == state)
	{
		return RE_GUILDMAP_ERROR_3;
	}

	//检测是否有其他公会秘境boss处于活着状态
	bool flag = pkGuild->CheckGuildMapHasAliveBoss();
	if(true == flag)
	{
		return RE_GUILDMAP_ERROR_18;
	}

	CF_GuildTower::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_GuildTower>(mapID);
	if(NULL == pkData)
	{
		return RE_GUILDMAP_ERROR_4;
	}

	//是否在活动时间内
	bool tag = false;
	if(0 != pkData->_GameStoryID)
	{
		tag = UT_ServerHelper::CheckStoryIsActive(pkData->_GameStoryID);
		if(false == tag)
		{
			return RE_GUILDMAP_ERROR_5;
		}
	}

	//检测是否已击杀前置地图的怪
	tag = pkGuild->CheckGuildMapFinished(pkData->_PreMapResID);
	if(false == tag)
	{
		return RE_GUILDMAP_ERROR_6;
	}

	mem::vector<PS_CostEntry> itemInfo;
	itemInfo.reserve(pkData->_consumeItem.size());
	for(UT_SIMDataList::iterator it=pkData->_consumeItem.begin(); it!=pkData->_consumeItem.end(); ++it)
	{
		PS_CostEntry data;
		data.m_ItemType = it->IID();
		data.m_ItemCount = it->ParamA();
		itemInfo.push_back(data);
	}

	//检测公会道具是否足够
	if(itemInfo.size() > 0)
	{
		ResultType res = pkGuild->CheckGuildItemEnough(itemInfo);
		if(RE_SUCCESS != res)
		{
			return res;
		}
	}

	int64_t maxHp = UT_ServerHelper::GetGuildMapBossMaxHp(mapID, pkData->_lCharType);
	if(-1 == maxHp)
	{
		return RE_GUILDMAP_ERROR_15;
	}

	//开启公会秘境boss
	MG_GG_REQ_AddGuildBossInfo msg;
	msg.m_nGuildID = guildID;
	msg.m_nMapID = mapID;
	msg.m_nBossInfo.m_nBossID = pkData->_lCharType;
	msg.m_nBossInfo.m_nInvaildTime = pkData->_aliveTime;
	msg.m_nBossInfo.m_nState = GuildBossState_Alive;
	msg.m_nBossInfo.m_nBossHP = maxHp;
	for(int i=0; i<itemInfo.size(); ++i)
	{
		int32_t num = (int32_t)itemInfo[i].m_ItemCount;
		msg.m_nConsumeItem.insert(std::make_pair(itemInfo[i].m_ItemType, num));
	}

	SendMsgToSociety(MGPT_GG_REQ_ADDGUILDBOSSINFO, &msg, GetUserID(), GetInstance());

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::GetVIPDropReward()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetVIPDropReward();
	}

	if(m_nVIPDropItemInfo.empty())
	{
		return RE_SUCCESS;
	}

	Utility::UT_SIMDataList items;
	items.reserve(m_nVIPDropItemInfo.size());
	for(mem::map<int, int>::iterator it=m_nVIPDropItemInfo.begin(); it!=m_nVIPDropItemInfo.end(); ++it)
	{
		UT_SIMDataInfo data;
		data.SetItemInfo(it->first, it->second);

		items.push_back(data);
	}
	//vip宝箱--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(pkOwnerPlayer->GetVIPLevel());
	int32_t nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, VIP_OPERATE, OPERATE_LOGTYPE2);
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, items, this, SYS_FUNC_TP_VIPDROP_ITEM, 0, mailTitle, mailDesc, false, false, false, nLogCode, nParams);
	if(RE_SUCCESS == res)
	{
		m_nVIPDropItemInfo.clear();
	}
	return res;
}

void LC_ServerPlayer::CheckAddVIPDropItem()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->CheckAddVIPDropItem();

	int newVIPLevel = GetNewVipLevel();
	if(newVIPLevel < 1)
	{
		return;
	}

	bool tag = m_NewVIPReward.CheckUpdateBonus();
	if(false == tag)
	{
		m_nNewVipDropTime = 0;
		return;
	}

	int currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if(0 == m_nNewVipDropTime)
	{
		m_nNewVipDropTime = currentTime + GetGlobalSetting.VIPDropTime*60;
	}
	else if(currentTime >= m_nNewVipDropTime) 
	{
		int times = (currentTime-m_nNewVipDropTime) / (GetGlobalSetting.VIPDropTime*60)+1;
		m_nNewVipDropTime = currentTime - (currentTime-m_nNewVipDropTime)%(GetGlobalSetting.VIPDropTime*60) + GetGlobalSetting.VIPDropTime*60;

		CF_VipNew::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_VipNew>(newVIPLevel);
		if(NULL != pkData)
		{
			RewardTypeList reward_list;
			GetVIPDropItem(pkData->_iDropID1, times, reward_list);
			if(!reward_list.empty())
			{
				AddVIPDropItem(reward_list);
			}
		}		
	}
}

void LC_ServerPlayer::GetVIPDropItem(int dropID, int times, RewardTypeList& item)
{
	CF_ItemGenMonsterDrop::DataEntry* pkEntry  = SafeGetCSVFileDataEntryPtr<CF_ItemGenMonsterDrop>(dropID);
	if (NULL != pkEntry)
	{
		int mf_rate = (int)(GetFinalAttributeMap()->GetAttribute(ATT_MF_RATE));
		int gf_rate = (int)(GetFinalAttributeMap()->GetAttribute(ATT_CASH_RATE));
		LC_ServerRewardManager* inst = LC_ServerRewardManager::GetSingletonPtr();
		for(int i=0; i<times; ++i)
		{
			inst->GenerateRewaredFromDropPacketID(mf_rate, gf_rate, pkEntry->_lCommDrop, item);
		}
	}
}

void LC_ServerPlayer::AddVIPDropItem(RewardTypeList& item)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->AddVIPDropItem(item);

	for(RewardTypeList::iterator it=item.begin(); it!=item.end(); ++it)
	{
		int itemID = 0;
		int itemNum = 0;
		switch(it->m_eType)
		{
		case GameLogic::LC_Reward::RT_GOLD:
			{
				itemID = SPEC_ITEM_TID_CASH;
				itemNum = it->GetGoldCount();
			}
			break;
		case GameLogic::LC_Reward::RT_ITEM:
			{
				itemID = it->GetItemContext().GetBackPackValueByType(LPSFET_TYPE_ID);
				itemNum = it->GetItemContext().GetBackPackValueByType(LPSFET_OVERLAP_COUNT);
			}
			break;
		case GameLogic::LC_Reward::RT_BOSS_JP:
			{
				itemID = SPEC_ITEM_TID_BOSS_JP;
				itemNum = it->GetBossJP();
			}
			break;
		case GameLogic::LC_Reward::RT_UNBINDYUANBAO:
			{
				itemID = SPEC_ITEM_TID_YUANBAO;
				itemNum = it->GetUnbindyuanbaoCount();
			}
			break;
		case GameLogic::LC_Reward::RT_RUNE_CREAM:
			{
				itemID = SPEC_ITEM_TID_RUNE_CREAM;
				itemNum = it->GetRuneCreamCount();
			}
			break;
		}

		if(0!=itemID && 0!=itemNum)
		{
			mem::map<int, int>::iterator findIt = m_nVIPDropItemInfo.find(itemID);
			if(findIt == m_nVIPDropItemInfo.end())
			{
				m_nVIPDropItemInfo.insert(std::make_pair(itemID, itemNum));
			}
			else
			{
				findIt->second += itemNum;
			}
		}
	}

	SyncVIPDropItem();
}

void LC_ServerPlayer::SyncVIPDropItem()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->SyncVIPDropItem();

	MG_SC_NewVIPBonusCacheSync msg;
	msg.m_nCount = 0;
	for(mem::map<int, int>::iterator it=m_nVIPDropItemInfo.begin(); it!=m_nVIPDropItemInfo.end(); ++it)
	{
		if(msg.m_nCount >= MAX_BOT_BONUS_CACHE_COUNT)
		{
			const unique_id_impl& instance = GetInstance();
			GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "SyncVIPDropItem size>MAX_BOT_BONUS_CACHE_COUNT size:%d, c_cid:%d, c_citizenship:%d, c_uid:%d",
				msg.m_nCount, instance.detail(), instance.catagory(), GetUserID());
			break;
		}
		msg.m_Data[msg.m_nCount].m_nItemId = it->first;
		msg.m_Data[msg.m_nCount].m_nCount = it->second;
		msg.m_nCount++;
	}

	FillBonusCache(msg);
	SendMsgToClient( MGPT_SC_NEWVIP_BONUS_CACHE_SYNC, &msg);
}

void LC_ServerPlayer::FillVIPDropItem(MG_SC_NewVIPBonusCacheSync& msg)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->FillVIPDropItem(msg);

	const unique_id_impl& instance = GetInstance();
	if(msg.m_nCount >= MAX_BOT_BONUS_CACHE_COUNT)
	{		
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "FillVIPDropItem-1 size>MAX_BOT_BONUS_CACHE_COUNT  size:%d, c_cid:%d, c_citizenship:%d, c_uid:%d",
			msg.m_nCount, instance.detail(), instance.catagory(), GetUserID());
		return;
	}

	for(mem::map<int, int>::iterator it=m_nVIPDropItemInfo.begin(); it!=m_nVIPDropItemInfo.end(); ++it)
	{
		if(msg.m_nCount >= MAX_BOT_BONUS_CACHE_COUNT)
		{
			GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "FillVIPDropItem-2 size>MAX_BOT_BONUS_CACHE_COUNT  size:%d, c_cid:%d, c_citizenship:%d, c_uid:%d",
				msg.m_nCount, instance.detail(), instance.catagory(), GetUserID());
			break;
		}
		msg.m_Data[msg.m_nCount].m_nItemId = it->first;
		msg.m_Data[msg.m_nCount].m_nCount = it->second;
		msg.m_nCount++;
	}
}

void LC_ServerPlayer::FillBonusCache(MG_SC_NewVIPBonusCacheSync& msg)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->FillBonusCache(msg);
	m_NewVIPReward.FillBonusCache(msg);
}


void LC_ServerPlayer::ResetBestGuild(bool login, int endTime)
{
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
		return;
	}

	bool tag = true;
	if(login)
	{
		tag = UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_BestGuild);
		if(tag)
		{
			endTime = UT_ServerHelper::GetStoryEndTime(GameStoryIDType_BestGuild);
		}
	}

	if(tag)
	{
		uint32_t lastEndTime = GetBestGuildActivityEndTime(GameStoryIDType_BestGuild);
		if(lastEndTime != endTime)
		{
			ResetBestGuildTaskDailyTask();
			SetBestGuildActivityEndTime(GameStoryIDType_BestGuild, endTime);

			//清除已经完成的历练和任务
			ResetBestGuildTaskAchievementID();
			CalcuBestGuildCounter(true);
		}
	}
}


void LC_ServerPlayer::CancelBestGuildTaskDailyTask()
{
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
		return;
	}

	mem::vector<int32_t> storyID;
	uint32_t time = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	for(mem::map<int32_t, uint32_t>::iterator it=m_nBestGuildActivityEndTime.begin(); it!=m_nBestGuildActivityEndTime.end(); ++it)
	{
		if(time >= it->second)
		{
			storyID.push_back(it->first);
			pkTaskManager->CancelBestGuildTaskDailyTask(this, it->first);
		}
	}

	for(int i=0; i<storyID.size(); ++i)
	{
		m_nBestGuildActivityEndTime.erase(storyID[i]);
	}
}

void LC_ServerPlayer::SetAssignBestGuildTaskTime(int scheduleID, int32_t endTime)
{
	mem::map<int32_t, int32_t>::iterator findIt = m_nAssignBestGuildTaskEndTime.find(scheduleID);
	if(findIt == m_nAssignBestGuildTaskEndTime.end())
	{
		m_nAssignBestGuildTaskEndTime.insert(std::make_pair(scheduleID, endTime));
	}
	else
	{
		findIt->second = endTime;
	}
}

int32_t LC_ServerPlayer::GetAssignBestGuildTaskTime(int scheduleID)
{
	mem::map<int32_t, int32_t>::iterator findIt = m_nAssignBestGuildTaskEndTime.find(scheduleID);
	return findIt==m_nAssignBestGuildTaskEndTime.end() ? 0 : findIt->second;
}

void LC_ServerPlayer::SetAssignBestGuildDailyTaskTime(int storyID, uint32_t time)
{
	mem::map<int32_t, uint32_t>::iterator findIt = m_nStoryAssignTaskTime.find(storyID);
	if(findIt == m_nStoryAssignTaskTime.end())
	{
		m_nStoryAssignTaskTime.insert(std::make_pair(storyID, time));
	}
	else
	{
		findIt->second = time;
	}
}

uint32_t LC_ServerPlayer::GetAssignBestGuildDailyTaskTime(int storyID)
{
	mem::map<int32_t, uint32_t>::iterator findIt = m_nStoryAssignTaskTime.find(storyID);
	return findIt==m_nStoryAssignTaskTime.end() ? 0 : findIt->second;
}

uint32_t LC_ServerPlayer::GetBestGuildActivityEndTime(int storyID)
{
	mem::map<int32_t, uint32_t>::iterator findIt = m_nBestGuildActivityEndTime.find(storyID);
	return findIt==m_nBestGuildActivityEndTime.end() ? 0 : findIt->second;
}

void LC_ServerPlayer::SetBestGuildActivityEndTime(int storyID, uint32_t time)
{
	mem::map<int32_t, uint32_t>::iterator findIt = m_nBestGuildActivityEndTime.find(storyID);
	if(findIt==m_nBestGuildActivityEndTime.end())
	{
		m_nBestGuildActivityEndTime.insert(std::make_pair(storyID, time));
	}
	else
	{
		findIt->second = time;
	}
}
uint32_t LC_ServerPlayer::GetGuildPersonalScore(int32_t storyID)
{
	mem::map<uint32_t, uint32_t>::iterator findIt = m_nGuildFightScore.find(storyID);
	return findIt==m_nGuildFightScore.end() ? 0 : findIt->second;
}

uint32_t LC_ServerPlayer::GetPersonalGuildTotalScore()
{
	return GetGuildPersonalScore(0);
}


void LC_ServerPlayer::UpdateGuildFightScore(std::map<uint32_t,uint32_t> & updateScore)
{
	for(std::map<uint32_t,uint32_t>::iterator itc = updateScore.begin(); itc != updateScore.end(); ++itc)
	{
		m_nGuildFightScore[itc->first] = itc->second;
		if(itc->first == 1)
			continue;
	}
}

void LC_ServerPlayer::CheckProcessingTaskVaild(LC_TaskMap* pkTaskMap)
{
	if(NULL == pkTaskMap)
	{
		return;
	}

	LC_ProcessingTaskEntryMap& kProcessEntryMap = pkTaskMap->GetProcessingTaskEntryMap();
	LC_ProcessingTaskEntryMap::iterator it=kProcessEntryMap.begin();
	while(it!=kProcessEntryMap.end())
	{
		const CSVFile::CF_TaskList::DataEntry* pkData = it->second.GetTaskDatatable();
		if(NULL != pkData && false==UT_ServerHelper::CheckActivityVaild(pkData->_TaskFinishScheduleID))
		{
			it = kProcessEntryMap.erase(it);
		}
		else
		{
			++it;
		}
	}
}

void LC_ServerPlayer::ResetBestGuildTaskAchievementID()
{
	LC_TaskMap* pkTaskMap = GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return;
	}

	CAchievementManager* pkMgr = CAchievementManager::GetSingletonPtr();
	CAchievementAsset& achievementAsset = GetAchievementAsset();

	m_nBestGuildTaskID1.clear();
	m_nBestGuildTaskID2.clear();
	CF_BestGuildTask::DataEntryMapExternIterator kIt = CF_BestGuildTask::GetSingletonPtr()->GetIterator();
	for(; kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_BestGuildTask::DataEntry* pkData = kIt.PeekNextValuePtr();
		for(Utility::UT_SIMDataList::iterator it=pkData->_sTaskID.begin(); it!=pkData->_sTaskID.end(); ++it)
		{
			pkTaskMap->RemoveTaskFinishRecord(it->IID());
		}

		for(Utility::UT_SIMDataList::iterator it=pkData->_sAchievementID.begin(); it!=pkData->_sAchievementID.end(); ++it)
		{
			int32_t achievementID = it->IID();
			const LC_AchievementDataEntry_New* pkEntry = pkMgr->GetAchievementEntryByID(achievementID);
			ResultType res = achievementAsset.CheckAchievementCanFinish(achievementID);
			bool tag = UT_ServerHelper::CheckActivityVaild(pkEntry->_iScheduleID);
			if(!tag)
			{
				m_BestGuildFinishedAchievement1.erase(achievementID);
				m_BestGuildFinishedAchievement2.erase(achievementID);
				if(RE_SUCCESS == res)
				{
					m_BestGuildFinishedAchievement2.insert(achievementID);
				}
			}
			else
			{
				m_BestGuildFinishedAchievement1.erase(achievementID);
				m_BestGuildFinishedAchievement2.erase(achievementID);
				if(RE_SUCCESS == res)
				{
					m_BestGuildFinishedAchievement1.insert(achievementID);
				}
			}
			achievementAsset.RemoveAchievementFromFinishRecord(achievementID);
		}
	}
}

void LC_ServerPlayer::ResetBestGuildTaskDailyTask()
{
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
		return;
	}

	LC_TaskMap* pkTaskMap = GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return;
	}

	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	CF_BestGuildDailyTask::DataEntryMapExternIterator kIter = CF_BestGuildDailyTask::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_BestGuildDailyTask::DataEntry* pkData = kIter.PeekNextValuePtr();
		bool tag = UT_ServerHelper::CheckStoryIsActive(pkData->_iGamestory);
		if(tag)
		{
			uint32_t lastAssignTime = GetAssignBestGuildDailyTaskTime(pkData->_iGamestory);
			bool flag = LC_Helper::CheckIsSameDay(lastAssignTime, currentTime);
			if(!flag)
			{
				for(Utility::UT_SIMDataList::iterator it1=pkData->_sDailyTaskID1.begin(); it1!=pkData->_sDailyTaskID1.end(); ++it1)
				{
					int taskID = it1->IID();
					tag = IsInFinishedTaskMap(taskID);
					if(tag)
					{
						pkTaskMap->RemoveTaskFinishRecord(taskID);
					}

					tag = IsInAssignTaskMap(taskID);
					if(!tag)
					{
						pkTaskManager->AssignTaskByTaskID(this, taskID);
					}
				}

				for(Utility::UT_SIMDataList::iterator it2=pkData->_sDailyTaskID2.begin(); it2!=pkData->_sDailyTaskID2.end(); ++it2)
				{
					int taskID = it2->IID();
					bool tag = IsInFinishedTaskMap(taskID);
					if(tag)
					{
						pkTaskMap->RemoveTaskFinishRecord(taskID);
					}
					tag = IsInAssignTaskMap(taskID);
					if(!tag)
					{
						pkTaskManager->AssignTaskByTaskID(this, taskID);
					}
				}
				SetAssignBestGuildDailyTaskTime(pkData->_iGamestory, currentTime);
			}
		}
	}
}

void LC_ServerPlayer::CalcuBestGuildCounter(bool reset)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL==pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CalcuBestGuildCounter();
	}

	if(reset)
	{
		m_nBestGuildRewardFlag = false;
		m_nBestGuildCounter = 0;
	}

	int32_t size = m_BestGuildFinishedAchievement1.size() + m_nBestGuildTaskID1.size();
	if(size > m_nBestGuildCounter)
	{
		m_nBestGuildCounter = size;
		SyncBestGuildTaskInfo();
	}
}

ResultType LC_ServerPlayer::GetBestGuildReward()
{
	bool tag = UT_ServerHelper::CheckActivityVaild(GetGlobalSetting.BestGuildScheduleID);
	if(tag)
	{
		return RE_GET_REWARD_ERROR_1;
	}

	tag = UT_ServerHelper::CheckActivityVaild(GetGlobalSetting.TaskRewardScheduleID);
	if(!tag)
	{
		return RE_GET_REWARD_ERROR_2;
	}

	tag = GetBestGuildRewardFlag();
	if(tag)
	{
		return RE_GET_REWARD_ERROR_3;
	}

	int taskCount = GetBestGuildTaskCount();
	if(taskCount < 1)
	{
		return RE_GET_REWARD_ERROR_4;
	}

	UT_SIMDataInfo item;
	item._iX = GetGlobalSetting.TaskRewardID;
	item._iY = taskCount;

	Utility::UT_SIMDataList rewards;
	rewards.push_back(item);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, HONOURCHALLENG_OPERATE, OPERATE_LOGTYPE2);
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, rewards, this, SYS_FUNC_TP_BESTGUILDREWATD_ITEM, taskCount, mailTitle, mailDesc, false, false, false, nLogCode);
	if(RE_SUCCESS == res)
	{
		UpdateBestGuildRewardFlag(true);
	}
	return res;
}

int32_t LC_ServerPlayer::GetBestGuildTaskCount()
{
	return m_nBestGuildCounter;
}

void LC_ServerPlayer::UpdateBestGuildRewardFlag(bool tag)
{
	m_nBestGuildRewardFlag = tag;
	SyncBestGuildTaskInfo();
}

bool LC_ServerPlayer::GetBestGuildRewardFlag()
{
	return m_nBestGuildRewardFlag;
}

void LC_ServerPlayer::SyncBestGuildTaskInfo()
{
	MG_SyncBestGuildTaskInfo msg;
	msg.m_nBestGuildTaskCount = m_nBestGuildCounter;
	msg.m_nBestGuildRewardFlag = m_nBestGuildRewardFlag;
	SendMsgToClient(MGPT_SYNCBESTGUILDTASKINFO, &msg);
}

void LC_ServerPlayer::AddBestGuildAchievementID(const LC_AchievementDataEntry_New* pkAchievement)
{
	if(NULL == pkAchievement)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddBestGuildAchievementID(pkAchievement);
	}

	int achievementID = pkAchievement->_lID;
	bool tag = UT_ServerHelper::CheckActivityVaild(pkAchievement->_iScheduleID);
	if(!tag)
	{
		m_BestGuildFinishedAchievement2.insert(achievementID);
	}
	else
	{
		mem::set<int32_t>::iterator findIt = m_BestGuildFinishedAchievement2.find(achievementID);
		if(findIt != m_BestGuildFinishedAchievement2.end())
		{
			m_BestGuildFinishedAchievement2.erase(findIt);
		}

		m_BestGuildFinishedAchievement1.insert(achievementID);
	}

	CalcuBestGuildCounter(false);
}

void LC_ServerPlayer::AddBestGuildTaskID(GameLogic::LC_Task* pkTask)
{
	if(NULL == pkTask)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddBestGuildTaskID(pkTask);
	}

	int32_t taskID = pkTask->GetTaskID();
	bool tag = UT_ServerHelper::CheckActivityVaild(pkTask->GetTaskFinishScheduleID());
	if(!tag)
	{
		m_nBestGuildTaskID2.insert(taskID);
	}
	else
	{
		mem::set<int32_t>::iterator findIt = m_nBestGuildTaskID2.find(taskID);
		if(findIt != m_nBestGuildTaskID2.end())
		{
			m_nBestGuildTaskID2.erase(findIt);
		}
		m_nBestGuildTaskID1.insert(taskID);
	}

	CalcuBestGuildCounter(false);
}

void LC_ServerPlayer::FlushBestGuildCounter(int scheduleID)
{
	mem::vector<int32_t> removeAchievementID;
	mem::vector<int32_t> removeTaskID;
	CAchievementManager* pkMgr = CAchievementManager::GetSingletonPtr();
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	for(mem::set<int32_t>::iterator it=m_BestGuildFinishedAchievement2.begin(); it!=m_BestGuildFinishedAchievement2.end(); ++it)
	{
		int32_t achievementID = *it;
		const LC_AchievementDataEntry_New* pkEntry = pkMgr->GetAchievementEntryByID(achievementID);
		if(NULL != pkEntry)
		{
			if(0!=scheduleID && pkEntry->_iScheduleID!=scheduleID)
			{
				continue;
			}

			if(!UT_ServerHelper::CheckActivityVaild(pkEntry->_iScheduleID))
			{
				continue;
			}

			removeAchievementID.push_back(achievementID);
			m_BestGuildFinishedAchievement1.insert(achievementID);
		}		
	}

	for(mem::set<int32_t>::iterator it=m_nBestGuildTaskID2.begin(); it!=m_nBestGuildTaskID2.end(); ++it)
	{
		int32_t taskID = *it;
		LC_Task* pkTask = pkTaskManager->GetTask(taskID);
		if(NULL != pkTask)
		{
			int finishScheduleID = pkTask->GetTaskFinishScheduleID();
			if(0!=scheduleID && finishScheduleID!=scheduleID)
			{
				continue;
			}

			if(!UT_ServerHelper::CheckActivityVaild(finishScheduleID))
			{
				continue;
			}

			removeTaskID.push_back(taskID);
			m_nBestGuildTaskID1.insert(taskID);
		}
	}

	for(mem::vector<int32_t>::iterator it=removeAchievementID.begin(); it!=removeAchievementID.end(); ++it)
	{
		m_BestGuildFinishedAchievement2.erase(*it);	
	}
	for(mem::vector<int32_t>::iterator it=removeTaskID.begin(); it!=removeTaskID.end(); ++it)
	{
		m_nBestGuildTaskID2.erase(*it);
	}
}

void LC_ServerPlayer::LoadBestGuildAchievementInfo(const char_data_define::PBBestGuildAchievement_Info& data)
{
	m_nBestGuildCounter = data.bestguildcounter();
	for(int i=0; i<data.bestguildtaskid1_size(); ++i)
	{
		m_nBestGuildTaskID1.insert(data.bestguildtaskid1(i));
	}
	for(int i=0; i<data.bestguildtaskid2_size(); ++i)
	{
		m_nBestGuildTaskID2.insert(data.bestguildtaskid2(i));
	}
	for(int i=0; i<data.bestguildfinishedachievement1_size(); ++i)
	{
		m_BestGuildFinishedAchievement1.insert(data.bestguildfinishedachievement1(i));
	}
	for(int i=0; i<data.bestguildfinishedachievement2_size(); ++i)
	{
		m_BestGuildFinishedAchievement2.insert(data.bestguildfinishedachievement2(i));
	}
	m_nBestGuildRewardFlag = data.bestguildrewardflag();
}

void LC_ServerPlayer::SaveBestGuildAchievementInfo(char_data_define::PBBestGuildAchievement_Info* pkData)
{
	if(NULL == pkData)
	{
		return;
	}

	pkData->set_bestguildcounter(m_nBestGuildCounter);
	for(mem::set<int32_t>::iterator it=m_nBestGuildTaskID1.begin(); it!=m_nBestGuildTaskID1.end(); ++it)
	{
		pkData->add_bestguildtaskid1(*it);
	}
	for(mem::set<int32_t>::iterator it=m_nBestGuildTaskID2.begin(); it!=m_nBestGuildTaskID2.end(); ++it)
	{
		pkData->add_bestguildtaskid2(*it);
	}	
	for(mem::set<int32_t>::iterator it=m_BestGuildFinishedAchievement1.begin(); it!=m_BestGuildFinishedAchievement1.end(); ++it)
	{
		pkData->add_bestguildfinishedachievement1(*it);
	}
	for(mem::set<int32_t>::iterator it=m_BestGuildFinishedAchievement2.begin(); it!=m_BestGuildFinishedAchievement2.end(); ++it)
	{
		pkData->add_bestguildfinishedachievement2(*it);
	}
	pkData->set_bestguildrewardflag(m_nBestGuildRewardFlag);
}

int LC_ServerPlayer::GetBestGuildSettleAccountPoint()
{
	return m_nSettleAccountPoint;
}

void LC_ServerPlayer::SetBestGuildSettleAccountPoint(int score)
{
	m_nSettleAccountPoint = score;
}

void LC_ServerPlayer::SetLastAccountPointRankIndexByTypeAndStoryId(int type, int storyID)
{
	if(GuildFightRankType::GFRT_GUILD!=type && GuildFightRankType::GFRT_PERSONAL!=type)
	{
		return;
	}

	uint64_t myself = GetInstance();
	uint64_t uGuildID = GetGuildID();
	int index = UT_ServerHelper::GetAccountPointRankIndexFromRedisByTypeAndStoryId(uGuildID,myself, type, storyID);

	uint64_t key = LC_Helper::EncodeScore(type, storyID);
	mem::map<uint64_t, int32_t>::iterator findIt = m_nPlayerLastRankIndex.find(key);
	if(findIt == m_nPlayerLastRankIndex.end())
	{
		m_nPlayerLastRankIndex.insert(std::make_pair(key, index));
	}
	else
	{
		findIt->second = index;
	}
}

int LC_ServerPlayer::GetLastAccountPointRankIndexByTypeAndStoryId(int type, int storyID)
{
	if(GuildFightRankType::GFRT_GUILD!=type && GuildFightRankType::GFRT_PERSONAL!=type)
	{
		return -1;
	}

	uint64_t key = LC_Helper::EncodeScore(type, storyID);
	mem::map<uint64_t, int32_t>::iterator findIt = m_nPlayerLastRankIndex.find(key);
	if(findIt == m_nPlayerLastRankIndex.end())
	{
		return -1;
	}

	return findIt->second;
}

void LC_ServerPlayer::SetCurrentAccountPointRankIndexByTypeAndStoryId(int type, int storyID)
{
	if(GuildFightRankType::GFRT_GUILD!=type && GuildFightRankType::GFRT_PERSONAL!=type)
	{
		return;
	}

	uint64_t myself = GetInstance();
	uint64_t uGuildID = GetGuildID();
	int index = UT_ServerHelper::GetAccountPointRankIndexFromRedisByTypeAndStoryId(uGuildID,myself, type, storyID);

	uint64_t key = LC_Helper::EncodeScore(type, storyID);
	mem::map<uint64_t, int32_t>::iterator findIt = m_nPlayerCurrentRankIndex.find(key);
	if(findIt == m_nPlayerCurrentRankIndex.end())
	{
		m_nPlayerCurrentRankIndex.insert(std::make_pair(key, index));
	}
	else
	{
		findIt->second = index;
	}
}

int LC_ServerPlayer::GetCurrentAccountPointRankIndexByTypeAndStoryId(int type, int storyID)
{
	if(GuildFightRankType::GFRT_GUILD!=type && GuildFightRankType::GFRT_PERSONAL!=type)
	{
		return -1;
	}

	uint64_t key = LC_Helper::EncodeScore(type, storyID);
	mem::map<uint64_t, int32_t>::iterator findIt = m_nPlayerCurrentRankIndex.find(key);
	if(findIt == m_nPlayerCurrentRankIndex.end())
	{
		return -1;
	}

	return findIt->second;
}





void LC_ServerPlayer::SyncChainFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncChainFlag();
	}

	MG_SyncChainFlag msg;
	msg.m_nChainFlag = GetChainFlag();
	SendMsgToClient(MGPT_SYNCCHAINFLAG, &msg);
}

uint32_t LC_ServerPlayer::GetChainFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetChainFlag();
	}

	return m_nChainFlag;
}

ResultType LC_ServerPlayer::SetChainFlag(int index)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetChainFlag(index);
	}

	bool flag = m_nChainFlag & (1<<index);
	if(!flag)
	{
		m_nChainFlag |= (1<<index);
		SyncChainFlag();
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::SetEquipSuitLevel(int level)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetEquipSuitLevel(level);
	}

	if(level <= m_nEquipSuitLevel)
	{
		return RE_FAIL;
	}

	m_nEquipSuitLevel = level;
	return RE_SUCCESS;
}

void LC_ServerPlayer::SyncEquipSuitLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncEquipSuitLevel();
	}

	MG_SyncEquipSuitLevel msg;
	msg.m_nEquipSuitLevel = m_nEquipSuitLevel;
	SendMsgToClient(MGPT_SYNCEQUIPSUITLEVEL, &msg);
}

void LC_ServerPlayer::UpdateRegularBossGroupInfo()
{
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if(0!=m_nRegularBossGroupCDTime && currentTime>=m_nRegularBossGroupCDTime)
	{
		m_nRegularBossGroupID = 0;
		m_nRegularBossGroupCDTime = 0;
		SyncRegularBossGroupInfo();
	}
}

void LC_ServerPlayer::SyncRegularBossGroupInfo()
{
	MG_SyncRegularBossGroupInfo msg;
	msg.m_nRegularBossGroupID = m_nRegularBossGroupID;
	msg.m_nRegularBossGroupCDTime = m_nRegularBossGroupCDTime;
	SendMsgToClient(MGPT_SYNCREGULARBOSSGROUPINFO, &msg);
}

ResultType LC_ServerPlayer::CheckCanEnter(int mapID)
{
	CF_WorldMapList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapID);
	if (NULL == pkData)
	{
		return RE_FAIL;
	}

	const unique_id_impl& playerInstance = GetInstance();

	//如果是浩劫秘境，先判断cd时间
	int groupID = -1;
	if(UT_ServerHelper::IsRegularBossMap(mapID, groupID))
	{
		uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		if(m_nRegularBossGroupID==0 && m_nRegularBossGroupCDTime==0)
		{
			m_nRegularBossGroupID = groupID;
			m_nRegularBossGroupCDTime = currentTime+GetGlobalSetting.RegularBossGroupCDTime*60;
			SyncRegularBossGroupInfo();
		}
		else if(m_nRegularBossGroupID==groupID && currentTime<m_nRegularBossGroupCDTime)
		{
			SyncRegularBossGroupInfo();
		}
		else
		{
			return RE_REGULARBOSS_IN_CD;
		}
	}

	if (!CheckEnterMap_Task(mapID))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckCanEnter r1 mapID:%d, cid:%d, citizenship:%d, uid:%d", mapID, playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return RE_FAIL;
	}

	ResultType ret = RE_SUCCESS;
	ret = LC_Helper::CanEnterMap(mapID, this);
	if (ret != RE_SUCCESS)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckCanEnter r2 mapID:%d, cid:%d, citizenship:%d, uid:%d", mapID, playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return ret;
	}

	//活动是否开启
	if(0 != pkData->_iStoryID && pkData->_iMapLogicType!=MT_GUILD_MAP)
	{
		if (false==UT_ServerHelper::CheckStoryIsActive(pkData->_iStoryID) && mapID!=GetGlobalSetting.BestGuildMapID)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckCanEnter r3 mapID:%d, storyID:%d, cid:%d, citizenship:%d, uid:%d", mapID, pkData->_iStoryID, playerInstance.detail(), playerInstance.catagory(), GetUserID());
			return RE_GAMESTORY_UNACTIVE;
		}
	}

	//关联活动是否开启
	//目前只有异种降临地图用了这个字段
	for(uint32_t i=0; i<pkData->_iStoryIDSubclass.size(); ++i)
	{
		int storyID = pkData->_iStoryIDSubclass[i].IID();
		if (!UT_ServerHelper::CheckStoryIsActive(storyID))
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckCanEnter r4 mapID:%d, storyID:%d, cid:%d, citizenship:%d, uid:%d", mapID, storyID, playerInstance.detail(), playerInstance.catagory(), GetUserID());
			return RE_GAMESTORY_UNACTIVE;
		}
	}

	LC_ServerMapLogic_TranscriptionRuleManger* rulemanager = SERVER_GET_TRANSCRIPTIONRULE_MANAGER;
	CF_TranscriptionRule::DataEntry* pkEntry = rulemanager->GetRule(mapID);
	if(NULL != pkEntry)
	{
		LC_ServerMapLogic_TranscriptionRuleManger* rulemanager = SERVER_GET_TRANSCRIPTIONRULE_MANAGER;
		ret = rulemanager->CheckEnter(this, pkEntry);
		if (ret != RE_SUCCESS)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "CheckCanEnter r5 mapID:%d, ret:%d, cid:%d, citizenship:%d, uid:%d", mapID, ret, playerInstance.detail(), playerInstance.catagory(), GetUserID());
			return ret;
		}
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::GetNewAchievementReward(int32_t id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetNewAchievementReward(id);
	}

	bool tag = IsInNewAchievementReward(id);
	if(true == tag)
	{
		return RE_NEWACHIEVEMENT_ERROR_1;
	}

	CF_NewAchievementReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_NewAchievementReward>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	int starNum = GetNewAchievementStarNum();
	if(starNum < pkData->_rewardNum)
	{
		return RE_NEWACHIEVEMENT_ERROR_2;
	}
	//成就星级--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(pkData->_rewardNum);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE,ACHIEVEMENT_OPERATE, OPERATE_LOGTYPE2);
	ResultType res = RE_SUCCESS;
	if(!pkData->_chapterReward.empty())
	{
		StringType mailTitle;
		StringType mailDesc;
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_chapterReward, this, SYS_FUNC_TP_NEWACHIEVEMENT_CHAPTERREWARD, id, mailTitle, mailDesc, false,false,false,nLogCode, nParams);
		if(RE_SUCCESS != res)
		{
			return res;
		}
	}

	UpdateNewAchievementReward(id);

	return res;
}

void LC_ServerPlayer::SyncNewAchievementStarNum()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncNewAchievementStarNum();
	}

	MG_SyncNewAchievementStarNum msg;
	msg.m_nNewAchievementStarNum = GetNewAchievementStarNum();
	SendMsgToClient(MGPT_SYNCNEWACHIEVEMENTSTARNUM, &msg);
}

void LC_ServerPlayer::SyncNewAchievementReward()
{
	MG_SyncNewAchievementRewardRecord msg;
	for(mem::set<int>::iterator it=m_nNewAchievementRewardRecord.begin(); it!=m_nNewAchievementRewardRecord.end(); ++it)
	{
		msg.m_nID.push_back(*it);
	}

	SendMsgToClient(MGPT_SYNCNEWACHIEVEMENTREWARDRECORD, &msg);
}

bool LC_ServerPlayer::IsInNewAchievementReward(int32_t id)
{
	mem::set<int>::iterator findIt = m_nNewAchievementRewardRecord.find(id);
	return findIt!=m_nNewAchievementRewardRecord.end() ? true : false;
}

void LC_ServerPlayer::UpdateNewAchievementReward(int32_t id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateNewAchievementReward(id);
	}

	m_nNewAchievementRewardRecord.insert(id);

	SyncNewAchievementReward();
}

void LC_ServerPlayer::AddNewAchievementAchievementStarNum(int num)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddNewAchievementAchievementStarNum(num);
	}

	if(num <= 0)
	{
		return;
	}

	m_nNewAchievementStarNum += num;

	UpdateRankUserValueByRankType(Rank_Type_NewAchievement);

	SyncNewAchievementStarNum();
}

int32_t LC_ServerPlayer::GetNewAchievementStarNum()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetNewAchievementStarNum();
	}

	return m_nNewAchievementStarNum;
}


uint64_t LC_ServerPlayer::GetCombatScore()
{
	uint64_t nResult = 0;
	if (m_pAssignedBuddyInstance == NULL)
		return nResult;
	nResult = m_pAssignedBuddyInstance->GetBuddyAttrMgr().GetBuddyCombatScoreByType(BCST_FinalBuddy);
	return nResult;
}

uint64_t LC_ServerPlayer::GetActivateBuddyCombatScore()
{
	uint64_t totalScore = 0;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		totalScore += pResultPlayer->GetCombatScore();
	}
	return totalScore;
}

uint64_t LC_ServerPlayer::GetBuddyAllBaseCombatScore(int buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer) 
		return 0;
	if(!IsMainController())
		return pkOwnerPlayer->GetBuddyAllBaseCombatScore(buddyID);
	mem::map<int32_t, BuddyInstance*>::iterator findIt = m_ppUsableBuddyInstance.find(buddyID);
	if(findIt != m_ppUsableBuddyInstance.end())
	{
		BuddyInstance* pkBuddy = findIt->second;
		if(NULL != pkBuddy)
			return pkBuddy->GetAllBaseAttributeCombatScore();
	}
	return 0;
}

int32_t LC_ServerPlayer::GetCombatScoreMaxBuddyID(uint64_t& maxCS)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer) 
		return 0;

	if(!IsMainController())
		return pkOwnerPlayer->GetCombatScoreMaxBuddyID(maxCS);

	int32_t buddyID = 0;
	maxCS = 0;
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
			continue;
		uint64_t score = pkBuddy->GetAllBaseAttributeCombatScore();
		if(score > maxCS)
		{
			maxCS = score;
			buddyID = pkBuddy->GetTemplateID();
		}
	}
	return buddyID;
}

ResultType LC_ServerPlayer::ActiveBuddyTransform(int buddyID, int transformID, bool useItem)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ActiveBuddyTransform(buddyID, transformID, useItem);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.find(buddyID);
	if(it == m_ppUsableBuddyInstance.end())
	{
		return RE_BUDDYTRANSFORM_ERROR_3;
	}

	BuddyInstance* pkBuddy = it->second;
	if(NULL == pkBuddy)
	{
		return RE_FAIL;
	}

	ResultType res = pkBuddy->ActiveBuddyTransform(transformID, useItem, true, true);


	pkBuddy->GetBuddyAttrMgr().RefreshSkinAttrMap(pkOwnerPlayer,pkBuddy);
	pkBuddy->GetBuddyAttrMgr().RefreshHeroAllAttributeMap(pkOwnerPlayer,pkBuddy);
	pkBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(pkOwnerPlayer,pkBuddy, false, SPART_Buddy_3);


	return res;
}

ResultType LC_ServerPlayer::SetBuddyCurrentTransformID(int buddyID, int transformID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetBuddyCurrentTransformID(buddyID, transformID);
	}

	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.find(buddyID);
	if(it == m_ppUsableBuddyInstance.end())
	{
		return RE_FAIL;
	}

	BuddyInstance* pkBuddy = it->second;
	if(NULL == pkBuddy)
	{
		return RE_FAIL;
	}

	ResultType res = pkBuddy->SetBuddyCurrentTransformID(transformID, false);
	if(RE_SUCCESS == res)
	{
		//判断现在这个buddy是不是主控buddy
		//判断玩家是否有队伍
		//有，改变队伍中，组队信息中的皮肤id
		int activeBuddyID = GetCurrentActivateBuddyID();		
		if(activeBuddyID == buddyID)
		{
			UpdateGroupTransformID();
		}
	}

	return res;
}

int LC_ServerPlayer::GetCurrentActivateBuddyTransformID()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetCurrentActivateBuddyTransformID();
	}

	int buddyID = GetCurrentActivateBuddyID();
	return GetBuddyCurrentTransformID(buddyID);
}

int LC_ServerPlayer::GetBuddyCurrentTransformID(int buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetBuddyCurrentTransformID(buddyID);
	}

	mem::map<int32_t, BuddyInstance*>::iterator findIt = m_ppUsableBuddyInstance.find(buddyID);
	if(findIt == m_ppUsableBuddyInstance.end())
	{
		return 0;
	}

	BuddyInstance* pkBuddy = findIt->second;
	if(NULL == pkBuddy)
	{
		return 0;
	}

	return pkBuddy->GetBuddyCurrentTransformID();
}

void LC_ServerPlayer::UpdateGroupTransformID()
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if(NULL == pOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pOwnerPlayer->UpdateGroupTransformID();
	}

	LC_PlayerGroupBase* pkGroup = GetPlayerGroup();
	if(NULL == pkGroup)
	{
		return;
	}

	LC_PlayerGroupEntry* pkEntry = pkGroup->FindGroupEntryInMemberListByPlayerID(GetID());
	if(NULL == pkEntry)
	{
		return;
	}

	pkEntry->SetTransformID(GetCurrentActivateBuddyTransformID());
	pkGroup->UpdateDirtyFlag(DIRTY_FLAG_PLAYER_GROUP_MEMBER_LIST);
}

ResultType LC_ServerPlayer::AddBuddyTransformItem(int transformID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddBuddyTransformItem(transformID);
	}

	ResultType res = RE_FAIL;
	CF_BuddyTransform::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BuddyTransform>(transformID);
	if(NULL != pkData)
	{
		for(Utility::UT_SIMDataList::iterator it=pkData->_kItems.begin(); it!=pkData->_kItems.end(); ++it)
		{
			res = LC_Helper::AddItem(GetPackAsset(), (int)(it->IID()),(int)(it->ParamA()), 0, false);
			//res = AddItem(it->IID(), it->ParamA());
			if(RE_SUCCESS != res)
			{
				return res;
			}
		}
	}

	SyncBackPackToClient(PACK_TYPE_BASIC);
	return res;
}

ResultType LC_ServerPlayer::AddSubTransformItem(int transformID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddBuddyTransformItem(transformID);
	}

	ResultType res = RE_FAIL;
	CF_SubordinateTransform::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SubordinateTransform>(transformID);
	if(NULL != pkData)
	{
		for(Utility::UT_SIMDataList::iterator it=pkData->_kItems.begin(); it!=pkData->_kItems.end(); ++it)
		{
			res = LC_Helper::AddItem(GetPackAsset(), (int)(it->IID()),(int)(it->ParamA()), 0, false);
			//res = AddItem(it->IID(), it->ParamA());
			if(RE_SUCCESS != res)
			{
				return res;
			}
		}
	}

	SyncBackPackToClient(PACK_TYPE_BASIC);
	return res;
}

int32_t LC_ServerPlayer::GetTransformNum_NotInitID()
{
	int32_t num = 0;
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			num += pkBuddy->GetTransformNum_NotInitID();
		}
	}

	return num;
}

int32_t LC_ServerPlayer::GetSubScore_Suit( int32_t nType )
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return -1;

	if(!IsMainController())
	{
		return pOwnerPlayer->GetSubScore_Suit(nType);
	}

	return LC_PlayerBase::GetSubScore_Suit(nType);
}

void LC_ServerPlayer::SetSubScore_Suit( int32_t nType, int32_t nScore )
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return pOwnerPlayer->SetSubScore_Suit(nType, nScore);
	}

	return LC_PlayerBase::SetSubScore_Suit(nType, nScore);
}

bool LC_ServerPlayer::ModifySubScore_Suit( int32_t nType, int32_t nDeltaScore )
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return pOwnerPlayer->ModifySubScore_Suit(nType, nDeltaScore);
	}

	return LC_PlayerBase::ModifySubScore_Suit(nType, nDeltaScore);
}

uint64_t LC_ServerPlayer::GetSumSubSystemCombatScore(int32_t iSubType)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;
	if(!IsMainController())
		return m_pOwnerPlayer->GetSumSubSystemCombatScore(iSubType);
	if(!IS_VALID_SUBORDINATE_BASE_TYPE(iSubType))
		return 0;
	int nType = 0;
	switch(iSubType)
	{
	case LC_SUB_TP_VEHICLE:
		nType = CST_Vehicle;
		break;
	case LC_SUB_TP_MUHUN:
		nType = CST_Wing;
		break;
	case LC_SUB_TP_DEVA_EYE:
		nType = CST_Devaeye;
		break;
	default:
		break;
	}
	return GetCommanderAttrMgr().GetCommanderCombatScoreByType(nType);
}

int64_t LC_ServerPlayer::GetYaZhiCombatScore()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetYaZhiCombatScore();
	}
	
	return (int64_t)GetActivateBuddyCombatScore();
}

uint64_t LC_ServerPlayer::GetControllerCombatScore()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
		return 0;

	if(!IsMainController())
		return pkOwnerPlayer->GetControllerCombatScore();

	CommanderAttrMgr& attrMgr = GetCommanderAttrMgr();
	return attrMgr.GetCommanderCombatScoreByType(CST_Controller)+ attrMgr.GetCommanderCombatScoreByType(CST_SubSkillScore) + attrMgr.GetCommanderCombatScoreByType(CST_Core);
}

void LC_ServerPlayer::UpdateControllerCombatScoreAndOtherOpen()
{
	uint64_t nControllerCombatScore  = GetControllerCombatScore();
	AchievementEvent kEvent;
	kEvent.SetNum(nControllerCombatScore);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_TOTALSCORE, kEvent);
}

bool LC_ServerPlayer::CheckCanRespaw(int32_t& cdTime)
{
	if(!CheckOwnerDead())
		return false;

	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	uint32_t lastTime = m_ControllerPlayerRespawnData.m_TimeStamp;
	int time = currentTime - lastTime;

	bool tag = false;
	if(time >= m_ControllerPlayerRespawnData.m_CurRespawnTime)
	{
		tag = true;
	}
	else
	{
		tag = false;
		cdTime = m_ControllerPlayerRespawnData.m_CurRespawnTime-time;
	}

	return tag;
}

void LC_ServerPlayer::ClearCombatStatusAsBuddy()
{
	SetDefaultTargetID(INVALID_ACTOR_ID);
	SetLogicCombatFlag(false);
	LC_ActorHatredList* pkHatredList = GetHatredList();

	pkHatredList->Reset();
}

void LC_ServerPlayer::AddPlaceHolder(int mapResID, mem::vector<object_id_type>& placeHolderLogicID)
{
	mem::map<int, mem::vector<object_id_type> >::iterator it = m_nPlaceHolderLogicID.find(mapResID);
	if(it == m_nPlaceHolderLogicID.end())
	{
		m_nPlaceHolderLogicID.insert(std::make_pair(mapResID, placeHolderLogicID));
	}
	else
	{
		for(int i=0; i<placeHolderLogicID.size(); ++i)
		{
			it->second.push_back(placeHolderLogicID[i]);
		}
	}
}

bool LC_ServerPlayer::GetPlaceHolder(int mapResID, mem::vector<object_id_type>& placeHolderLogicID)
{
	mem::map<int, mem::vector<object_id_type> >::iterator it = m_nPlaceHolderLogicID.find(mapResID);
	if(it != m_nPlaceHolderLogicID.end())
	{
		placeHolderLogicID = it->second;
		return true;
	}
	return false;
}

void LC_ServerPlayer::RemoveMapPlaceHolder(int mapResID)
{
	m_nPlaceHolderLogicID.erase(mapResID);
}

void LC_ServerPlayer::AddDropItemInfo(int npcID, mem::map<int, int>& dropItems)
{
	mem::map<int, mem::map<int, int> >::iterator findIt = m_nDropItems.find(npcID);
	if(findIt != m_nDropItems.end())
	{
		for(mem::map<int, int>::iterator it=dropItems.begin(); it!=dropItems.end(); ++it)
		{
			mem::map<int, int>::iterator kIt = findIt->second.find(it->first);
			if(kIt != findIt->second.end())
			{
				kIt->second += it->second;
			}
			else
			{
				findIt->second.insert(std::make_pair(it->first, it->second));
			}
		}
	}
	else
	{
		m_nDropItems.insert(std::make_pair(npcID, dropItems));
	}
}

void LC_ServerPlayer::GetDropItemInfo(int npcID, std::map<int, int>& dropItems)
{
	dropItems.clear();
	mem::map<int, mem::map<int, int> >::iterator findIt = m_nDropItems.find(npcID);
	if(findIt != m_nDropItems.end())
	{
		for(mem::map<int, int>::iterator it=findIt->second.begin(); it!=findIt->second.end(); ++it)
		{
			dropItems.insert(std::make_pair(it->first, it->second));
		}
		m_nDropItems.erase(findIt);
	}
}

int LC_ServerPlayer::RemoveErrorProcessingMainTask()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return 0;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return 0;
	}

	return pkTaskMap->RemoveErrorProcessingMainTask();
}

bool LC_ServerPlayer::RemoveProcessingTaskByTaskID(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return false;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return false;
	}

	return pkTaskMap->RemoveTaskProcessing(taskID);
}

void LC_ServerPlayer::FinishTask_bug(int index)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	LC_TaskMap* pkTaskMap = pkOwnerPlayer->GetTaskMap();
	if(NULL == pkTaskMap)
	{
		return;
	}

	pkTaskMap->AddToTaskFinishRecordByTaskSaveIndex(index);
}

void LC_ServerPlayer::UpdateControllerPlayerRespawn()
{
	++m_ControllerPlayerRespawnData.m_DeadTime;
	m_ControllerPlayerRespawnData.m_TimeStamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
}

int LC_ServerPlayer::TryInterruptSkill( uint32_t nSkillId, float fCurTime, int nInterruptType )
{
	if (nSkillId == -1)
		nSkillId = GetCurrentStateType();
	if (nSkillId == -1 || nSkillId == 0)
		return false;
	ClearNextSkill();
	if ( nInterruptType == SKI_FORCE_STAGE )
	{
		int32_t stateType = GetCurrentStateType();
		if ( IS_SKILL_TYPE(stateType) ) 
		{
			SK_SkillExecute* skillstate = (SK_SkillExecute*)GetCurrentState();
			if( skillstate )
			{
				skillstate->MoveNextStage(this, GET_PROCESS_TIME);
			}
		}
	}
	else
	{
		bool bInterruptError = false;
		ResultType iResult;

		Update(GET_PROCESS_TIME, 0.0f);

		iResult = CheckInterruptSkill(nSkillId, (SkillInterruptType)nInterruptType);

		if (iResult != RE_SKILL_NONE_ERROR)
			bInterruptError = true;
		else
		{
			iResult = InterruptSkill(fCurTime, nSkillId, (SkillInterruptType)nInterruptType);
		}

		//通知出错信息给请求玩家
		if (bInterruptError)
		{
			MG_Rlt_PlayerInterruptSkill rltMsg;
			rltMsg.m_iResultType			= iResult;
			rltMsg.m_lRequesterID			= m_iID;
			rltMsg.m_lSkillExecuteID		= nSkillId;
			rltMsg.m_usInterruptType		= nInterruptType;

			SendMsgToClient(MGPT_RLT_PLAYER_INTERRUPT_SKILL, &rltMsg);
		}
	}
	return true;
}

int LC_ServerPlayer::TryFinishSkill( uint32_t nSkillId, float fCurTime, int32_t nCurX, int32_t nCurY )
{
	if (nSkillId == -1)
		nSkillId = GetCurrentStateType();
	if (nSkillId == -1)
		return false;

	UT_Vec3Int kCurrentLocation;
	//		object_id_type lRequesterID		= finishMsg.m_lRequesterID;
	kCurrentLocation.x		= nCurX;
	kCurrentLocation.y		= nCurY;
	//		float fClientTime		= finishMsg.m_fClientTime;

	if (nSkillId == GetCurrentStateType())
	{
		SetCurrentLocation(kCurrentLocation);
		Update(GET_PROCESS_TIME, 0.0f);
	}
	return true;
}


int LC_ServerPlayer::ForceFinishCurrentSkill()
{
	float fCurrentTime = GET_PROCESS_TIME;
	TryInterruptSkill( -1, fCurrentTime, SKI_FORCE);
	TryFinishSkill( -1, fCurrentTime, GetCurrentLocation().x, GetCurrentLocation().y );

	return true;
}

void LC_ServerPlayer::NotifyCastSkillToAchievement(int achievementType)
{
	if(achievementType != LC_ACHIEVEMENT_TYPE_CAST_CATCH_SKILL)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->NotifyCastSkillToAchievement(achievementType);
	}

	AchievementEvent kEvent;
	kEvent.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_CAST_CATCH_SKILL, kEvent);
}

void LC_ServerPlayer::NotifyEventToGoal(int goalType, int param)
{
	if(goalType!=LC_GOAL_TYPE_CAST_SKILL_SUCCESS && goalType!=LC_GOAL_TYPE_ACCEPT_TASK)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->NotifyEventToGoal(goalType, param);
	}

	GoalEvent kGoalEvent;
	kGoalEvent.SetGoalEvent(param);
	DoGoalEvent(goalType, &kGoalEvent);
}

void LC_ServerPlayer::NotifyCastSkillToGatherTaskNpc(int npcCharID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "NotifyCastSkillToGatherTaskNpc c_uid:%d r1", GetUserID());
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->NotifyCastSkillToGatherTaskNpc(npcCharID);
	}

	const unique_id_impl& instance = GetInstance();
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "NotifyCastSkillToGatherTaskNpc npcID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", npcCharID, instance.detail(), instance.catagory(), GetUserID());
	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
	if (NULL != pkGameEvent)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "NotifyCastSkillToGatherTaskNpcpkGameEvent npcID:%d, mapID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", npcCharID, pkOwnerPlayer->GetMapResID(), instance.detail(), instance.catagory(), GetUserID());
		pkGameEvent->SetEventType(GLET_GATHER_TASKNPC);
		pkGameEvent->SetEventParam(EP_GATHERTASK_PLAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_GATHERTASK_NPC_CHAR_ID, npcCharID);
		pkGameEvent->SetEventParam(EP_GATHERTASK_MAPID, pkOwnerPlayer->GetMapResID());
		pkGameEventManager->InsertGameEvent(pkGameEvent);
	}
	else
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "NotifyCastSkillToGatherTaskNpc r2 c_cid:%d, c_citizenship:%d, c_uid:%d", instance.detail(), instance.catagory(), GetUserID());
	}
}

void LC_ServerPlayer::NotifyPlayerLoginIn(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyPlayerLoginIn(taskID);

	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
	if (NULL != pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_LOGIN_IN);
		pkGameEvent->SetEventParam(EP_LOGIN_IN_PLAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_LOGIN_IN_MAPID, GetMapResID());
		pkGameEvent->SetEventParam(EP_LOGIN_IN_TASKID, taskID);
		pkGameEventManager->InsertGameEvent(pkGameEvent);
	}
}

void LC_ServerPlayer::NotifyPlayerVipLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyPlayerVipLevel();
	int vipLevel = GetNewVipLevel();
	if (vipLevel>0)
	{
		LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_VIPLEVELUP);
			pkGameEvent->SetEventParam(EP_VIP_LEVEL_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_VIP_LEVEL, vipLevel);			
			pkGameEvent->SetEventParam(EP_VIP_LEVEL_MAPID, GetMapResID());
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}
}

void LC_ServerPlayer::NotifyPlayerAddGuild()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyPlayerAddGuild();

	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_ADD_GUILD);
			pkGameEvent->SetEventParam(EP_ADD_GUILD_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_ADD_GUILD_MAPID, GetMapResID());
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}
}

void	LC_ServerPlayer::NotifyTitleLevelToTask()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyTitleLevelToTask();

	int titleLevel = GetCommanderTitle();
	if(0 == titleLevel)
	{
		return;
	}

	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_TITLE_LEVEL);
			pkGameEvent->SetEventParam(EP_TITLE_LEVEL_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_TITLE_LEVEL_MAPID, GetMapResID());
			pkGameEvent->SetEventParam(EP_TITLE_LEVEL, titleLevel);
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}
}

void LC_ServerPlayer::NotifyTotalCashToTask(int cashType)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyTotalCashToTask(cashType);

	MoneyType totalCashNum = GetCashNumByCashType(cashType);

	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_TOTAL_ADD_CASH);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
		pkGameEvent->SetEventParam(EP_TOTAL_ADD_CASH_PlAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_TOTAL_ADD_CASH_COUNT, totalCashNum);
		pkGameEvent->SetEventParam(EP_TOTAL_ADD_CASH_TYPE, cashType);
		pkGameEvent->SetEventParam(EP_TOTAL_ADD_CASH_SRC_TYPE, 0);
		pkGameEvent->SetEventParam(EP_TOTAL_ADD_CASH_MAP_ID, GetMapResID());
		pkEventManager->InsertGameEvent(pkGameEvent);
	}
}

void LC_ServerPlayer::NotifyControllerLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NotifyControllerLevel();

	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (pkGameEvent != NULL)
		{
			pkGameEvent->SetEventType(GLET_PLAYER_LEVEL_UP);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
			pkGameEvent->SetEventParam(EP_LEVEL_UP_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_LEVEL_UP_VALUE, GetLevel());
			pkGameEvent->SetEventParam(EP_LEVEL_UP_MAPID, GetMapResID());
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	UpdatePlayerBaseDataToGroup();
}

void LC_ServerPlayer::NoticeAcceptTask(LC_Task* pkTask)
{
	if(NULL == pkTask)
	{
		return;
	}

	//接取任务成功后，通知其他系统统一在这儿做
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->NoticeAcceptTask(pkTask);

	CF_TaskList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TaskList>(pkTask->GetTaskID());
	if(NULL == pkData)
	{
		return;
	}

	CF_TaskCondition::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_TaskCondition>(pkData->_fCondition1);
	if(NULL == pkEntry)
	{
		return;
	}

	//接取累计登录任务后，累计任务计数+1
	if(pkEntry->_iType == TaskFinishCondition::TFT_LOGININ_DAY)
	{
		NotifyPlayerLoginIn(pkTask->GetTaskID());
	}
	else if(pkEntry->_iType == TaskFinishCondition::TFT_VIPLEVEL)
	{
		NotifyPlayerVipLevel();
	}
	else if(pkEntry->_iType==TaskFinishCondition::TFT_ADD_GUILD && INVALID_GUILD_ID!=GetGuildID())
	{
		NotifyPlayerAddGuild();
	}
	else if(pkEntry->_iType==TaskFinishCondition::TFT_TITLE_LEVEL)
	{
		NotifyTitleLevelToTask();
	}
	else if(pkEntry->_iType==TaskFinishCondition::TFT_TOTAL_ADD_CASH)
	{
		NotifyTotalCashToTask(pkEntry->_AddCashType);
	}
	else if(pkEntry->_iType==TaskFinishCondition::TFT_LEVEL)
	{
		NotifyControllerLevel();
	}

	//接取悬赏任务成功，增加接取次数
	if(pkTask->GetTaskType() == STT_REWARD_TASK)
	{
		ModifyAcceptRewardTaskTimes(true);
	}
}

int LC_ServerPlayer::CastSkill( uint32_t nSkillId, float fCurTime, int32_t nItemID, object_id_type nTargetId,  const UT_Vec3Int & rkCur, const UT_Vec3Int & rkLock, const UT_Vec3Int & rkMouse, int16_t nForwardAngle)//, bool bServerCast )
{
	//return true;
	SK_SkillExecute* pkSkill = SK_Factory::GetSingletonPtr()->RequestSkillExcute(nSkillId);
	if (pkSkill == NULL)
		return false;

	if (!GetHatredList()->CheckEnabled())
		return false;

	SetMouseLocation(rkMouse);

	int nRetCode = false;
	bool bLCSkill = false;
	int nOPType = pkSkill->GetProperty_OperationType();
	switch ( nOPType )
	{
	case SOT_TARGET:
		nRetCode = CastSkill_Target(pkSkill, fCurTime, nItemID, nTargetId, rkCur, bLCSkill);
		break;
	case SOT_DIR:
		nRetCode = CastSkill_Dir(pkSkill, fCurTime, nItemID, nTargetId, rkLock, nForwardAngle, bLCSkill);
		break;
	case SOT_LOCATION:
		nRetCode = CastSkill_Location(pkSkill, fCurTime, nItemID, rkCur, rkLock, bLCSkill);
		break;
	default:
		return false;
		break;
	}

	if (nRetCode)
	{
		m_fLastCastSkillTime = fCurTime;
		m_nCurrentSkillId = nSkillId;
		if (!bLCSkill)
		{
			ModifySkillUsableCount_Self(nSkillId, -DEFAULT_SKILL_USABLE_STEP_COUNT);
		}
	}
	return true;
}

int LC_ServerPlayer::TrySetDefaultTargetID( object_id_type nTargetID )
{
	if (GetControlType() != eControlType_Player)
		return false;
	SetLogicCombatFlag(true);
	if (GetSoloDulePlay())
	{
		LC_ServerPlayerManager* pMgr = SERVER_GET_PLAYER_MANAGER();
		LC_ServerPlayer* pOrigTarget = (LC_ServerPlayer*)pMgr->FindPlayer(m_lDefaultTargetID);
		if ( pOrigTarget && !pOrigTarget->GetDead() )
			return false;
	}
	SetDefaultTargetID( nTargetID );
	return true;
}

int LC_ServerPlayer::CastSkill_Dir( SK_SkillExecute* pkSkill, float fCurTime, int32_t nItemID, object_id_type nTargetId, const UT_Vec3Int & rkLock, int16_t nForwardAngle, bool& bLCSkill )
{
	int32_t iSkillExecuteID = pkSkill->GetExecuteID();
	int32_t lSkillItemID = nItemID;
	SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(iSkillExecuteID);
	if (!pkSkillExecute)
	{
		return false;
	}

	if (GetActionForbid()->IsActionForbid(LAFT_SKILL, LAF_SKILL_SKILL_ID, iSkillExecuteID))
	{
		return false;
	}

	if (IS_ITEM_ID(lSkillItemID))
	{
		if (GetActionForbid()->IsActionForbid(LAFT_ITEM, LAF_ITEM_SKILL_ITEM, lSkillItemID))
		{
			return false;
		}
	}

	UT_Vec2Float			kForwardDir;
	kForwardDir =			UT_MathBase::GetZRotDir(nForwardAngle);
	UT_Vec3Int				kLockedLocation(rkLock);

	bool bExecuteError = false;
	ResultType iResult = CheckExecuteSkill(fCurTime, pkSkill, lSkillItemID);
	if (iResult != RE_SKILL_CAN_TAKE_PLACE)
	{
		bExecuteError = true;
	}
	else
	{
		if (pkSkillExecute->GetProperty_IsLCSkill() )
		{
			bLCSkill = true;
			ExecuteLCSkillImmediately(fCurTime, pkSkill, nTargetId, kLockedLocation, nForwardAngle);
		}
		//方向型瞬发技能
		else if (SOT_DIR == pkSkillExecute->GetProperty_OperationType() && pkSkillExecute->GetProperty_ExecuteImmediately())
		{
			SetLockedTargetID(nTargetId);
			SetLockedLocation(kLockedLocation);
			ExecuteSkillImmediately(fCurTime, pkSkill, lSkillItemID);
		}

		else
		{
			SetLockedTargetID(nTargetId);
			SetLockedLocation(kLockedLocation);

			//先挂起技能
			iResult = PendingSkill(iSkillExecuteID, lSkillItemID);
			if (iResult != RE_SKILL_PENDING_SUCCESS)
			{
				bExecuteError = true;
			}
			else
			{
				ClearPendingSkill();
				SetForwardDir(kForwardDir);
				ExecuteSkill(fCurTime, pkSkillExecute, lSkillItemID);
				Update(fCurTime, 0.0f);
			}
		}
	}

	//通知出错信息给请求玩家
	if (bExecuteError)
	{
		MG_Rlt_PlayerExecuteSkillTypeDir rltMsg;
		rltMsg.m_lRequesterID			= m_iID;
		rltMsg.m_lSkillExecuteID		= iSkillExecuteID;
		rltMsg.m_iResultType			= iResult;
		rltMsg.m_fServerTime			= fCurTime;
		static float fStaticCurTime = fCurTime;
		float fDeltaCurTime = fCurTime - fStaticCurTime;
		fStaticCurTime = fCurTime;

		SendMsgToClient(MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_DIR, &rltMsg);

		return false;
	}

	return true;
}

int LC_ServerPlayer::CastSkill_Location( SK_SkillExecute* pkSkill, float fCurTime, int32_t nItemID, const UT_Vec3Int & rkCur, const UT_Vec3Int & rkLock, bool& bLCSkill )
{
	int32_t iSkillExecuteID = pkSkill->GetExecuteID();
	int32_t lSkillItemID = nItemID;
	SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(iSkillExecuteID);
	if (!pkSkillExecute)
	{
		return false;
	}

	if (GetActionForbid()->IsActionForbid(LAFT_SKILL, LAF_SKILL_SKILL_ID, iSkillExecuteID))
	{
		return false;
	}

	if (IS_ITEM_ID(lSkillItemID))
	{
		if (GetActionForbid()->IsActionForbid(LAFT_ITEM, LAF_ITEM_SKILL_ITEM, lSkillItemID))
		{
			return false;
		}
	}

	UT_Vec3Int				kCurrentLocation(rkCur);
	UT_Vec3Int				kLockedLocation(rkLock);

	bool bExecuteError = false;
	ResultType iResult;

	SetLockedLocation(kLockedLocation);
	iResult = CheckExecuteSkill(fCurTime, pkSkill, lSkillItemID);
	if (pkSkill->GetProperty_IsLCSkill())
	{
		bLCSkill = true;
	}
	if (iResult != RE_SKILL_CAN_TAKE_PLACE)
	{
		bExecuteError = true;
	}
	else
	{
		//先挂起技能
		iResult = PendingSkill(iSkillExecuteID, lSkillItemID);
		if (iResult != RE_SKILL_PENDING_SUCCESS)
		{
			bExecuteError = true;
		}
		else
		{
			ClearPendingSkill();
			ExecuteSkill(fCurTime, pkSkillExecute, lSkillItemID);
			Update(fCurTime, 0.0f);
		}
	}



	//通知出错信息给请求玩家
	if (bExecuteError)
	{
		MG_Rlt_PlayerExecuteSkillTypeLocation rltMsg;
		rltMsg.m_lRequesterID			= m_iID;
		rltMsg.m_lSkillExecuteID		= iSkillExecuteID;
		rltMsg.m_iResultType			= iResult;
		rltMsg.m_fServerTime			= fCurTime;

		SendMsgToClient(MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_LOCATION, &rltMsg);

		return false;
	}

	return true;
}

int LC_ServerPlayer::CastSkill_Target( SK_SkillExecute* pkSkill, float fCurTime, int32_t nItemID, object_id_type nTargetId, const UT_Vec3Int & rkCur, bool& bLCSkill )
{
	int32_t lSkillExecuteID = pkSkill->GetExecuteID();
	int32_t lSkillItemID = nItemID;
	if (GetActionForbid()->IsActionForbid(LAFT_SKILL, LAF_SKILL_SKILL_ID, lSkillExecuteID))
	{
		return false;
	}

	if (IS_ITEM_ID(lSkillItemID))
	{
		if (GetActionForbid()->IsActionForbid(LAFT_ITEM, LAF_ITEM_SKILL_ITEM, lSkillItemID))
		{
			return false;
		}
	}

	bool bExecuteError = false;
	ResultType iResult;

	SetLockedTargetID(nTargetId);
	iResult = CheckExecuteSkill(fCurTime, pkSkill, lSkillItemID);
	if (iResult != RE_SKILL_CAN_TAKE_PLACE)
	{
		bExecuteError = true;
	}
	else
	{
		if (pkSkill->GetProperty_IsLCSkill() )
		{
			bLCSkill = true;
			ExecuteLCSkillTargetImmediately(fCurTime, pkSkill, nTargetId);
		}
		else
		{
			//先挂起技能
			iResult = PendingSkill(lSkillExecuteID, lSkillItemID);
			if (iResult != RE_SKILL_PENDING_SUCCESS)
			{
				bExecuteError = true;
			}
			else
			{
				ClearPendingSkill();
				ExecuteSkill(fCurTime, pkSkill, lSkillItemID);
			}
		}
	}

	Update(fCurTime, 0.0f);

	//通知出错信息给请求玩家
	if (bExecuteError)
	{
		MG_Rlt_PlayerExecuteSkillTypeTarget rltMsg;
		rltMsg.m_lRequesterID			= m_iID;
		rltMsg.m_lSkillExecuteID		= lSkillExecuteID;
		rltMsg.m_lLockTargetID			= nTargetId;
		rltMsg.m_iResultType			= iResult;
		rltMsg.m_fServerTime			= fCurTime;

		SendMsgToClient(MGPT_RLT_PLAYER_EXECUTE_SKILL_TYPE_TARGET, &rltMsg);

		return false;
	}
	return true;
}

uint64_t LC_ServerPlayer::GetMJBossValue()
{
	uint64_t value = 0;
	const RaidInfo* pkRaid = GetRaidAsset()->GetRaidCatTop(RD_CAT_TP_MJBOSS);
	if (pkRaid)
	{
		uint32_t time = LC_Helper::TimeStampReverse(pkRaid->m_iClearRecord);
		value = LC_Helper::EncodeScore(pkRaid->m_iRaidId, time);
	}
	return value;
}

int32_t LC_ServerPlayer::GetEndlessTotalFloor()
{
	int floorCount = 0;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return floorCount;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetEndlessTotalFloor();
	}

	for(int i=LC_CMN_STAT_TP_ENDLESS_TOWER_1; i<=LC_CMN_STAT_TP_ENDLESS_TOWER_6; ++i)
	{
		LC_CommonStatAsset& kCommonStatAsset = GetCommonStatAsset();
		LC_CommonStatEntry* pkCmnStatEntry = kCommonStatAsset.GetCommonStatEntry(i);
		if(NULL == pkCmnStatEntry)
		{
			continue;
		}

		floorCount += pkCmnStatEntry->GetStatEntry(LC_CMN_STAT_ENTRY_KEY_STORY_CUR_BATCH);
	}

	return floorCount;
}

void LC_ServerPlayer::GetEndlessRecords(mem::map<int, int>& records)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	CF_EndlessTower::DataEntryMapExternIterator iter = CF_EndlessTower::GetSingletonPtr()->GetIterator();
	while(iter.HasMoreElements())
	{
		CF_EndlessTower::DataEntry* pkData = iter.PeekNextValuePtr();
		int storyID = pkData->_iGameStoryID;
		LC_CommonStatAsset& kCommonStatAsset = GetCommonStatAsset();
		LC_CommonStatEntry* pkCmnStatEntry = kCommonStatAsset.GetCommonStatEntry(pkData->_iType);
		if(pkCmnStatEntry != NULL)
		{
			int stat = pkCmnStatEntry->GetStatEntry(LC_CMN_STAT_ENTRY_KEY_STORY_CUR_BATCH);
			records.insert(std::make_pair(pkData->_iGameStoryID, stat));
		}
		iter.MoveNext();
	}
}

bool LC_ServerPlayer::checkEnterEndLessTower(CF_EndlessTower::DataEntry* pkData)
{
	bool PreFinish = false;
	bool CurrentFinish = false;
	if(pkData->_PreStoryID == 0)
	{//无尽之塔无前置层
		PreFinish = true;	
	}

	if(!PreFinish)
	{
		CF_EndlessTower::DataEntry* pkPreData = SafeGetCSVFileDataEntryPtr<CF_EndlessTower>(pkData->_PreStoryID);
		if(NULL != pkPreData)
		{
			PreFinish = CheckEndLessTowerIsFinished(pkPreData->_iType);
		}
	}

	if(PreFinish)
	{
		CurrentFinish = CheckEndLessTowerIsFinished(pkData->_iType);
	}

	return (PreFinish && !CurrentFinish);
}

bool LC_ServerPlayer::CheckEndLessTowerIsFinished(int type)
{
	LC_CommonStatEntry* pkStatEntry = GetCommonStatAsset().GetCommonStatEntry(type);
	if(NULL == pkStatEntry)
		return false;

	return pkStatEntry->IsFinished();
}

int32_t LC_ServerPlayer::GetCurrentOpBuddy()
{
	return m_nCurrentOpBuddyId;
}

int LC_ServerPlayer::DeallocateBuddy()
{
	LC_ServerPlayerManager* pkPlayerManager = SERVER_GET_PLAYER_MANAGER();
	for ( int i = 1; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pkPlayerManager->DestroyPlayer(pResultPlayer);
	}
	return true;
}

void LC_ServerPlayer::BuddyControllerOperation_Move(MG_Sync_GamePlayerMove& syncMsg, float fCurrentTime)
{
	LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(m_nCurrentBuddyIndex);
	IF_A_NA_PLAYER(pResultPlayer) 
		return;
	pResultPlayer->BuddyOperation_Move(syncMsg, fCurrentTime);
}
#define			TEMP_FOLLOW_DISTANCE		400
void LC_ServerPlayer::BuddyOperation_Move(MG_Sync_GamePlayerMove& syncMsg, float fCurrentTime, bool bForce)
{
	// Check deny move
	bool bDenyMove = GetDenyMove();
	if ( bDenyMove )
	{
		StopMove();
		return;
	}
	int32_t nSkillStage = GetSkillStage();
	int32_t nCurSkillId = GetCurrentStateType();
	SK_SkillExecute* pCurSkill = SK_Factory::GetSingletonPtr()->RequestSkillExcute(nCurSkillId);
	if (pCurSkill)
	{
		if (!pCurSkill->GetProperty_SkillStageCanMoveServer(nSkillStage) && !(SPC_INDUCE == pCurSkill->GetProperty_SkillProcessCategory() && pCurSkill->GetProperty_ToMouseDirection()))
		{
			StopMove();
			return;
		}
	}

	//传送时会有时序错误，用这种方式修正
	int lMapID = syncMsg.m_lMapID;
	if (GetMapLogicID() != lMapID)
	{
		return;
	}
	UT_Vec3Int kCurrentLocation;
	UT_Vec3Int kTargetLocation;
	kCurrentLocation = GetCurrentLocation();
	int16_t nForwardAngle = UT_MathBase::GetZRotAngle(GetForwardDir());
	if (
		syncMsg.m_lCurrentLocationX == syncMsg.m_lTargetLocationX 
		&& syncMsg.m_lCurrentLocationY == syncMsg.m_lTargetLocationY
		&& syncMsg.m_lCurrentLocationX == kCurrentLocation.x
		&& syncMsg.m_lCurrentLocationY == kCurrentLocation.y
		&& syncMsg.m_nActionMode == GetMoveActionMode()
		&& abs(syncMsg.m_sCurrentDirAngle - nForwardAngle) < 2
		)
	{
		//printf("sync to stop\n");
		return;
	}
	kCurrentLocation.x = syncMsg.m_lCurrentLocationX;
	kCurrentLocation.y = syncMsg.m_lCurrentLocationY;
	kCurrentLocation.z = syncMsg.m_lCurrentLocationZ;
	kTargetLocation.x	= syncMsg.m_lTargetLocationX;
	kTargetLocation.y	= syncMsg.m_lTargetLocationY;

	if (GetControlType() == eControlType_Buddy)
	{
		if ( syncMsg.m_lMoveSpeed > 0 )
		{
			//int32_t nXOffset = UT_MathBase::RandInRangeInt(-TEMP_FOLLOW_DISTANCE, TEMP_FOLLOW_DISTANCE);
			//int32_t nYOffset = UT_MathBase::RandInRangeInt(-TEMP_FOLLOW_DISTANCE, TEMP_FOLLOW_DISTANCE);
			//kTargetLocation.x += nXOffset;
			//kTargetLocation.y += nYOffset;
		}
		if ( syncMsg.m_lMoveSpeed == 0 )
		{
			kTargetLocation.x = GetCurrentLocation().x;
			kTargetLocation.y = GetCurrentLocation().y;
			kCurrentLocation.x = kTargetLocation.x;
			kCurrentLocation.y = kTargetLocation.y;
		}
	}

	AccumulateMoveDistance(kCurrentLocation);

	CheckTimePassValid(syncMsg.m_fClientTime, fCurrentTime, 0.5f);

	bool bMoveCheckValid = CheckSyncMoveValid(kCurrentLocation);
	if (!bMoveCheckValid)
	{
		MG_Sync_GamePlayerMove rltMsg = syncMsg;
		rltMsg.m_iPlayerID =GetID();
		rltMsg.m_lCurrentLocationX = GetLastMoveCheckLocation().x;
		rltMsg.m_lCurrentLocationY = GetLastMoveCheckLocation().y;
		rltMsg.m_lTargetLocationX  = GetLastMoveCheckLocation().x;
		rltMsg.m_lTargetLocationY  = GetLastMoveCheckLocation().y;
		SendMsgToClient(MGPT_SYNC_GAME_PLAYER_MOVE, &rltMsg);

		return;
	}

	if ( GetRiderCharType() > 0 && !GetPKRecorder()->GetFightState() && syncMsg.m_lMoveSpeed > 0.0f)
	{
		SetRunMoveTick(GET_PROCESS_TIME);
		SetSyncPlayerMove(true);
	}
	else
	{
		SetSyncPlayerMove(false);
	}

	SetCurrentLocation(kCurrentLocation);
	SetTargetLocation(kTargetLocation);
	SetMoveSpeed(syncMsg.m_lMoveSpeed);
	SetMoveActionMode(syncMsg.m_nActionMode);
	UpdateWorldLocationAssetData();
	if ( bForce == false )
		SetForwardDirAngle((float)syncMsg.m_sCurrentDirAngle);
}


int LC_ServerPlayer::ResetBuddy()
{
	//m_pOwnerPlayer = NULL;
	m_nOwnerPlayerId = INVALID_ACTOR_ID;
	m_nBuddyTemplateId = 0;
	m_nCurrentBuddyIndex = 0;
	//m_nUnlockedActivateBuddyCount = MAX_ACTIVE_BUDDY_NUM;
	m_nUnlockedActivateBuddyCount = 1;
	m_nAllocatedActivateBuddyCount = 0;
	m_nCurrentOpBuddyId = 0;
	m_nTotalActivatedSkillCount = 0;
	//m_ppUsableBuddyData.reset();
	//m_ppActivateBuddyData
	m_ppActivateBuddyTemplateId.clear();
	m_ppActivateBuddyObjectId.clear();
	m_ppActivateBuddyDataPtr.clear();
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		m_ppActivateBuddyTemplateId.push_back(INVALID_ACTOR_ID);
		m_ppActivateBuddyObjectId.push_back(INVALID_ACTOR_ID);
		m_ppActivateBuddyDataPtr.push_back(NULL);
		m_fBuddyAutoRespawnTimer[i] = 0.00f;
	}
	m_ppUsableBuddyData.clear();
	for (mem::map<int32_t, BuddyInstance *>::iterator it = m_ppUsableBuddyInstance.begin();it != m_ppUsableBuddyInstance.end();it++)
	{
		if (it->second !=NULL)
		{
			T_SAFE_DELETE(it->second);
		}
	}
	m_ppUsableBuddyInstance.clear();
	m_nPlayerControlType = eControlType_Init;
	m_pAssignedBuddyInstance = NULL;
	memset(&m_AIData, 0, sizeof(m_AIData));
	memset(&m_SkyArenaData, 0, sizeof(m_SkyArenaData));
	m_nAliveBuddyCount = 0;
	m_bBuddyRelive = true;
	m_bForceLocalRelive  = false;
	m_bReliveFlag_Recover = false;
	m_fLastBuddyControllerUpdate_Fight = 0.00f;
	m_fLastCastSkillTime = 0.00f;
	m_nCurrentSkillId = -1;
	m_pNextSkillEntry = NULL;
	m_bLogicCombatFlag = false;
	m_bFollowMode_Combat = false;
	m_fRollSkillTimer = 0.00f;
	m_nIndexAsBuddy = -1;
	m_fOwnerMPTimer = GET_PROCESS_TIME;
	m_pDynamicSkillAsset = &m_kSkillAsset;
	m_bBuddyAIParam_ForceFollowMode = false;
	m_bBuddyAIParam_DebugMode = false;
	m_bBuddyAIParam_AttackMode = false;
	m_bBuddyAIParam_ControllerDebugMode = false;
	m_bBuddyAIParam_FollowAttackMode = false;
	m_eBuddyActionType = eBuddyActionType_Init;
	m_nLastTargetDistance = 0;
	m_fRunStateAccumulator = 0;
	m_nControllerCombatScore = 0;
	m_RecomputerControllerScore = false;
	m_nActivateBuddyInSceneCount = 0;
	m_bStateMapInitFlag = false;
	m_bSoloDulePlay = false;
	m_bRecoverFromSoloPlay = false;
	m_bSwitchLogicMap = false;
	m_nOrigMapLogicType = -1;
	m_pkSession = NULL;
	m_nSessionId = 0;
	m_bAutoSafeRelive = false;
	m_bInternalSwitchScene = false;
	ResetSnapshotData();
	m_fLastPVPTime = 0.00f;
	m_fBuddyRespawnTickCount = 0.00f;
	m_CommonItemRecordSet.clear();
	m_nSummitArenaHonorMaps.clear();
	b_ActivateSummitArena = false;
	b_NotifySummitArenaState = false;
	return true;
}


void LC_ServerPlayer::SyncBuddyData()
{
	SyncBuddyData_Activate();
	SyncBuddyData_Usable();
	SyncBuddyData_ActivateCount();
}

void LC_ServerPlayer::SyncBuddyData_Usable()
{
	int32_t nBuddyCount = 0;
	MG_SC_BuddyDataSync sync;
	int nCount = m_ppUsableBuddyData.size();
	mem::map<int32_t, SingleBuddyData>::iterator it = m_ppUsableBuddyData.begin();
	for ( ; it != m_ppUsableBuddyData.end(); ++it )
	{
		SingleBuddyData& data = it->second;
		if (data.nBuddyTemplateId == INVALID_ACTOR_ID)
			continue;
		sync.m_Data[nBuddyCount].nBuddyTemplateId = data.nBuddyTemplateId;
		sync.m_Data[nBuddyCount].nLevel = data.nLevel;
		sync.m_Data[nBuddyCount].bUnlock = data.bUnlock;
		nBuddyCount++;
	}

	sync.m_nCount = nBuddyCount;

	SendMsgToClient(MGPT_SC_BUDDY_DATA_SYNC, &sync);
}

void LC_ServerPlayer::SyncBuddyData_ActivateCount()
{
	MG_SC_ActivateBuddyCount data;
	data.m_nCount = m_nUnlockedActivateBuddyCount;
	SendMsgToClient(MGPT_SC_ACTIVATE_BUDDY_COUNT, &data);
}

void LC_ServerPlayer::SyncBuddyData_Activate()
{
	int32_t nBuddyCount = 0;
	MG_SC_ActivateBuddyDataSync sync;
	//int nActiveCount = m_ppActivateBuddyTemplateId.size();
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		sync.m_Data[i].nBuddyTemplateId = m_ppActivateBuddyTemplateId[i];
		sync.m_Data[i].nLevel = 1;
		sync.m_Data[i].bAlive = 1;
		sync.m_Data[i].nObjectId = pResultPlayer->m_iID;
		nBuddyCount++;
	}

	sync.m_nCount = MAX_ACTIVE_BUDDY_NUM;
	sync.m_nCurrentIndex = m_nCurrentBuddyIndex;
	SendMsgToClient(MGPT_SC_ACTIVATE_BUDDY_DATA_SYNC, &sync);
}

bool LC_ServerPlayer::AllocateBuddy(int32_t nMapLogicId, bool bControllee )
{
	m_nActivateBuddyInSceneCount = 0;
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* pkMapLogic = pkWorldManager->GetMapLogic(nMapLogicId);
	if (pkMapLogic == NULL)
		return false;

	if (m_nAllocatedActivateBuddyCount > 0)
	{
		m_bInternalSwitchScene = true;
		if (CheckOwnerDead())
		{
			m_bAutoSafeRelive = true;
		}
		return false;
	}
	else
	{
		m_bInternalSwitchScene = false;
	}

	MapType eMapType = (MapType)pkMapLogic->GetMapLogicType();
	SetOwnerPlayerId(m_iID);
	PushBuddyInstance(this, 0, true);
	if (GetAIControl())
		m_nCurrentBuddyIndex = 0;
	
	if (0 == m_nCurrentBuddyIndex )
		SetControlType(eControlType_Player);
	else
		SetControlType(eControlType_Buddy);

	GetAssignedBuddyInstance()->OnBind(GetID());

	int nCurIdx = 0;
	for ( int i = 1; i < m_nUnlockedActivateBuddyCount; i++ )
	{
		if (m_ppActivateBuddyTemplateId[i] == INVALID_ACTOR_ID)
			continue;

		// 这里的需求，就是创建出 buddy 附体的 player
		object_id_type instanceID = LC_LogicIDManager::GetSingletonPtr()->RequestLogicID(LOT_BUDDY);		
		Utility::UT_Vec3Int pos = m_kCurrentLocation;
		uint32_t ubits = 0;
		// 竞技场 创建buddy 
		if(bControllee)
			ubits |= (PLY_DEF_CLONE_BITS|PLY_DEF_BUDDY_BITS);
		else
			ubits |= PLY_DEF_BUDDY_BITS;

		LC_ServerPlayer* pActivatePlayer = pkMapLogic->SpawnBuddyPlayer(m_iID, instanceID, pos, ubits, this, NULL, FACTION_PLAYER);
		if (pActivatePlayer == NULL)
			continue;

		nCurIdx++;
		if ( nCurIdx == m_nCurrentBuddyIndex )
			pActivatePlayer->SetControlType(eControlType_Player);
		else
			pActivatePlayer->SetControlType(eControlType_Buddy);

		pActivatePlayer->SetBuddyAllocateId(instanceID);
		PushBuddyInstance(pActivatePlayer, i, true);
		pActivatePlayer->GetAssignedBuddyInstance()->OnBind(pActivatePlayer->GetID());
	}
	m_nDataStatus = 1;
	return true;
}

int LC_ServerPlayer::InitBuddyLogicData_ServerPlayer(BuddyInstance* pBuddy, int32_t nBuddyID)
{
	InitBuddyLogicData_BasePlayer(pBuddy, nBuddyID);
	m_kAttributeTimer.SetTimer(60);
	m_kUpdateLogicAreaInfo.SetTimer(1.0f);

	m_iHeartBeatCount = 0;

	_initSMController("");
	_initStateMap("");

	{
		m_kUpdateAssetTimers.resize(ASSET_TIMER_MAX);
		mem::vector<Utility::UT_Timer>::iterator it = m_kUpdateAssetTimers.begin();
		for (int i = 0; it != m_kUpdateAssetTimers.end(); ++it, ++i)
		{
			it->SetTimer(assetTimers[i]);
		}
	}

	if (!IsInstance())
	{
		return false;
	}

	m_DBUpdateTimer.SetTimer(_DBP_UPDATE_CYCLE_DELAY);
	m_UpdateItemTimer.SetTimer(_GSP_UPDATE_ITEM);
	m_kLogTimer.SetTimer(15);

	m_kUpdateCashOPTimer.SetTimer(_GSP_UPDATE_CASH_OP);

	return true;
}

int LC_ServerPlayer::InitBuddyLogicData_BasePlayer(BuddyInstance* pBuddy, int32_t nBuddyID)
{
	InitBuddyLogicData_BaseActor(pBuddy, nBuddyID);

	//设置默认状态
	//m_iDefaultState		= ST_PLAYER_STAND;
	m_iDefaultState = ST_NONE;

	ClearDirtyFlag();
	ClearDirtyFlagRevisionID();
	return true;
}

int LC_ServerPlayer::InitBuddyLogicData_BaseActor(BuddyInstance* pBuddy, int32_t nBuddyID)
{
	m_kCharType.set(nBuddyID);
	return true;
}

void LC_ServerPlayer::InitAIData()//CF_Buddy::DataEntry* pkBuddy)
{
	// 
}

void LC_ServerPlayer::SwitchSMToBuddy()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;
	if (pOwner->GetAIControl())
		return;
	_uninitStateMap();
	ClearState();
	{
#if 1
		SM_ServerStateFactory* pkStateFactory = (SM_ServerStateFactory*)SM_ServerStateFactory::GetSingletonPtr();

		m_kStateMap[ST_DEFAULT]			= pkStateFactory->RequestState(ST_DEFAULT);

		for (int i = ST_PLAYER_STAND; i <= ST_PLAYER_CHASE; i++)
		{
			m_kStateMap[i] = pkStateFactory->RequestState(i);
		}
		RefreshSMController();
#endif
	}
}

void LC_ServerPlayer::SwitchSMToPlayer()
{
	bool bAIControl = GetAIControl();
	if ( bAIControl )
	{
		_initStateMap("", true);
		_initSMController("");
		return;
	}
	else
	{
		_uninitStateMap();
		ClearState();
	}
	{
		SM_ServerStateFactory* pkStateFactory = (SM_ServerStateFactory*)SM_ServerStateFactory::GetSingletonPtr();
		m_kStateMap[ST_DEFAULT]			= pkStateFactory->RequestState(ST_DEFAULT);
		m_kStateMap[ST_PLAYER_STAND]			= pkStateFactory->RequestState(ST_PLAYER_STAND);
	}
}

void LC_ServerPlayer::InitDataAsBuddy(uint32_t nBuddyTemplateId, bool bCreation)
{
	CF_Buddy* pBuddyConfig = CF_Buddy::GetSingletonPtr();
	CF_Buddy::DataEntry* pData = pBuddyConfig->GetEntryPtr(nBuddyTemplateId);
	if (pData == NULL)
		return;

	m_nBuddyTemplateId = nBuddyTemplateId;

	LC_SkillAsset* pSkills = GetSkillAsset();
	if (pSkills == NULL)
		return;
	InitAIData();//pData);
}

int LC_ServerPlayer::GetPetSkillDamageByMode(PetDamageMode eMode)
{
	int nResult = 0;
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return nResult;

	if (!IsMainController())
		return pOwner->GetPetSkillDamageByMode(eMode);

	int nDmg[MAX_ACTIVE_BUDDY_NUM] = {0,0,0};
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer =  pOwner->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		LC_ActorAttributeMap* pAttrMap = pResultPlayer->GetFinalAttributeMap();
		if (pAttrMap == NULL)
			continue;
		nDmg[i] = pAttrMap->GetAttribute(ATT_MAX_ATK);
	}

	//玩具技能的攻击取值：可配置Q+E+R、Q+E、Q+R的buddy攻击之和
	switch (eMode)
	{
	case PET_DAMAGE_MODE_QER:
		nResult = nDmg[0] + nDmg[1] + nDmg[2];
		break;
	case PET_DAMAGE_MODE_QE:
		nResult = nDmg[0] + nDmg[1];
		break;
	case PET_DAMAGE_MODE_QR:
		nResult = nDmg[0] + nDmg[2];
		break;
	default:
		break;
	}

	return nResult;
}

bool LC_ServerPlayer::SwitchBuddyScheme(uint32_t mapID, uint32_t groupID, uint32_t schemeType, bool bRelive, bool forceSwitch)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->SwitchBuddyScheme(mapID, groupID, schemeType, bRelive, forceSwitch);

	return SwitchBuddyScheme_Impl(mapID, groupID, schemeType, bRelive, forceSwitch);
}

bool LC_ServerPlayer::SwitchBuddyScheme_Impl(uint32_t mapID, uint32_t groupID, uint32_t schemeType, bool bRelive, bool forceSwitch)
{
	if(m_pkMap == NULL)
	{
		return false;
	}

	//是否允许切换buddy
	if(!forceSwitch)
	{
		int nRetCode = CheckActivateBuddyCDTime(GET_PROCESS_TIME);
		if(nRetCode == false)
		{
			return false;
		}
		SetLastActivateBuddyTime(GET_PROCESS_TIME);
	}

	//切换出战阵容的时候，要检测是否需要切换（不需要设置阵容的地图之间跳转，不需要切阵容）
	if(schemeType == SchemeType_Offensive)
	{
		bool tag = GetBuddySchemeMgr().CheckNeedSwitchBuddyOffensiveScheme(mapID, groupID);
		if(!tag)
		{
			return false;
		}
	}

	mem::vector<int> buddyIDVec;
	int32_t  currentSchemeID = GetBuddySchemeMgr().GetBuddySchemeData(this, mapID, groupID, schemeType, buddyIDVec);
	if(buddyIDVec.empty() || -1==currentSchemeID)
	{
		return false;
	}
	
	if(bRelive)
	{
		ReliveAllBuddyBeforeEnterMap(true, true);
	}

	if(schemeType==SchemeType_Offensive)
	{
		GetBuddySchemeMgr().SetCurrentSchemeInfo(currentSchemeID, groupID);
	}

	const unique_id_impl& instance = GetInstance();
	bool bRet = BindBuddyInstance(0, buddyIDVec[0], false, currentSchemeID);
	if (!bRet)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "switch_scheme_bind_err:0, c_cid:%d, c_citizenship:%d, c_uid:%d", instance.detail(), instance.catagory(), GetUserID());
	}

	SetCurrentBuddy(0);

	BuddyInstance* pFirstInstance = GetBuddyInstanceByID(buddyIDVec[0]);
	if ( pFirstInstance )
		pFirstInstance->SetLockAssignedPlayerId(true);

	for ( int i = 1; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		bRet = UnBindBuddyInstance(i, false);
		if (!bRet)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "switch_scheme_unbind_err:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", i, instance.detail(), instance.catagory(), GetUserID());
		}
	}

	for ( int i = 1; i < buddyIDVec.size(); i++ )
	{
		bRet = BindBuddyInstance(i, buddyIDVec[i], false, currentSchemeID);
		if (!bRet)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "switch_scheme_bind_err:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", i, instance.detail(), instance.catagory(), GetUserID());
		}
	}
	if (pFirstInstance)
		pFirstInstance->SetLockAssignedPlayerId(false);

	//目前出战阵容
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL != pkOwnerPlayer)
	{
		LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
		{
			LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
			if (NULL != pkGameEvent)
			{
				pkGameEvent->SetEventType(GLET_PRESENT_BUDDYELEM);
				pkGameEvent->SetEventParam(EP_PRESENT_BUDDYELEM_PLAYER_ID, pkOwnerPlayer->GetID());
				pkGameEvent->SetEventParam(EP_PRESENT_BUDDYELEM_MAPID, pkOwnerPlayer->GetMapResID());

				mem::vector<int> buddyElem;
				pkOwnerPlayer->GetBuddyPresentElem(buddyElem);
				int param = EP_PRESENT_BUDDYELEM_ELEMTYPE1;
				for(int i=0; i<buddyElem.size(); ++i, ++param)
				{
					pkGameEvent->SetEventParam(param, buddyElem[i]);
				}
				pkGameEventManager->InsertGameEvent(pkGameEvent);
			}
		}
	}

	MG_SC_BuddyActivateSchemeType sync_type;
	sync_type.m_nCurrentType = currentSchemeID;
	SendMsgToClient(MGPT_SC_SYNC_BUDDY_ACTIVATE_SCHEME_TYPE, &sync_type);
	return true;
}

int LC_ServerPlayer::ActivateBot( int32_t nResId, bool bForce )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->ActivateBot(nResId, bForce);
	return false;
}

int LC_ServerPlayer::UpgradeBot( int32_t nResId, bool bForce )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->UpgradeBot(nResId, bForce);
	return false;
}

int LC_ServerPlayer::UpdateBot( float fDelta, float fCurrent )
{
	if (!IsMainController())
		return true;
	return true;
}

ResultType LC_ServerPlayer::TryFetchNewVIPBonus()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return RE_FAIL;

	if ( !IsMainController() )
		return pOwner->TryFetchNewVIPBonus();

	return m_NewVIPReward.TryFetchBonus();
}

int LC_ServerPlayer::TryFetchBotBonus()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if ( !IsMainController() )
		return pOwner->TryFetchBotBonus();
	return true;
}


int32_t LC_ServerPlayer::GetMaxBotBonusTimer()
{
	int32_t addPlus = 0;
	int vipLevel = GetVIPLevel();
	LC_VIPCmnManager* pkMgr = LC_VIPCmnManager::GetSingletonPtr();
	if(pkMgr != NULL)
	{
		LC_VIPProfitDataEntry* pkDataEntry = pkMgr->GetVIPProfitDataEntry(VIP_PROFIT_BOT);
		if(pkDataEntry != NULL)
		{
			addPlus = pkDataEntry->GetValue(vipLevel, false);
		}
	}
	return addPlus*ONE_MINUTE_SECONDS +GetGlobalSetting.nBotBonusTimer_Max;
}

int LC_ServerPlayer::FetchBotNormalBonus( int nSeconds, int nType )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->FetchBotNormalBonus(nSeconds, nType);

	bool bVIP = m_NewVIPReward.FetchNormalBonus(nSeconds, nType);

	return bVIP;
}



ResultType LC_ServerPlayer::OpenPetSystem(int petID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->OpenPetSystem(petID);
	}

	return m_PetInstanceMgr.Activate(petID);
}

void LC_ServerPlayer::_updateNewVIPReward( float fCurrent, float fDelta )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->_updateNewVIPReward(fCurrent, fDelta);

	if (GetAIControl())
		return;

	//int nVIPLevel = 1;
	m_NewVIPReward.Update( fCurrent, fDelta );
}

int LC_ServerPlayer::CapturePet( int32_t nResId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->CapturePet(nResId);

	return m_PetInstanceMgr.CapturePet(nResId, GetLotteryStat());
}

int LC_ServerPlayer::EnablePet( int16_t nIndex )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->EnablePet(nIndex);

	int nRetCode = m_PetInstanceMgr.EnablePet(nIndex);
	PetInstance* pInstance = m_PetInstanceMgr.GetEnabledPetInstance();
	if (pInstance)
	{
		MG_SC_PetOp_SwitchEnableIndex rltMsg;
		rltMsg.m_nTemplateId = pInstance->GetTemplateId();
		rltMsg.m_nOwnerId = GetID();
		BroadCastTransferToAreaWithoutMe(GetID(), MGPT_SC_PET_SWITCH_ENABLED_INDEX, &rltMsg);
	}

	return nRetCode;
}

int LC_ServerPlayer::DisablePet()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->DisablePet();

	int nRetCode = m_PetInstanceMgr.DisablePet(false);
	if (nRetCode)
	{
		MG_SC_PetOp_SwitchEnableIndex rltMsg;
		rltMsg.m_nTemplateId = INVALID_ACTOR_ID;
		rltMsg.m_nOwnerId = GetID();
		BroadCastTransferToAreaWithoutMe(GetID(), MGPT_SC_PET_SWITCH_ENABLED_INDEX, &rltMsg);
	}

	return true;
}

int LC_ServerPlayer::DecomposePet(int16_t nIndex)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->DecomposePet(nIndex);

	return m_PetInstanceMgr.Decompose(nIndex);
}

int LC_ServerPlayer::UpgradePetStarLevel(int16_t nIndex, bool bForce)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->UpgradePetStarLevel(nIndex, bForce);

	return m_PetInstanceMgr.UpgradeStarLevel(nIndex, bForce);
}

int LC_ServerPlayer::SyncPet()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->SyncPet();

	m_PetInstanceMgr.SyncAllPetData();
	return true;
}

uint64_t LC_ServerPlayer::GetTotalPetCombatScore()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return 0;

	if (!IsMainController())
		return pOwner->GetTotalPetCombatScore();

	return GetCommanderAttrMgr().GetCommanderCombatScoreByType( CST_PetAdvanced );
}

int32_t LC_ServerPlayer::GetMaxCombatScorePetID(int32_t& petStarLevel)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return 0;

	if (!IsMainController())
		return pOwner->GetMaxCombatScorePetID(petStarLevel);

	PetInstance* pkPetInstance = m_PetInstanceMgr.GetMaxCombatScoreInstance();
	if(NULL == pkPetInstance)
	{
		return 0;
	}

	petStarLevel = pkPetInstance->GetStarLevel();
	return pkPetInstance->GetTemplateId();
}

int32_t LC_ServerPlayer::GetEnabledPetInstanceResId()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->GetEnabledPetInstanceResId();

	return m_PetInstanceMgr.GetEnabledPetInstanceResId();
}

const mem::map<int16_t, PetInstance*>& LC_ServerPlayer::GetPetRawData(int& nResult)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
	{
		nResult = false;
		return gs_no_use;
	}

	if (!IsMainController())
		return pOwner->GetPetRawData(nResult);

	nResult = true;
	return m_PetInstanceMgr.GetRawData();
}

void LC_ServerPlayer::CheckResetYiZhongQinXiDamage()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if (pOwner == NULL)
		{
			return ;
		}
		return pOwner->CheckResetYiZhongQinXiDamage();
	}

	//本次记录的数据是否已经过期
	int32_t playerEndTime = GetYiZhongQinXiEndTime();
	int32_t serverEndTime = UT_ServerHelper::GetYiZhongQinXiGameEndTime();
	if(serverEndTime  != playerEndTime)
	{
		m_CombatRecorderMgr.SetYiZhongQinXiDamage();
		UpdateYiZhongQinXiEndTime(serverEndTime);
	}
}

ResultType LC_ServerPlayer::GetSingleDamageReward(int mapID, int rewardIndex)
{
	CF_BuddyThemeBossType::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BuddyThemeBossType>(mapID);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	mem::map<int32_t, mem::map<int32_t, bool> >::iterator findIt = m_nDamageRankReward.find(mapID);
	if(findIt == m_nDamageRankReward.end())
	{
		return RE_RANKDAMAGE_REWARD_ERROR_1;
	}

	mem::map<int32_t, bool>::iterator it = findIt->second.find(rewardIndex);
	if(it == findIt->second.end())
	{
		return RE_RANKDAMAGE_REWARD_ERROR_1;
	}

	if(it->second == true)
	{
		return RE_RANKDAMAGE_REWARD_ERROR_2;
	}

	mem::vector<StringType> ItemInfo;
	char str = '|';
	LC_Helper::SpliteString2MultiString(pkData->_sReward, ItemInfo, str);

	if(rewardIndex >= ItemInfo.size())
	{
		return RE_RANKDAMAGE_REWARD_ERROR_3;
	}

	UT_SIMDataList kItems;
	ParseFmtString2DataIFs(ItemInfo[rewardIndex], kItems);
	//幻境试炼伤害奖励
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(mapID);
	nParams.push_back(rewardIndex);
	int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN16_OPERATE, OPERATE_LOGTYPE1);
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, kItems, this, SYS_FUNC_TP_RankDamageReward, rewardIndex, mailTitle, mailDesc, false, false,false,nLogCode,nParams);
	if(RE_SUCCESS == res)
	{
		it->second = true;
	}

	return res;
}

void LC_ServerPlayer::SyncSingleDamageReward()
{
	MG_SyncSingleDamageRewardRecord msg;
	for(mem::map<int32_t, mem::map<int32_t, bool> >::iterator it=m_nDamageRankReward.begin(); it!=m_nDamageRankReward.end(); ++it)
	{
		std::map<int32_t, bool> record;
		for(mem::map<int32_t, bool>::iterator kIt=it->second.begin(); kIt!=it->second.end(); ++kIt)
		{
			record.insert(std::make_pair(kIt->first, kIt->second));
		}

		msg.m_nSingleDamageRewardRecord.insert(std::make_pair(it->first, record));
	}
	SendMsgToClient(MGPT_SYNCSINGLEDAMAGEREWARDRECORD, &msg);
}

void LC_ServerPlayer::UpdateRankTypeDamage(int mapID, int64_t damageData)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->UpdateRankTypeDamage(mapID, damageData);
	CF_BuddyThemeBossType::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BuddyThemeBossType>(mapID);
	if(NULL == pkData)
	{
		return;
	}

	mem::vector<int64_t> damageRange;
	LC_Helper::SpliteString2VecInt(TPSTR2STDSTR(pkData->_iDamages), damageRange, ";");

	mem::vector<StringType> ItemInfo;
	char str = '|';
	LC_Helper::SpliteString2MultiString(pkData->_sReward, ItemInfo, str);

	if(damageRange.size() != ItemInfo.size())
	{
		return;
	}

	mem::map<int32_t, mem::map<int32_t, bool> >::iterator findIt = m_nDamageRankReward.find(mapID);
	if(findIt == m_nDamageRankReward.end())
	{
		mem::map<int32_t, bool> record;
		m_nDamageRankReward.insert(std::make_pair(mapID, record));
		findIt = m_nDamageRankReward.find(mapID);
	}

	for(int i=0; i<damageRange.size(); ++i)
	{
		if(damageData >= damageRange[i])
		{
			findIt->second.insert(std::make_pair(i, false));
		}
	}

	SyncSingleDamageReward();
}

void LC_ServerPlayer::UpdateHuanjingEndTime(int storyID, int32_t endTime)
{
	mem::map<int32_t, int32_t>::iterator findIt = m_nHuanJingStoryEndTime.find(storyID);
	if(findIt == m_nHuanJingStoryEndTime.end())
	{
		m_nHuanJingStoryEndTime.insert(std::make_pair(storyID, endTime));
	}
	else
	{
		findIt->second = endTime;
	}
}

void LC_ServerPlayer::EnableCombatRecorder(int32_t nMapType)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->EnableCombatRecorder(nMapType);

	CF_WorldMapList::DataEntry* pkMapDataEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if (NULL == pkMapDataEntry)
		return;

	m_CombatRecorderMgr.SetDataKey(pkMapDataEntry->_iStoryID);
	SetCombatFlag(true);
	m_CombatRecorderMgr.Enable(nMapType);
}

void LC_ServerPlayer::DisableCombatRecorder(int32_t nRankIndex, uint64_t deltaData, uint64_t param, bool syncClient)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->DisableCombatRecorder(nRankIndex, deltaData, param, syncClient);

	FinishCombatRecorder(nRankIndex, deltaData, param, syncClient);

	m_CombatRecorderMgr.Disable();
}

bool LC_ServerPlayer::CheckCombatRecorderEnable()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return false;

	if (!IsMainController())
		return pOwner->CheckCombatRecorderEnable();

	return m_CombatRecorderMgr.CheckEnable();
}

void LC_ServerPlayer::FinishCombatRecorder(int32_t nRankIndex, uint64_t deltaData, uint64_t param, bool syncClient)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->FinishCombatRecorder(nRankIndex, deltaData, param, syncClient);

	m_CombatRecorderMgr.SetRank(nRankIndex);

	if(syncClient)
	{
		SyncSingleCombatRecorderDataToClient(m_CombatRecorderMgr.GetMapType(), m_CombatRecorderMgr.GetDataKey(), nRankIndex, deltaData, param, m_CombatRecorderMgr.GetWriteData());
	}

	m_CombatRecorderMgr.FinishRecord();
}


int32_t LC_ServerPlayer::GetCombatRecorderRank()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return -1;

	if (!IsMainController())
		return pOwner->GetCombatRecorderRank();

	return m_CombatRecorderMgr.GetRank();
}

void LC_ServerPlayer::SetCombatRecorderRank(int32_t nInput)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->SetCombatRecorderRank( nInput );

	m_CombatRecorderMgr.SetRank(nInput);
	return;
}

bool LC_ServerPlayer::AddCombatRecorderValue(uint64_t damage)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return false;

	if (!IsMainController())
		return pOwner->AddCombatRecorderValue(damage);

	bool bResult = m_CombatRecorderMgr.AddValue(damage);
	if ( bResult == false )
		return bResult;

	UT_ServerHelper::GetRealtimeCombatRecorder(pOwner);
	return true;
}

const LC_CombatRecorder& LC_ServerPlayer::GetMaxCombatRecorderData()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return gs_CombatRecorder_Error;

	if (!IsMainController())
		return pOwner->GetMaxCombatRecorderData();

	return m_CombatRecorderMgr.GetMaxData();
}

const LC_CombatRecorder& LC_ServerPlayer::GetWriteCombatRecorderData()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if(NULL == pOwner)
	{
		return gs_CombatRecorder_Error;
	}

	if(!IsMainController())
	{
		return pOwner->GetWriteCombatRecorderData();
	}

	return m_CombatRecorderMgr.GetWriteData();
}

const LC_CombatRecorder& LC_ServerPlayer::GetCombatRecorderData()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return gs_CombatRecorder_Error;

	if (!IsMainController())
		return pOwner->GetCombatRecorderData();

	return m_CombatRecorderMgr.GetReadData();
}

void LC_ServerPlayer::SyncCombatRecorderDataToClient()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->SyncCombatRecorderDataToClient();
}

int32_t LC_ServerPlayer::GetCombatRecorderMapType()
{
	if(!IsMainController())
	{
		return 0;
	}

	return m_CombatRecorderMgr.GetMapType();
}

void LC_ServerPlayer::SyncYiZhongQinXiDamageToClient()
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return;
		return pOwner->SyncYiZhongQinXiDamageToClient();
	}
	CheckResetYiZhongQinXiDamage();

	MG_SC_SingleCombatRecorder data;
	data.m_nType = MT_REANSCRIPTION_RANK;
	data.m_nDamageValue = m_CombatRecorderMgr.GetYiZhongQinXiDamage();
	const unique_id_impl& instance = GetInstance();
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "SyncYiZhongQinXiDamageToClient m_nType:%d, serverid:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, m_nDamageValue:%lld\n", 
		data.m_nType, GetGameServerID(), instance.detail(), instance.catagory(), GetUserID(),GetGuildID(), data.m_nDamageValue);
	SendMsgToClient(MGPT_SYNC_SINGLE_COMBAT_RECORDER, &data);
	return;
}


void LC_ServerPlayer::ReuseHuanJingData()
{
	m_nHuanJingStoryEndTime.clear();
	m_nHuanJingInvaildID.clear();
}

void LC_ServerPlayer::SaveHuanJingData(char_data_define::PBHuanJingData* pkData)
{
	if(NULL == pkData)
	{
		return;
	}

	for(mem::map<int32_t, int32_t>::iterator it=m_nHuanJingStoryEndTime.begin(); it!=m_nHuanJingStoryEndTime.end(); ++it)
	{
		::char_data_define::char_HuanJingStoryEndTime* pkEndTime = pkData->add_huanjingendtime();
		if(NULL != pkEndTime)
		{
			pkEndTime->set_storyid(it->first);
			pkEndTime->set_endtime(it->second);
		}
	}

	for(mem::set<int32_t>::iterator it=m_nHuanJingInvaildID.begin(); it!=m_nHuanJingInvaildID.end(); ++it)
	{
		pkData->add_huanjinginvaildid(*it);
	}	
}

void LC_ServerPlayer::LoadHuanJingData(const char_data_define::PBHuanJingData& data)
{
	for(int i=0; i<data.huanjingendtime_size(); ++i)
	{
		m_nHuanJingStoryEndTime.insert(std::make_pair(data.huanjingendtime(i).storyid(), data.huanjingendtime(i).endtime()));
	}

	for(int i=0; i<data.huanjinginvaildid_size(); ++i)
	{
		m_nHuanJingInvaildID.insert(data.huanjinginvaildid(i));
	}
}

ResultType LC_ServerPlayer::activateSuitCollection(uint32_t suitid)
{
	uint32_t oldSuitStemp = m_CollectEquipRecord.getCurrSuitStemp();
	ResultType ret = m_CollectEquipRecord.activateSuitCollection(suitid);
	if(ret == RE_SUCCESS)
	{
		GetCommanderAttrMgr().RefreshSuitCollectionAttributeMap(this, false);
	}
	return ret;
}
ResultType LC_ServerPlayer::ReceiveRewardBySuitCollection(uint32_t uStepLevel,uint32_t uType)
{
	CF_EquipCommanderSuitCollection::DataEntry* pkCollect = SafeGetCSVFileDataEntryPtr<CF_EquipCommanderSuitCollection>(uStepLevel);
	if(NULL == pkCollect)	
		return RE_ACTIVITY_CONFIG_INVALID;
	if(!m_CollectEquipRecord.isAllowReward(uStepLevel,uType))
		return RE_FAIL;
	Utility::UT_SIMDataList  kItems;
	for (Utility::UT_SIMDataList::const_iterator cit = pkCollect->Reward.begin(); cit != pkCollect->Reward.end(); ++cit)
	{
		if(cit->ParamC() == uType)
		{
			kItems.push_back(*cit);
			break;
		}
	}
	if(RE_SUCCESS != LC_Helper::CanAddItemEx(this,kItems, CIET_NONE))
		return RE_ITEM_REWARD_PACKAGE_FULL;
	PackOperateInfoList kItemOPs;
	//埋点日志
	vector<int> nParams; 
	nParams.clear();
	nParams.push_back(uStepLevel);
	nParams.push_back(uType);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, COLLECTSUIT_OPERATE, OPERATE_LOGTYPE1);
	LC_Helper::BuildAddItemOPs(kItems, kItemOPs, SYS_FUNC_TP_SUIT_COLLECT, uStepLevel);
	LC_Helper::DoItemOPs(this, kItemOPs, SYS_FUNC_TP_SUIT_COLLECT, uStepLevel, true, true, nLogCode, nParams);
	m_CollectEquipRecord.updateRewardReceived(uStepLevel,uType);
	return RE_SUCCESS;
}
void LC_ServerPlayer::NotifyCollectEquipInfo()
{
	MGPT_SYNC_Collect_Player_Equip_Suit notifyMsg;
	m_CollectEquipRecord.packNotifyCollectEquipInfo(notifyMsg);
	SendMsgToClient(MGPT_SYNC_COLLECT_PLAYER_EQUIP_SUIT, &notifyMsg);
}

void LC_ServerPlayer::SetHuanJingInvaild(int32_t id)
{
	//检查参数
	CF_BuddyThemeMain::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BuddyThemeMain>(id);
	if(NULL == pkData)
	{
		return;
	}

	mem::set<int32_t>::iterator findIt = m_nHuanJingInvaildID.find(id);
	if(findIt != m_nHuanJingInvaildID.end())
	{
		return;
	}

	m_nHuanJingInvaildID.insert(id);
	SyncHuanJingInvaildID();
}

void LC_ServerPlayer::ResetHuanJingInvaildID()
{
	m_nHuanJingInvaildID.clear();
	SyncHuanJingInvaildID();
}

void LC_ServerPlayer::SyncHuanJingInvaildID()
{
	MG_Sync_HuanJingFlag msg;
	msg.m_nInvaildID.reserve(m_nHuanJingInvaildID.size());
	for(mem::set<int32_t>::iterator it=m_nHuanJingInvaildID.begin(); it!=m_nHuanJingInvaildID.end(); ++it)
	{
		msg.m_nInvaildID.push_back(*it);
	}
	SendMsgToClient(MGPT_SYNC_HUANJINGFLAG, &msg);
}

CRedPoint& LC_ServerPlayer::GetRedPointAsset()
{
	return m_RedPoint;
}

void LC_ServerPlayer::SyncSingleCombatRecorderDataToClient(int nType, int nDataKey, int nRank, uint64_t deltaData, uint64_t param, const LC_CombatRecorder& recorder)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->SyncSingleCombatRecorderDataToClient(nType,nDataKey,nRank, deltaData, param,recorder);

	MG_SC_SingleCombatRecorder data;
	data.m_nType = nType;
	data.m_nRank = nRank;
	data.m_nDamageValue = deltaData;
	data.m_nKey = nDataKey;
	data.m_nParam = param;
	const unique_id_impl& instance = GetInstance();
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "SyncSingleCombatRecorderDataToClient m_nType:%d, serverid:%d, c_cid:%d, c_citizenship:%d, c_uid:%d, m_nDamageValue:%lld, m_nRank:%d, m_nKey:%d, m_nParam:%d\n", 
		data.m_nType, GetGameServerID(), instance.detail(), instance.catagory(), GetUserID(),GetGuildID(), data.m_nDamageValue, data.m_nRank, data.m_nKey, data.m_nParam);
	SendMsgToClient(MGPT_SYNC_SINGLE_COMBAT_RECORDER, &data);
}

float LC_ServerPlayer::GetFinalDamageRate()
{
	return m_fFinalDamageRate;
}
// 输入：万分比
void LC_ServerPlayer::ResetFinalDamageRate( float fInput )
{
	m_fFinalDamageRate = 1 + fInput * 0.0001f;
}

void LC_ServerPlayer::ResetFinalDamageRateByMap()
{
	int32_t nCurrentMapResId = GetMapResID();
	if ( m_nLastMapResId == nCurrentMapResId )
		return;
	m_nLastMapResId = nCurrentMapResId;
	ResetFinalDamageRate(0.00f);
	CF_WorldMapList::DataEntry* pkMapDataEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(nCurrentMapResId);
	if (NULL == pkMapDataEntry)
		return;

	CF_GameStory::DataEntry* pStory = SafeGetCSVFileDataEntryPtr<CF_GameStory>(pkMapDataEntry->_iStoryID);
	if (!pStory)
		return;


	CF_BossInvade::DataEntry* pData = SafeGetCSVFileDataEntryPtr<CF_BossInvade>(pStory->_iID);
	if ( pData == NULL )
		return;
	BuddyInstance* pInstance = GetAssignedBuddyInstance();
	if ( pInstance == NULL )
		return;
	Utility::UT_SIMDataList kData;
	Utility::ParseFmtString2DataIFs(pData->_sDamageUpBuddy, kData);
	for ( int i = 0; i <kData.size(); i++ )
	{
		UT_SIMDataInfo& singleData = kData[i];
		if (singleData._iID == pInstance->GetTemplateID())
		{
			ResetFinalDamageRate(singleData.ParamA());
			break;
		}
	}
}

void LC_ServerPlayer::TryStopAllBuddyAttack()
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	if (pOwnerPlayer == NULL)
		return;
	if(!IsMainController())
	{
		return pOwnerPlayer->TryStopAllBuddyAttack();
	}

	float fNow = GET_PROCESS_TIME;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		if ( pResultPlayer->GetControlType() == eControlType_Player )
			continue;

		pResultPlayer->TryInterruptSkill( -1, fNow, SKI_FORCE);
		pResultPlayer->TryFinishSkill( -1, fNow,pResultPlayer->GetCurrentLocation().x,pResultPlayer->GetCurrentLocation().y );
		pResultPlayer->SetDefaultTargetID(INVALID_ACTOR_ID);
	}
}

// for interface
int32_t LC_ServerPlayer::GetOtherActivateBuddy(bool bForce)
{
	int32_t nResult = -1;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return nResult;
	if(!IsMainController())
		return pkOwnerPlayer->GetOtherActivateBuddy(bForce);


	LC_ServerPlayer* pCurrentPlayer = GetCurrentActivateBuddy();
	if ( pCurrentPlayer && pCurrentPlayer->GetDead() == false && bForce == false)
		return nResult;

	for ( int i = 0; i < m_nUnlockedActivateBuddyCount; i++ )
	{
		if (i == m_nCurrentBuddyIndex)
			continue;
		LC_ServerPlayer* pPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pPlayer)
			continue;
		if ( pPlayer->GetDead() )
			continue;
		nResult = i;
		break;
	}

	return nResult;
}

int32_t LC_ServerPlayer::SwitchCurrentBuddy()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	int32_t nIndex = m_pOwnerPlayer->GetOtherActivateBuddy();
	if (nIndex == -1)
		return false;

	m_pOwnerPlayer->SetCurrentBuddy(nIndex, true);

	//切换新主控时，如果旧主控骑着坐骑，则同时切换坐骑给新的主控
	if (GetRiderCharType() > 0)
	{
		DismissVehicle();
		SummonVehicle();
	}

	if (GetLoadDataFromDBFlag())
	{
		SetCharInfoDirty();
	}

	return true;
}

int32_t LC_ServerPlayer::SetCurrentBuddy( uint32_t nIndex, bool bForce, bool bInit, int nMode )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	LC_ServerPlayer* pkCurrentPlayer = GetCurrentActivateBuddy();
	if (nMode == eSwitchBuddyMode_NoticeOnly && pkOwnerPlayer)
	{
		MG_SC_SetActivateBuddyReply data;
		data.m_nIndex = m_nCurrentBuddyIndex;
		pkOwnerPlayer->SendMsgToClient(MGPT_SC_SET_ACTIVATE_BUDDY_REPLY, &data);
		return true;
	}
	MG_RefreshPlayerMainInfo broadCastMsg;
	int32_t nResult = false;
	if (nIndex >= MAX_ACTIVE_BUDDY_NUM)
		goto Exit0;

	if (m_nCurrentBuddyIndex == nIndex && bForce == false)
		goto Exit0;

	LC_ServerPlayer* pPlayer = m_ppActivateBuddyDataPtr[nIndex];
	if (pPlayer == NULL)
		goto Exit0;

	// CD Checking
	if (!bForce)
	{
		bool bCDCheck = CheckSwitchBuddyCDTime( m_nCurrentBuddyIndex, GET_PROCESS_TIME );
		if (bCDCheck == false)
			goto Exit0;
		SetLastSwitchBuddyTime(m_nCurrentBuddyIndex, GET_PROCESS_TIME);
	}

	if (m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex])
	{
		m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->SetControlType( eControlType_Buddy );
	}

	bool bOrigCombatFlag = false;
	if ( pkCurrentPlayer )
		pkCurrentPlayer->GetLogicCombatFlag();
	//LC_ActorHatredList* pOrigHatredList = pkCurrentPlayer->GetHatredList();
	m_nCurrentBuddyIndex = nIndex;

	if (GetLoadDataFromDBFlag())
	{
		SetCharInfoDirty();
	}

	m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->SetControlType( eControlType_Player );

	//
	if (GetAIControl())
		m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->RefreshCurrentOPIndex(m_nCurrentBuddyIndex);
	if (!bInit)
		m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->GetAssignedBuddyInstance()->SyncSkillAsset();
	m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->ResetAllBuddyAIParam();
	m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->SetServerViewState(LC_ServerPlayer::SERVER_STATE_INWORLD);
	//切换主控的时候，广播MG_RefreshPlayerMainInfo，因为别的玩家要看到显示者已经被更换
	pkCurrentPlayer = GetCurrentActivateBuddy();
	if(NULL != pkCurrentPlayer && NULL != pkOwnerPlayer)
	{
		pkCurrentPlayer->SetLogicCombatFlag(  bOrigCombatFlag );
		broadCastMsg.m_lCurrentPlayerID = pkCurrentPlayer->GetID();

		mem::vector<int32_t> vecBuddyIDs;
		pkOwnerPlayer->GetActivateBuddyIDs(vecBuddyIDs);
		for(int i=0;i<vecBuddyIDs.size();++i)
		{
			LC_ServerPlayer* pkBuddy = pkOwnerPlayer->GetActivateBuddyByID(vecBuddyIDs[i]);
			if(NULL != pkBuddy)
			{
				broadCastMsg.m_lActivePlayerIDs.push_back(pkBuddy->GetID());
			}
		}

		broadCastMsg.m_GuildName = pkOwnerPlayer->GetGuildName().c_str();
		LC_TitleAsset* pkTitleAsset = GetTitleAsset();

		int titleType = pkTitleAsset->GetCurrentTitleType();
		if(titleType == TNT_SYSTEM_TITLE)
		{
			broadCastMsg.m_TitleID = pkTitleAsset->GetCurrentTitle();
		}
		else
		{
			broadCastMsg.m_TitleID = 0;
		}

		LC_VIPAsset& rVipAsset = pkOwnerPlayer->GetVIPAsset();
		broadCastMsg.m_VipLevel = rVipAsset.GetVIPLevel();
		broadCastMsg.m_iUiFlag = rVipAsset.GetUiFlag();

		pkOwnerPlayer->BroadCastToArea(MGPT_CONTROLLER_PLAYER_INFO, &broadCastMsg);
	}

	//切换主控后，同步buddy的血量
	SyncActiviteBuddyProperty();
	m_ppActivateBuddyDataPtr[m_nCurrentBuddyIndex]->SyncSkillStatesToClient(SSC_ALL);

	//更新队伍信息中的主控皮肤id
	UpdateGroupTransformID();
	nResult = true;

	if (pkOwnerPlayer && pkOwnerPlayer->GetSoloDulePlay())
	{
		SetAIControl(true);
		RefreshSMController();
	}

Exit0:
	if ( nMode != eSwitchBuddyMode_DataOnly && pkOwnerPlayer )
	{
		MG_SC_SetActivateBuddyReply data;
		data.m_nIndex = m_nCurrentBuddyIndex;
		pkOwnerPlayer->SendMsgToClient(MGPT_SC_SET_ACTIVATE_BUDDY_REPLY, &data);
	}
	return nResult;
}

bool LC_ServerPlayer::ReliveSelf(int nReliveType, bool bAllReliveMode, int32_t playerIndex)
{
	/*if(nReliveType == RELIVE_LOGIN)
	{
	return false;
	}*/
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveSelf pOwner == NULL cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,nReliveType:%d,bAllReliveMode:%d,playerIndex:%d ",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAllReliveMode,playerIndex);
		return false;
	}

	const unique_id_impl& playerInstance = pOwner->GetInstance();
	int lTargetMapResID = pOwner->GetMapResID();
	int owerUserId = pOwner->GetUserID();
	int citizenship = pOwner->GetCitizenship();
	int Id = pOwner->GetID();
	int serverID = GetGameServerID() ;
	if (!GetDead())
	{
		GfxWriteLog(LOG_TAG_INFO, LOG_SWITCH_INFO, "ReliveSelf not Dead cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,nReliveType:%d,bAllReliveMode:%d,playerIndex:%d ",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex);
		return false;
	}
	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(lTargetMapResID);
	if (NULL == pkMapEntry)
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveSelf NULL == pkMapEntry cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,nReliveType:%d,bAllReliveMode:%d,playerIndex:%d,lTargetMapResID:%d ",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex,lTargetMapResID);
		return false;
	}

	//检查消耗品
	if (nReliveType == RELIVE_NOW && pkMapEntry->_iRespawnItemNum < 0 && !pOwner->GetOwnerReliveFlag_Recover() )
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveSelf NULL == pkMapEntry cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,nReliveType:%d,bAllReliveMode:%d,playerIndex:%d,lTargetMapResID:%d,_iRespawnItemNum:%d,OwnerReliveFlag_Recover:%d ",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex,lTargetMapResID,pkMapEntry->_iRespawnItemNum,!pOwner->GetOwnerReliveFlag_Recover());
		return false;
	}

	LC_ServerWorldManager* pkServerWorldManager = SERVER_GET_WORLD_MANAGER();
	if ( nReliveType == RELIVE_NOW )//
	{
		Utility::UT_Vec3Int respawn_pos = GetCurrentLocation();
		LC_ServerPlayer* pCurPlayer = GetCurrentActivateBuddy();
		if ( pCurPlayer && pCurPlayer->GetID() != GetID() && !pCurPlayer->GetDead() )
		{
			pCurPlayer->CalcAdvanceFollowLocation( this, GetGlobalSetting.nStopFollowDistance,  respawn_pos );
			SetCurrentLocation(respawn_pos);
			SetTargetLocation(respawn_pos);
			SyncLocationInfo();
			SetLastMoveCheckLocation(respawn_pos);
		}
		pkServerWorldManager->RequestChangePlayerLocation(this, LMIOT_CURRENT_RESPAWN,
			GetMapLogicID(),
			lTargetMapResID,
			respawn_pos);
		GfxWriteLog( LOG_TAG_INFO, LOG_SWITCH_INFO, "ReliveSelf success 1 cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,nReliveType:%d,bAllReliveMode:%d,playerIndex:%d,lTargetMapResID:%d",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex,lTargetMapResID);
		return true;
	}

	//代码走到这儿，一定是通过指挥官普通复活，复活每一个出战buddy

	UT_Vec3Int	kTargetLocation;
	if(IsMainController())
	{
		if (false == UT_ServerHelper::GetRandomLocationXYZ(kTargetLocation,lTargetMapResID,citizenship))
		{
			GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveSelf GetRandomLocationXYZ error cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAllReliveMode:%d,playerIndex:%d (%d,%d,%d) ",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex,kTargetLocation.x,kTargetLocation.y,kTargetLocation.z);
		}
	}
	else
	{
		kTargetLocation = pOwner->GetCurrentLocation();
	}
	//if(playerIndex>=0 && playerIndex<MAX_ACTIVE_BUDDY_NUM)
	//{
	//	//int nOffsetX[MAX_ACTIVE_BUDDY_NUM] = {0, 1, 0};
	//	//int nOffsetY[MAX_ACTIVE_BUDDY_NUM] = {1, 0, -1};
	//	ModifyOffsetLocationByIndex(playerIndex, kTargetLocation);
	//	//kTargetLocation.x += GetGlobalSetting.nInitPosOffset * nOffsetX[playerIndex];
	//	//kTargetLocation.y += GetGlobalSetting.nInitPosOffset * nOffsetY[playerIndex];
	//}
	SetFollowLocation(kTargetLocation, false, 0);
	SetTargetLocation(kTargetLocation);

	pkServerWorldManager->RequestChangePlayerLocation(this,
		LMIOT_SAFE_RESPAWN,
		GetMapLogicID(),
		lTargetMapResID,
		kTargetLocation);

	if (!bAllReliveMode)
		SwitchCurrentBuddy();

	GfxWriteLog( LOG_TAG_INFO, LOG_SWITCH_INFO, "ReliveSelf success 2 cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAllReliveMode:%d,playerIndex:%d,lTargetMapResID:%d",playerInstance.detail(),playerInstance.catagory(),serverID,owerUserId,Id,nReliveType,bAllReliveMode,playerIndex,lTargetMapResID);
	return true;
}

int32_t LC_ServerPlayer::ReliveAllBuddy(int nReliveType, bool bAuto, bool bForce)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy IsMainController cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d ",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID());
			return false;
		}
		return pkOwnerPlayer->ReliveAllBuddy(nReliveType,bAuto,bForce);
	}

	int32_t cdTime = 0;
	if(!CheckCanRespaw(cdTime) && !bForce)
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_SWAP_CONTROLLER_COOLDOWN,0,cdTime);	
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy CheckCanRespaw bForce  cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,cdTime:%d ",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),cdTime);
		return false;
	}

	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if (NULL == pkMapEntry)
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy NULL == pkMapEntry cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d ",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID());
		return false;
	}
	if (!bForce)
	{
		if(nReliveType == RELIVE_NOW)//
		{
			//不允许原地复活
			if ( pkMapEntry->_iRespawnItemNum == -1 || pkMapEntry->_iRespawnItemNum == -2)
			{
				Send_SC_BuddyReply(0,RE_BUDDY_ERROR_SWAP_CURRENT_LOCATION,0,0);	
				GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy pkMapEntry->_iRespawnItemNum == -1 || -2 cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum);
				return false;
			}
		}
		else if( pkMapEntry->_iRespawnItemNum == -1)
		{
			//不允许普通复活
			Send_SC_BuddyReply(0,RE_BUDDY_ERROR_SWAP_SAFE_LOCATION,0,0);	
			GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy pkMapEntry->_iRespawnItemNum == -1 cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum);
			return false;
		}
	}
	//检查消耗品
	if (pkMapEntry->_iRespawnItemNum > 0 )
	{
		if (nReliveType == RELIVE_NOW && GetLevel() >= MIN_NOT_NEWBIE_LEVEL)
		{
			//检查消耗品
			int itemID = GetGlobalSetting.nPlayerReliveId;
			if (GetPackAsset()->GetItemCountInPack(PACK_TYPE_BASIC, itemID) < pkMapEntry->_iRespawnItemNum)
			{
				//是否直接消耗钻石复活
				if(bAuto)
				{
					CF_ItemList::DataEntry* pkItemData = CF_ItemList::GetSingletonPtr()->GetEntryPtr(itemID);
					if(NULL == pkItemData)
					{
						GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy NULL == pkItemData cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d,configitemID:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum,itemID);
						return false;
					}
					CF_ShopList::DataEntry* pkShopData = CF_ShopList::GetSingletonPtr()->GetEntryPtr( pkItemData->_ShopID);
					if(NULL == pkShopData)
					{
						GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy NULL == pkShopData cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d,configitemID:%d,_ShopID:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum,itemID,pkItemData->_ShopID);
						return false;
					}
					LC_ServerPlayer* pOwner = GetOwnerPlayer();
					if (pOwner == NULL)
					{
						GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy NULL == pOwner cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d,configitemID:%d,_ShopID:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum,itemID,pkItemData->_ShopID);
						return false;
					}

					bool bRecoverMode = pOwner->GetOwnerReliveFlag_Recover();
					int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, RELIVE_OPERATE, OPERATE_LOGTYPE1);
					if(!bRecoverMode && RE_SUCCESS != LC_Helper::PayCashMap(this, pkShopData->_ActualPriceList, SYS_FUNC_TP_RELIVEAllBUDDY_CONSUME_UNBIND_YUANBAO, pkShopData->_iItemID, 1, false, nLogCode))
					{
						//钻石不足
						Send_SC_BuddyReply(0,RE_UNBIND_YUANBAO_NOT_ENOUGH,0,0);
						GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy not enough money cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d,configitemID:%d,_ShopID:%d",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum,itemID,pkItemData->_ShopID);
						return false;
					}
				}
				else
				{
					Send_SC_BuddyReply(0,RE_BUDDY_ERROR_RESPAWN_LESS_ITEM,0,0);
					GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "ReliveAllBuddy RE_BUDDY_ERROR_RESPAWN_LESS_ITEM cid:%d,citizenship:%d,serverid:%d,uid:%d,id:%d,bLocal:%d,bAuto:%d,bForce:%d,resMap:%d,_iRespawnItemNum:%d ",GetInstance().detail(),GetInstance().catagory(),GetGameServerID(),GetUserID(),GetID(),nReliveType,bAuto,bForce,GetMapResID(),pkMapEntry->_iRespawnItemNum);
					return false;
				}
			}
		}
	}

	//m_ppActivateBuddyDataPtr[0]一定是主控
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->m_bBuddyRelive = false;
		pResultPlayer->ReliveSelf(nReliveType, true, i);
		pResultPlayer->m_bBuddyRelive = true;
	}

	SetForceLocalRelive( false );

	if (!CheckOwnerDead() && nReliveType == RELIVE_NOW && GetLevel() >= MIN_NOT_NEWBIE_LEVEL && !bAuto)
		DeleteItem(GetGlobalSetting.nPlayerReliveId, pkMapEntry->_iRespawnItemNum);

	UpdateControllerPlayerRespawn();

	SetAttackFlag(true);
	return true;
}
void LC_ServerPlayer::Send_SC_BuddyReply(int buddyTid,uint32_t errorCode,int8_t nMode,int32_t cdTime)
{
	MG_SC_BuddyReply rltMsg;
	rltMsg.m_nBuddyTemplateID = buddyTid;
	rltMsg.m_nErrorCode = errorCode;
	rltMsg.m_nMode = nMode;
	rltMsg.m_nSwapCDTime = cdTime; //m_nSwapCDTime秒后可以复活
	SendMsgToClient(MGPT_SC_BUDDY_REPLY, &rltMsg);		
}

int32_t LC_ServerPlayer::ReliveBuddy( uint32_t nIndex, bool bFreeMode )
{
	if (nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM)
		return 0;
	LC_ServerPlayer* pPlayer = GetActivateBuddyByIndex(nIndex);
	IF_A_NA_PLAYER(pPlayer) 
		return 0;
	if (bFreeMode)
		pPlayer->m_bBuddyRelive = false;
	pPlayer->ReliveSelf(RELIVE_NOW, true);
	if (bFreeMode)
		pPlayer->m_bBuddyRelive = true;
	ResetBuddyAutoRespawnTimerByIndex(nIndex);
	return 1;
}

bool LC_ServerPlayer::OnInitBuddyTemplateId()
{
	if (m_ppActivateBuddyTemplateId.size() == 0)
		return false;

	m_ppActivateBuddyTemplateId[0] = GetBornCharType();
	return true;
}

int32_t LC_ServerPlayer::GetEntryServerStartTime()
{
	return GetGameServerApp()->GetServerManager()->GetEntryServerStartTime();
}

void LC_ServerPlayer::NoticeNewAchievementToClient(const mem::set<int32_t>& idSet)
{
	if(idSet.empty())
	{
		return;
	}

	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
		return pOwner->NoticeNewAchievementToClient(idSet);

	MG_NoticeNewAchievement msg;
	for(mem::set<int32_t>::const_iterator it=idSet.begin(); it!=idSet.end(); ++it)
	{
		msg.m_nAchievementSet.push_back(*it);
	}	
	SendMsgToClient(MGPT_NOTICENEWACHIEVEMENT, &msg);
}

void LC_ServerPlayer::PreLeaveForRelive(CSVFile::CF_WorldMapList::DataEntry* pData)
{
	// simulate the logic run on login_server
	// private usage function. check nothing internal.
	if ( pData->_bLeaveReviveBuddy  && !pData->_iShowRaidStage )
	{
		// relive.
		ReliveAllBuddy( RELIVE_SAFE, false, true );
	}
	return;
}

void LC_ServerPlayer::PostEnterForRelive(CSVFile::CF_WorldMapList::DataEntry* pData)
{
	// simulate the logic run on login_server
	// private usage function. check nothing internal.
	if ( pData->_bEnterReviveBuddy )
	{
		// relive.
		ReliveAllBuddy( RELIVE_LOGIN, false, true );
	}
	return;
}

int32_t LC_ServerPlayer::PreLeaveMap( int32_t nMapResId, int32_t nDstMapResId )
{
	if (!IsMainController())
		return false;

	//物资护送奖励
	SendEscortRewardToMail();

	m_fLastPVPTime = 0.00f;

	CF_WorldMapList::DataEntry* pSrcData = CF_WorldMapList::GetSingletonPtr()->GetEntryPtr(nMapResId);
	CF_WorldMapList::DataEntry* pDstData = CF_WorldMapList::GetSingletonPtr()->GetEntryPtr(nDstMapResId);
	CF_GameStory::DataEntry* pSrcStory = NULL;
	CF_GameStory::DataEntry* pDstStory = NULL;
	if ( pSrcData )
	{
		pSrcStory = SafeGetCSVFileDataEntryPtr<CF_GameStory>(pSrcData->_iStoryID);
		PreLeaveForRelive(pSrcData);
	}
	if ( pSrcData && pSrcData->_iMapLogicType == MT_WATCHTOWER && pSrcData->_iID != GetGlobalSetting.BestGuildMapID )
	{
		SetCurrentBuddy(0, true);
		return true;
	}
	if (pSrcData == NULL )
		return false;
	if (pDstData == NULL  )
	{
		if (pSrcStory && pSrcStory->_RecoverBuddySchemeOnLeave )
		{
			SwitchBuddyScheme(INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Offensive, false, true);
		}
		return false;
	}
	pDstStory = SafeGetCSVFileDataEntryPtr<CF_GameStory>(pDstData->_iStoryID);
	if(NULL == pSrcStory || (nDstMapResId<=0 && pDstStory == NULL))
		return false;

	if ( nDstMapResId && pDstStory && pSrcStory->_ielementdamagetype == pDstStory->_ielementdamagetype )
		return true;

	if (pSrcStory->_RecoverBuddySchemeOnLeave)
	{
		SwitchBuddyScheme(INIT_MAP_ID, INIT_SCHEME_GROUPID, SchemeType_Offensive, false, true);
	}

	return true;
}

int LC_ServerPlayer::GetCitizenship()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return LC_PlayerBase::GetCitizenship();

	if (!IsMainController())
		return pOwner->GetCitizenship();

	return LC_PlayerBase::GetCitizenship();
}

int32_t LC_ServerPlayer::PostEnterMap(uint32_t schemeType, uint32_t groupID)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return false;

	CF_WorldMapList::DataEntry* pSrcData = CF_WorldMapList::GetSingletonPtr()->GetEntryPtr(GetMapResID());
	if ( pSrcData == NULL )
		return false;

	_TryRecoverDeadState();
	if (m_bAutoSafeRelive && m_bSwitchLogicMap)
	{
		//ReliveAllBuddy();
		m_bAutoSafeRelive = false;
	}
	PostEnterForRelive(pSrcData);
	if (m_bInternalSwitchScene)
	{
		if (m_bSwitchLogicMap)
		{
			ReliveAllBuddyBeforeEnterMap(true);
			m_bInternalSwitchScene = false;
			m_bSwitchLogicMap = false;
		}
		for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
		{
			LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
			IF_A_NA_PLAYER(pResultPlayer) 
				continue;
			pResultPlayer->SyncDead(true);
		}
	}

	AutoSwitchBuddyScheme(schemeType,groupID);

	if (IsMainController())
	{
		m_fBuddyRespawnTickCount = GET_PROCESS_TIME;
		m_fLastPVPTime = 0.00f;
		if (!GetAIControl())
			SetDenyMove(false);
	}

	LC_ServerPlayerEnterLeaveManager* enterLeaveManager = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
	if (enterLeaveManager)
		enterLeaveManager->DelSwitchMapLinePlayer( GetUserID() );

	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->ForceFinishCurrentSkill();
	}

	return true;
}

void LC_ServerPlayer::AutoSwitchBuddyScheme(uint32_t schemeType, uint32_t groupID)
{
	LC_ServerMap* pkMap = (LC_ServerMap*)GetMap();
	if (pkMap == NULL)
	{
		return;
	}

	SwitchBuddyScheme(GetMapResID(), groupID, schemeType, false, true);
}
// 2.刷新所有英雄系统的属性
void LC_ServerPlayer::RefreshAllHeroAllSysAttrMap()
{
	for(mem::map<int32_t, BuddyInstance*>::iterator it= m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
			continue;		
		pkBuddy->GetBuddyAttrMgr().RefreshAllAttrMap(this,pkBuddy);
	}
}
//4.刷新英雄最后的出战属性
void LC_ServerPlayer::RefreshAllHeroAllNewFinalAttrMap(bool login)
{
	for(mem::map<int32_t, BuddyInstance*>::iterator it= m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
			continue;
		pkBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this, pkBuddy, login);
	}

	//指挥官战斗力更新 需要刷新的东西
	UpdateControllerCombatScoreAndOtherOpen();
}

//4.刷新英雄最后的出战属性
void LC_ServerPlayer::RefreshAllHeroAllNewFinalAttrMapByTypeValue(int iAttributeType,attr_value_type iValueFunc,bool add)
{
	for(mem::map<int32_t, BuddyInstance*>::iterator it= m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
			continue;
		if(add)
			pkBuddy->GetBuddyAttrMgr().GetHeroAllAttributeMap()->AddAttributeValueFunc(iAttributeType,iValueFunc);
		else
			pkBuddy->GetBuddyAttrMgr().GetHeroAllAttributeMap()->RemoveAttributeValueFunc(iAttributeType,iValueFunc);
		pkBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this, pkBuddy, false);
	}

}

// 刷新灵魂上所有英雄提供出去的灵魂链属性
void LC_ServerPlayer::RefreshChainAllBuddyToGiveCoreAttr()
{
	int32_t nSize = m_BuddyChain.GetCount();
	for ( int i = 0; i<nSize; i++ )
	{
		int32_t myBuddyId = m_BuddyChain.Get(i);
		if(myBuddyId <= INVALID_ACTOR_ID)
			continue;
		BuddyInstance* pInstance = GetBuddyInstanceByID(myBuddyId);
		if ( pInstance == NULL )
			continue;
		pInstance->GetBuddyAttrMgr().RefreshHeroGiveToOtherCoreAttrMap(this);	
	}
}
// 刷新灵魂链 上所有英雄获得灵魂连锁属性
void LC_ServerPlayer::RefreshChainBuddyCoreAttr(bool login, int32_t reasonType)
{
	m_showCoreArrMap.Clear();
	bool bFirst = true;
	int32_t nSize = m_BuddyChain.GetCount();
	for ( int i = 0; i<nSize; i++ )
	{
		int32_t myBuddyId = m_BuddyChain.Get(i);
		if(myBuddyId <= INVALID_ACTOR_ID)
			continue;
		BuddyInstance* pInstance = GetBuddyInstanceByID(myBuddyId);
		if ( pInstance == NULL )
			continue;
		LC_ActorAttributeMap OtherCoreAttributeMap; 
		OtherCoreAttributeMap.Clear();
		LC_ActorAttributeMap AllCoreAttributeMap; 
		AllCoreAttributeMap.Clear();
		for ( int k = 0;k<nSize; k++ )
		{
			int32_t nAddBuddyId = m_BuddyChain.Get(k);
			if(nAddBuddyId <= INVALID_ACTOR_ID)
				continue;
			BuddyInstance* pInstanceAdd = GetBuddyInstanceByID(nAddBuddyId);
			if ( pInstanceAdd == NULL )
				continue;
			AllCoreAttributeMap.AddAttributeMap(pInstanceAdd->GetBuddyGiveCore(),true);
			if(myBuddyId != nAddBuddyId)
				OtherCoreAttributeMap.AddAttributeMap(pInstanceAdd->GetBuddyGiveCore(),true);
		}
		pInstance->SetChainAllAttrMap(this,&OtherCoreAttributeMap, login, reasonType);
		if(bFirst)
		{
			m_showCoreArrMap.CopyFrom(&AllCoreAttributeMap);
			bFirst = false;
		}
	}
	m_showCoreArrMap.RecomputeAll();
	m_showCoreArrMap.PrintAttrMap("m_showCoreArrMap");
	GetCommanderAttrMgr().SetCommanderCombatScoreByType(this, CST_Core,LC_Helper::CalcAttributeMapCombatScore(&m_showCoreArrMap));
	SyncCommanderAttributeToClient(SPAT_CoreAllAttr,m_showCoreArrMap, login, GetCommanderAttrMgr().GetCommanderCombatScoreByType(CST_Core), reasonType);
	SyncCommanderAttributeToClient(SPAT_CommanderAllAttr,*(GetCommanderAttrMgr().GetCommanderAllAttributeMap()), login, GetControllerCombatScore(), reasonType);
}

void LC_ServerPlayer::RefreshChainBuddyCoreAttrByOnChain(int nBuddyId, bool login, int32_t reasonType)
{
	if ( !m_BuddyChain.Check( nBuddyId ) )
		return;
	RefreshChainBuddyCoreAttr(login, reasonType);
}

int32_t LC_ServerPlayer::BuddyChain_Add( int16_t nIndex, int32_t nBuddyId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return RE_FAIL;

	if (!IsMainController())
		return pOwner->BuddyChain_Add( nIndex, nBuddyId);

	ResultType eResult = RE_SUCCESS;
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if ( pBuddy == NULL )
	{
		eResult = RE_BUDDY_CHAIN_ERROR_INVALID_BUDDY;
		goto Exit0;
	}
	eResult = m_BuddyChain.Add( nIndex, nBuddyId );
	if ( eResult == RE_SUCCESS )
	{
		pBuddy->GetBuddyAttrMgr().RefreshHeroGiveToOtherCoreAttrMap(this);
		//刷新灵魂链上玩家获得灵魂链属性
		RefreshChainBuddyCoreAttr(false, SPART_Core_1);
		pBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this,pBuddy, false);
		MG_SC_AddBuddyChainSync sync;
		sync.m_nBuddyID = nBuddyId;
		sync.m_nIndex = nIndex;
		SendMsgToClient(MGPT_SC_ADD_BUDDY_CHAIN_SYNC, &sync );
		OnBuddyChainEvent_Add( nBuddyId);
	}
Exit0:
	MG_SC_BuddyChainOperationResult result;
	result.m_nIndex = nIndex;
	result.m_nError = eResult;
	SendMsgToClient(MGPT_SC_BUDDY_CHAIN_OPERATION_RESULT, &result );

	return eResult;
}

int32_t LC_ServerPlayer::BuddyChain_Del( int16_t nIndex)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return RE_FAIL;

	if (!IsMainController())
		return pOwner->BuddyChain_Del( nIndex);

	int32_t nOrigBuddyId = 0;
	ResultType eResult = m_BuddyChain.Del( nIndex, nOrigBuddyId );
	if ( eResult == RE_SUCCESS )
	{
		MG_SC_DelBuddyChainSync sync;
		sync.m_nIndex = nIndex;
		SendMsgToClient(MGPT_SC_DEL_BUDDY_CHAIN_SYNC, &sync );
		OnBuddyChainEvent_Del(nOrigBuddyId);
		BuddyInstance* pkBuddy = GetBuddyInstanceByID(nOrigBuddyId);
		if(pkBuddy)
		{
			pkBuddy->GetBuddyAttrMgr().ClearChainAllAttrMap(this,pkBuddy);
			RefreshChainBuddyCoreAttr(false);
			pkBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this,pkBuddy, false);
		}
	}

	MG_SC_BuddyChainOperationResult result;
	result.m_nIndex = nIndex;
	result.m_nError = eResult;
	SendMsgToClient(MGPT_SC_BUDDY_CHAIN_OPERATION_RESULT, &result );

	return eResult;
}

int32_t LC_ServerPlayer::BuddyChain_Switch( int16_t nIndex, int32_t nBuddyId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return RE_FAIL;

	if (!IsMainController())
		return pOwner->BuddyChain_Switch( nIndex, nBuddyId);

	ResultType eResult = RE_SUCCESS;
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if ( pBuddy == NULL )
	{
		eResult = RE_BUDDY_CHAIN_ERROR_INVALID_BUDDY;
		goto Exit0;
	}
	int32_t nOrigBuddyId = 0;
	eResult = m_BuddyChain.Switch( nIndex, nBuddyId, nOrigBuddyId );
	if ( eResult == RE_SUCCESS )
	{
		MG_SC_SwitchBuddyChainSync sync;
		sync.m_nBuddyID = nBuddyId;
		sync.m_nIndex = nIndex;
		SendMsgToClient(MGPT_SC_SWITCH_BUDDY_CHAIN_SYNC, &sync );
		OnBuddyChainEvent_Switch( nBuddyId, nOrigBuddyId);
	}

Exit0:
	MG_SC_BuddyChainOperationResult result;
	result.m_nIndex = nIndex;
	result.m_nError = eResult;
	SendMsgToClient(MGPT_SC_BUDDY_CHAIN_OPERATION_RESULT, &result );

	return eResult;
}

int32_t LC_ServerPlayer::OnBuddyChainEvent_Add( int32_t nBuddyId, bool bLoad  )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
		return pkOwnerPlayer->OnBuddyChainEvent_Add(nBuddyId,bLoad  );
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if ( pBuddy == NULL )
		return RE_BUDDY_CHAIN_ERROR_INVALID_BUDDY;
	return RE_SUCCESS;
}

int32_t LC_ServerPlayer::OnBuddyChainEvent_Del( int32_t nBuddyId, bool bLoad )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
		return pkOwnerPlayer->OnBuddyChainEvent_Del(nBuddyId,nBuddyId );
	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if ( pBuddy == NULL )
		return RE_BUDDY_CHAIN_ERROR_INVALID_BUDDY;
	return RE_SUCCESS;
}

int32_t LC_ServerPlayer::OnBuddyChainEvent_Switch( int32_t nBuddyId, int32_t nOrigBuddyId )
{
	if ( !IsMainController() )
		return RE_FAIL;

	return RE_SUCCESS;
}



int32_t LC_ServerPlayer::OnBuddyChainEvent_Reload(int32_t nBuddyId)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
		return pkOwnerPlayer->OnBuddyChainEvent_Reload(nBuddyId);

	OnBuddyChainEvent_Del( nBuddyId, true );
	OnBuddyChainEvent_Add( nBuddyId, true );
	return RE_SUCCESS;
}

bool LC_ServerPlayer::BuddyChain_SetIndexImpl( int16_t nIndex )
{
	bool bResult = m_BuddyChain.SetIndex(nIndex);
	if ( bResult == false )
		return false;
	MG_SC_BuddyChainCountSync sync;
	sync.m_nCount = nIndex;
	SendMsgToClient(MGPT_SC_BUDDY_CHAIN_COUNT_SYNC, &sync);

	return true;
}

bool LC_ServerPlayer::BuddyChain_SetIndex( int16_t nIndex )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->BuddyChain_SetIndex(nIndex);

	return BuddyChain_SetIndexImpl(nIndex);
}

void LC_ServerPlayer::BuddyChain_CalcCount( int32_t nTaskId )
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->BuddyChain_CalcCount(nTaskId);


	BuddyChain_RefreshIndexImpl( 0, nTaskId );
}

int16_t LC_ServerPlayer::BuddyChain_RefreshIndexImpl( int16_t nBeginCount, int32_t nTaskId )
{
	CF_SoulConnect::DataEntryMapExternIterator kIter = CF_SoulConnect::GetSingletonPtr()->GetIterator();
	int32_t nLevel = GetLevel();
	int32_t nTitleLevel = m_nCommanderTitle;
	int16_t nResult = 0;
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		const CF_SoulConnect::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		int nIndex = pkEntry->_id - 1;

		if ( pkEntry->_iCommanderTitleLevel != 0 && pkEntry->_iCommanderTitleLevel > nTitleLevel )
			continue;

		if ( pkEntry->_iLevel != 0 && pkEntry->_iLevel > nLevel )
			continue;

		if ( pkEntry->_iTaskID != INVALID_TASK_ID )
		{
			if ( m_pkTaskMap->GetTaskState(pkEntry->_iTaskID) != NT_FINISH )
				continue;
		}

		bool bRet = m_BuddyChain.SetIndex(nIndex);
		if ( bRet )
		{
			MG_SC_BuddyChainCountSync sync;
			sync.m_nCount = nIndex;
			SendMsgToClient(MGPT_SC_BUDDY_CHAIN_COUNT_SYNC, &sync);
		}
		nResult++;
	}
	return nResult;
}

void LC_ServerPlayer::BuddyChain_SyncToClient()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
		return pOwner->BuddyChain_SyncToClient();


	Protocol::MG_SC_BuddyChainSync sync;
	m_BuddyChain.SetProtocolData(sync);

	SendMsgToClient(MGPT_SC_BUDDY_CHAIN_SYNC, &sync);

	return;
}

bool LC_ServerPlayer::GetAutoSafeRelive()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->GetAutoSafeRelive();

	return m_bAutoSafeRelive;
}

bool LC_ServerPlayer::GetInternalSwitchScene()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->GetInternalSwitchScene();

	return m_bInternalSwitchScene;
}

void LC_ServerPlayer::GetMainControllerAllAttributeMap(LC_ActorAttributeMap* map)
{
	LC_ActorAttributeMap* pkControllerBuffAttrMap = GetMainControllerBuffAttrbuteMap();
	if( NULL==pkControllerBuffAttrMap || NULL==map)
		return;
	map->AddAttributeMap(pkControllerBuffAttrMap, true);
	map->RecomputeAll();
}

void	LC_ServerPlayer::SyncControllerSkillStatesToClient(int iStateCategory)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer)
		return;
	if (!IsMainController())
		return pOwnerPlayer->SyncControllerSkillStatesToClient(iStateCategory);
	for (int i = 0; i <MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = pOwnerPlayer->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->SyncSkillStatesToClient(iStateCategory);
	}
}

bool LC_ServerPlayer::LearnSkillToController( int nSkillId, int& nSlotIndex, bool send, int32_t runeSystemType, int32_t runeSystemParam, GameLogic::LC_SkillIDSet* pkReplacedSkills )
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->LearnSkillToController(nSkillId, nSlotIndex, send, runeSystemType, runeSystemParam, pkReplacedSkills);
	}

	bool isUpgrade = true;
	//没找到，说明已经此次是学习，不是升级
	LC_SkillAssetEntry* pkOldSkillEntry = m_kControllerSkillAsset.FindLearnedSkill(nSkillId);
	if(NULL == pkOldSkillEntry)
	{
		isUpgrade = false;
	}

	if (IS_SKILL_TYPE(nSkillId))
	{
		LC_SkillIDSet kSkillIDSet;
		ResultType result = m_kControllerSkillAsset.AddSkillToAsset(nSkillId, nSlotIndex, &kSkillIDSet);
		if(result == RE_SKILL_IS_LEARNED)
		{
			return false;
		}

		if(isUpgrade)
		{
			int oldSkillID = pkOldSkillEntry->GetTypeID();
			if(oldSkillID != -1)
			{
				//减掉原来技能的属性修正
				ModifyControllerAttributeBySkill(pkOldSkillEntry, oldSkillID, false, runeSystemType, runeSystemParam);
			}
		}

		LC_SkillAssetEntry* pkNewSkillEntry = m_kControllerSkillAsset.FindLearnedSkill(nSkillId);
		if (result==RE_SUCCESS && NULL!=pkNewSkillEntry)
		{
			UpdateDirtyFlag(DIRTY_FLAG_SKILLASSET);

			//增加技能属性
			ModifyControllerAttributeBySkill(pkNewSkillEntry, nSkillId, true, runeSystemType, runeSystemParam);

			//如果是被动技能，立即激活
			SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(nSkillId);
			if (pkSkillExecute == NULL)
			{
				return false;
			}
			CF_SkillSpecialAttrib::DataEntry* pkSkillAttrib = pkSkillExecute->GetAttrDataEntryPtr();
			CF_SkillExecuteList::DataEntry* pkSkillData = pkSkillExecute->GetDataEntryPtr();
			if (pkReplacedSkills)
			{
				*pkReplacedSkills = kSkillIDSet;
			}
			LC_ShortcutBar* pShortcutBar =  GetShortcutBar();
			int32_t shorcutidx = -1;
			LC_SkillIDSet::iterator it = kSkillIDSet.begin();
			for (; it != kSkillIDSet.end(); ++it)
			{
				if(NULL == pShortcutBar)
					continue;
				shorcutidx = pShortcutBar->FindFirstEntryIndexByTypeID(*it);
				if (shorcutidx >= 0)
					break;
			}
			if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
			{
				if (pkSkillExecute->HasPassive())
				{
					pkSkillExecute->StartPassive(this);
				}
				else
				{
					this->ActiveSkillStateToAllBuddyInstance(pkSkillAttrib->_lSkillConstParameter1, 0, this->GetID(), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter2), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter3), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter4), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter5), Utility::Int2Float(pkSkillAttrib->_lSkillConstParameter6));
				}
			}
			else
			{
				if( NULL != pShortcutBar)
				{
					if (shorcutidx >= 0)
						pShortcutBar->ShortcutSkill(shorcutidx / MAX_SINGLE_SHORTCUTBAR_SLOT_COUNT, shorcutidx % MAX_SINGLE_SHORTCUTBAR_SLOT_COUNT, nSkillId, true);
					else if (pkSkillData->_AutoShortcutIdx > 0)
					{
						LC_ShortcutEntry* entry = pShortcutBar->GetShortcutEntry(pkSkillData->_AutoShortcutPage, pkSkillData->_AutoShortcutIdx - 1);
						if (entry && !entry->GetValid())
						{
							pShortcutBar->ShortcutSkill(pkSkillData->_AutoShortcutPage, pkSkillData->_AutoShortcutIdx - 1, nSkillId);
						}
					}
				}

			}
			if( NULL != pShortcutBar)
				pShortcutBar->RefreshShortcutBar();
			//重新生成CD表
			BuildSkillCoolDownMap();
			BuildTransformSkillCoolDownMap();

			//发送GLET_LEARN_SKILL_END事件，通知客户端学会/升级了该技能
			if(pkSkillData->_bPrompt && send)
			{
				LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
				LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
				if (NULL != pkGameEvent)
				{
					pkGameEvent->SetEventType(GLET_LEARN_SKILL_END);
					pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM, GENT_SELF);
					pkGameEvent->SetEventParam(EP_LEARN_SKILL_PLAYER_ID, GetID());
					pkGameEvent->SetEventParam(EP_LEARN_SKILL_ID, nSkillId);
					pkGameEvent->SetEventParam(EP_LEARN_SKILL_SLOT, nSlotIndex);
					pkGameEvent->SetEventParam(EP_LEARN_SKILL_STATE, isUpgrade);
					pkEventManager->InsertGameEvent(pkGameEvent);
				}
			}

			SyncBuddySkillAssetToClient( true );
			SyncSkillAssetToClient(true);

			return true;
		}
	}
	return false;
}

bool LC_ServerPlayer::RemoveSkillToController( int nSkillId, int32_t subType)
{
	if (!IsInstance())
	{
		return false;
	}

	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->RemoveSkillToController(nSkillId);
	}

	LC_SkillAssetEntry* pkSkillEntry = m_kControllerSkillAsset.FindLearnedSkill(nSkillId);
	if(NULL == pkSkillEntry)
	{
		return false;
	}

	if (IS_SKILL_TYPE(nSkillId))
	{
		if (RE_SUCCESS == m_kControllerSkillAsset.DeleteSkillFromAsset(nSkillId))
		{
			//删掉属性
			ModifyControllerAttributeBySkill(pkSkillEntry, nSkillId, false);

			//如果是被动技能，立即end
			SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(nSkillId);
			if (pkSkillExecute == NULL)
			{
				return false;
			}
			CF_SkillExecuteList::DataEntry* pkSkillData = pkSkillExecute->GetDataEntryPtr();
			if (pkSkillData->_lPosNegType == SPNT_NEGTIVE)
			{
				if (pkSkillExecute->HasPassive())
				{
					pkSkillExecute->EndPassive(this);
				}
				else
				{
					CF_SkillSpecialAttrib::DataEntry* pkAttrib = pkSkillExecute->GetAttrDataEntryPtr();
					if(pkAttrib)
						this->DeactiveSkillStateToAllBuddyInstance(pkAttrib->_lSkillConstParameter1);
				}
			}

			//删除该CD信息
			GetSkillCoolDownMap()->RemoveSkillCDSlot(nSkillId);
			//更新至客户端
			UpdateDirtyFlag(DIRTY_FLAG_SKILLASSET);

			return true;
		}
	}

	return true;
}
bool LC_ServerPlayer::FlushSkillStateToOneBuddyInstance(int32_t nBuddyId)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->FlushSkillStateToOneBuddyInstance(nBuddyId);
	}

	BuddyInstance* pInstance = GetBuddyInstanceByID(nBuddyId);
	if (pInstance == NULL)
		return false;
	if( NULL == m_pAssignedBuddyInstance)
		return false;
	LC_ActorStateMap* pStateMap = m_pAssignedBuddyInstance->GetStateMap();
	pInstance->FlushControllerSkillState(*pStateMap);

	return false;
}

ResultType LC_ServerPlayer::ActiveSkillStateToAllBuddyInstance(int lStateTypeID, int lStateLifeTime, object_id_type lStateAttacherID, float fPara0, float fPara1, float fPara2, float fPara3, float fPara4)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->ActiveSkillStateToAllBuddyInstance(lStateTypeID, lStateLifeTime, lStateAttacherID, fPara0, fPara1, fPara2, fPara3, fPara4);
	}

	//永久存下的buff不能二次叠加
	LC_ActorStateMap* pkStateMap = m_pOwnerPlayer->GetControllerStateMap();
	if(NULL != pkStateMap)
	{
		LC_ActorStateEntry* pkActorStateEntry = pkStateMap->GetStateEntryByID(lStateTypeID);
		if(NULL!=pkActorStateEntry && pkActorStateEntry->GetMaxLifeTime()<0)
		{
			return RE_SKILL_STATE_ADD_FAIL;
		}
	}

	SK_Factory* pkFactory = SK_Factory::GetSingletonPtr();
	SK_State* pkSkillState = pkFactory->RequestSkillState(lStateTypeID);
	if (NULL == pkSkillState)
	{
		return RE_SKILL_STATE_ADD_FAIL;
	}
#if 0
	// BuddyInstance的buff不需要后续逻辑
	if ((GetDead() || GetDying()) && !pkSkillState->GetProperty_AttachOnDead())
	{
		return RE_SKILL_STATE_ADD_FAIL_FULL;
	}
	ResultType iResult = pkSkillState->CheckActorSkillFlag(GetAllSkillFlag());

	if (iResult == RE_SKILL_CHECK_GOD_CANT  )
	{
		if ( GOD_ITEM_4 == GetStateExtendData(GOD_STATE_ID, GOD_STATE_ITEMTYPE))
			return RE_SKILL_CHECK_GOD_CANT;
		else
			iResult = RE_SKILL_CHECK_SKILLFLAG_SUCCESS;
	}

	if (iResult != RE_SKILL_CHECK_SKILLFLAG_SUCCESS)
	{
#ifndef T6_CLIENT
		SK_SkillEventManagerBase* pkEventManager = ENGINE_GET_SKILL_EVENT_MANAGER();
		SK_SkillEvent* pkEvent = pkEventManager->AllocEvent();
		if (NULL != pkEvent)
		{
			pkEvent->SetEventType(SETE_ATTACH_STATE);
			pkEvent->SetSrcActorID(lStateAttacherID);
			pkEvent->SetDstActorID(GetID());
			pkEvent->SetLogicID(0);
			pkEvent->SetParam(SK_AttachStateEvent::SEP_STATE_ID, lStateTypeID);
			pkEvent->SetParam(SK_AttachStateEvent::SEP_RESULT, SK_AttachStateEvent::SASR_SKILLFLAG_EXCLUDE);
			pkEventManager->AddEvent(pkEvent);
		}
#endif
		return RE_SKILL_STATE_ADD_FAIL;
	}

	iResult = pkSkillState->StatePreCheck(this, lStateAttacherID, lStateLifeTime, fPara0, fPara1, fPara2, fPara3, fPara4);
	if (iResult != RE_SKILL_SCRIPT_NORMAL)
	{
		return RE_SKILL_STATE_ADD_FAIL;
	}
#endif

	ResultType eResultType = m_kControllerSkillStateMap->AddSkillStateToStateMap(lStateTypeID, lStateLifeTime, lStateAttacherID, fPara0, fPara1, fPara2, fPara3, fPara4);
	// 系统buff 加属性 

	SyncSkillStateToActivateBuddyInstance();
	return eResultType;
}

ResultType LC_ServerPlayer::ActiveSkillStateToAllBuddyInstance(Skill::SkillStateParam& rParam)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->ActiveSkillStateToAllBuddyInstance(rParam);
	}

	return false;
}

ResultType LC_ServerPlayer::DeactiveSkillStateToAllBuddyInstance(int lStateTypeID)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->DeactiveSkillStateToAllBuddyInstance(lStateTypeID);
	}

	ResultType res = m_kControllerSkillStateMap->RemoveSkillStateInStateMap(lStateTypeID);

	SyncSkillStateToActivateBuddyInstance();
	return res;
}

ResultType LC_ServerPlayer::DeactiveSkillStateToAllBuddyInstance(int iBuffType, int iKind, int iLevel, int iDeactiveMaxCount)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return RE_FAIL;

	if (!IsMainController())
	{
		return m_pOwnerPlayer->DeactiveSkillStateToAllBuddyInstance(iBuffType, iKind, iLevel, iDeactiveMaxCount);
	}

	FilerStateOPer oper(iBuffType, iKind, iLevel);
	m_kControllerSkillStateMap->ForAllState(&oper);

	LC_SkillIDSet::iterator it = oper.kStates.begin();
	for (; it != oper.kStates.end(); ++it)
	{
		m_kControllerSkillStateMap->RemoveSkillStateInStateMap(*it);
	}

	SyncSkillStateToActivateBuddyInstance();
	return (int)oper.kStates.size();
}

int LC_ServerPlayer::DeactiveAllSkillState()
{
	int nCount = 0;
	FilerStateOPerAll oper(0, 0, 0);
	m_kSkillStateMap->ForAllState(&oper);

	LC_SkillIDSet::iterator it = oper.kStates.begin();
	for (; it != oper.kStates.end(); ++it)
	{
		m_kSkillStateMap->RemoveSkillStateInStateMap(*it);
	}
	nCount = (int)oper.kStates.size();

	return nCount;
}

void LC_ServerPlayer::SyncSkillStateToActivateBuddyInstance()
{
	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->SyncSkillStatesToClient(SSC_ALL);
	}	
}

void LC_ServerPlayer::ModifyControllerAttributeBySkill(LC_SkillAssetEntry* pkSkillEntry, int nSkillId, bool add, int runeSystemType, int runeSystemParam)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (NULL==m_pOwnerPlayer || NULL==pkSkillEntry)
		return;
	if(!IsMainController())
		return m_pOwnerPlayer->ModifyControllerAttributeBySkill(pkSkillEntry, nSkillId, add, runeSystemType, runeSystemParam);	
	CF_SkillSpecialAttrib::DataEntry* pkSkillAttrib = SafeGetCSVFileDataEntryPtr<CF_SkillSpecialAttrib>(nSkillId);
	if(NULL==pkSkillAttrib)
		return;

	const unique_id_impl& instance = GetInstance();
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "controller add[%d] attribute by learn or remove Skill! c_cid:%d, c_citizenship:%d, c_uid:%d, skillID:%d, systemType:%d, systemType:%d",
		(int)add, instance.detail(), instance.catagory(), GetUserID(), nSkillId, runeSystemType, runeSystemParam);

	if(runeSystemType!=-1 && runeSystemParam!=-1)
	{
		pkSkillEntry->SetRuneSystemType(runeSystemType);
		pkSkillEntry->SetRuneSystemParam(runeSystemParam);
	}
	else
	{
		runeSystemType = pkSkillEntry->GetRuneSystemType();
		runeSystemParam = pkSkillEntry->GetRuneSystemParam();
	}
}

int32_t LC_ServerPlayer::TryBuyBuddyByItem(int32_t nItemId, int32_t nBuddyId)
{
	LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwnerPlayer) 
		return false;

	if(!IsMainController())
		return pOwnerPlayer->TryBuyBuddyByItem(nItemId, nBuddyId);

	int32_t nResult = BuyBuddy(nBuddyId, true);
	return nResult;
}

ResultType LC_ServerPlayer::ReliveAllBuddyBeforeEnterMap(bool full, bool bAliveFull)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwnerPlayer = GetOwnerPlayer();
		if (pOwnerPlayer == NULL)
			return RE_FAIL;
		return pOwnerPlayer->ReliveAllBuddyBeforeEnterMap(full,bAliveFull);
	}
	for ( int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		LC_ServerPlayer* pkServerPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pkServerPlayer) 
			continue;

		pkServerPlayer->m_bBuddyRelive = false;
		LC_ActorAttributeMap* pkAttributeMap = pkServerPlayer->GetFinalAttributeMap();
		if (!pkAttributeMap)
			return RE_FAIL;

		attr_value_type lHP = 0;
		int lMP = 0;
		if(full)
		{
			lHP = pkAttributeMap->GetAttribute(ATT_MAX_HP);
			lMP = (int)(pkAttributeMap->GetAttribute(ATT_MAX_MP));
		}
		else
		{
			//复活HP、MP回复30%
			lHP = pkAttributeMap->GetAttribute(ATT_MAX_HP)*0.3;
			lMP = (int)(pkAttributeMap->GetAttribute(ATT_MAX_MP)*0.3);
		}

		if (pkServerPlayer->GetDead())
		{
			pkServerPlayer->Respawn(lHP, lMP);

			//发送网络应答
			MG_RLT_Respawn rltMsg;
			rltMsg.m_lPlayerID = pkServerPlayer->GetID();
			rltMsg.m_iRespawnType = MGPT_REQ_RESPAWN_ON_CURRENT_LOCATION;
			rltMsg.m_iHP = lHP;
			rltMsg.m_iMP = lMP;
			rltMsg.m_iReduceExp = 0;//UT_MathBase::MinInt(iReduceExp,lPlayerEXP);
			rltMsg.m_iReduceBindCash = 0;//iReduceBindCash;

			BroadCastToArea(MGPT_RLT_RESPAWN, &rltMsg);

			pkServerPlayer->m_bBuddyRelive = true;
		}
		else
		{
			if (bAliveFull)
			{
				pkServerPlayer->SetHP(lHP);
				pkServerPlayer->SetMP(lMP);
			}
		}
	}	
	SwitchCurrentBuddy();

	return RE_SUCCESS;
}

void LC_ServerPlayer::SetReliveBeforeEnterMapTag(bool tag)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->SetReliveBeforeEnterMapTag(tag);
	}

	if(m_bRelieveBeforeEnterMapTag != tag)
	{
		m_bRelieveBeforeEnterMapTag = tag;
	}
}

bool LC_ServerPlayer::GetReliveBeforeEnterMapTag()
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;

	if(!IsMainController())
	{
		return m_pOwnerPlayer->GetReliveBeforeEnterMapTag();
	}

	return m_bRelieveBeforeEnterMapTag;
}

int32_t LC_ServerPlayer::UnBindBuddyInstance(int32_t nIndex, bool bCheckCD)
{
	int nErrorCode = RE_BUDDY_ERROR_DEACTIVATE_OK;
	if (!IsMainController())
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_ACTIVATE_NONE_CONTROLLER,0,0);
		return false;
	}

	// 0 deny unbind.
	if (nIndex <= 0 || nIndex >= m_nUnlockedActivateBuddyCount)
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_ACTIVATE_SLOT_INVALID,0,0);
		return false;
	}

	LC_ServerPlayer* pkBeModifyPlayer = m_ppActivateBuddyDataPtr[nIndex];
	if(NULL != pkBeModifyPlayer && pkBeModifyPlayer->GetDead())
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_DEACTIVATE_DEAD,0,0);
		return false;
	}

	if (pkBeModifyPlayer == NULL && bCheckCD)
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_DEACTIVATE_NIL_SLOT,0,0);
		return false;
	}

	int nRetCode = false;
	nRetCode = CheckActivateBuddyCDTime(GET_PROCESS_TIME);
	if (nRetCode == false && bCheckCD)
	{
		Send_SC_BuddyReply(0,RE_BUDDY_ERROR_ACTIVATE_CD_NOT_READY,0,0);
		return false;
	}

	nErrorCode = CheckUnBindBuddyInstance_Logic();

	if (bCheckCD)
	{
		if (nErrorCode != RE_BUDDY_ERROR_DEACTIVATE_OK)
		{
			Send_SC_BuddyReply(0,nErrorCode,0,0);
			return false;
		}
	}
	else
	{
		if (nErrorCode != RE_BUDDY_ERROR_DEACTIVATE_OK && nErrorCode != RE_BUDDY_ERROR_ACTIVATE_MAP_DENY_FIGHT)
		{
			Send_SC_BuddyReply(0,nErrorCode,0,0);
			return false;
		}
		nErrorCode = RE_BUDDY_ERROR_ACTIVATE_OK;
	}

	LC_ServerPlayerEnterLeaveManager* pIOMgr = SERVER_GET_PLAYERENTERLEAVE_MANAGER();
	if ( pIOMgr == NULL )
	{
		Send_SC_BuddyReply(0,nErrorCode,0,0);
		return false;
	}

	object_id_type nChangedId = INVALID_ACTOR_ID;
	// 1 Put Current Buddy back
	int32_t nOrigBuddyId = m_ppActivateBuddyTemplateId[nIndex];

	BuddyInstance* pBuddy = GetBuddyInstanceByID(nOrigBuddyId);
	if (pBuddy == NULL && bCheckCD)
	{
		if(0 != nOrigBuddyId)
		{
			Send_SC_BuddyReply(0,RE_BUDDY_ERROR_ACTIVATE_BUDDYID_INVALID,0,0);
		}
		return false;
	}

	// 2 Remove orig player.
	object_id_type nDelayLeaveID = 0;
	IF_A_VALID_PLAYER(pkBeModifyPlayer)
	//if ( pkBeModifyPlayer )
	{
		int nNewIndex = 0;
		if ( m_nCurrentBuddyIndex == nIndex )
		{
			nNewIndex = GetOtherActivateBuddy( true );
			if ( nNewIndex == -1 )
				return false;
		}
		if ( bCheckCD )
			SetLastActivateBuddyTime(GET_PROCESS_TIME);

		m_ppActivateBuddyTemplateId[nIndex] = nChangedId;
		m_ppActivateBuddyObjectId[nIndex] = nChangedId;
		m_ppActivateBuddyDataPtr[nIndex] = NULL;
		// stop all buffs
		pkBeModifyPlayer->DeactiveAllSkillState();
		// Replace a buddy instance
		SubAliveBuddyCount();

		pkBeModifyPlayer->GetAssignedBuddyInstance()->OnUnBind();
		GetBuddySchemeMgr().SetCurrentScheme(this, nIndex, INVALID_ACTOR_ID);

		nChangedId = pkBeModifyPlayer->GetID();

		if ( m_nCurrentBuddyIndex == nIndex )
			SwitchCurrentBuddy();

		//pIOMgr->UserLeaveServer(pkBeModifyPlayer, LMIOT_RESET);
		pIOMgr->DestoryPlayerNotSaveDB(pkBeModifyPlayer, LMIOT_RESET);
		nDelayLeaveID = pkBeModifyPlayer->GetID();
		m_nAllocatedActivateBuddyCount--;

	}

	Send_SC_BuddyReply(0,nErrorCode,0,0);

	SyncBuddyData_Usable();
	SyncBuddyData_Activate();
	if ( nDelayLeaveID )
		SyncLeaveFov(nDelayLeaveID);

	GetBuddySchemeMgr().SetCurrentScheme(this, nIndex, INVALID_ACTOR_ID);

	if (GetLoadDataFromDBFlag())
	{
		SetCharInfoDirty();
	}

	return true;
}

int32_t LC_ServerPlayer::BindBuddyInstance(int32_t nIndex, int32_t nBuddyId, bool bCheckCD, int32_t nTargetType)
{
	if (nTargetType == -1)
		nTargetType = 0;
	int nErrorCode = RE_BUDDY_ERROR_ACTIVATE_OK;
	if (!IsMainController())
	{
		Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_ACTIVATE_NONE_CONTROLLER,0,0);
		return false;
	}

	if (nIndex < 0 || nIndex >= m_nUnlockedActivateBuddyCount)
	{
		Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_ACTIVATE_SLOT_INVALID,0,0);
		return false;
	}

	LC_ServerPlayer* pkBeModifyPlayer = m_ppActivateBuddyDataPtr[nIndex];
	if(NULL != pkBeModifyPlayer && pkBeModifyPlayer->GetDead())
	{
		Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_SWAP_BUDDY_DEAD,0,0);
		return false;
	}

	int nRetCode = CheckActivateBuddyByTemplateID(nBuddyId);
	if (nRetCode && bCheckCD)
	{
		Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_ACTIVATE_BUDDYID_IN_USE,0,0);
		return false;
	}

	nRetCode = CheckActivateBuddyCDTime(GET_PROCESS_TIME);
	if (nRetCode == false && bCheckCD)
	{
		Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_ACTIVATE_CD_NOT_READY,0,0);
		return false;
	}

	BuddyInstance* pBuddy = GetBuddyInstanceByID(nBuddyId);
	if (pBuddy == NULL)
	{
		if(0 != nBuddyId)
		{
			Send_SC_BuddyReply(nBuddyId,RE_BUDDY_ERROR_ACTIVATE_BUDDYID_INVALID,0,0);
		}
		return false;
	}

	ResultType resType = GetBuddySchemeMgr().CheckModifyCurrentScheme(this, nIndex, nBuddyId);
	if ((resType != RE_BUDDY_SCHEME_ERROR_OK && resType != RE_BUDDY_SCHEME_ERROR_EXIST && (bCheckCD || (nIndex != 0)) )
		|| ( resType == RE_BUDDY_SCHEME_ERROR_EXIST && bCheckCD ) 
		)
	{
		Send_SC_BuddyReply(nBuddyId,resType,0,0);
		return false;
	}

	nErrorCode = CheckBindBuddyInstance_Logic(pBuddy, m_ppActivateBuddyDataPtr[nIndex]!=NULL);

	if (bCheckCD)
	{
		if (nErrorCode != RE_BUDDY_ERROR_ACTIVATE_OK)
		{
			Send_SC_BuddyReply(nBuddyId,nErrorCode,0,0);
			return false;
		}
	}
	else
	{
		if (nErrorCode != RE_BUDDY_ERROR_ACTIVATE_OK && nErrorCode != RE_BUDDY_ERROR_ACTIVATE_MAP_DENY_FIGHT)
		{
			Send_SC_BuddyReply(nBuddyId,nErrorCode,0,0);
			return false;
		}
		nErrorCode = RE_BUDDY_ERROR_ACTIVATE_OK;
	}

	if (bCheckCD)
		SetLastActivateBuddyTime(GET_PROCESS_TIME);

	object_id_type nChangedId = INVALID_ACTOR_ID;
	// 1 Put Current Buddy back
	int32_t nOrigBuddyId = m_ppActivateBuddyTemplateId[nIndex];
	m_ppActivateBuddyTemplateId[nIndex] = nBuddyId;

	if ( nBuddyId == nOrigBuddyId )
		return true;
	// 2 Bind New BuddyData
	LC_ServerPlayer* pNewPlayer = NULL;

	if ( m_ppActivateBuddyDataPtr[nIndex] )
	{
		float fCurrentTime = GET_PROCESS_TIME;
		m_ppActivateBuddyDataPtr[nIndex]->SetPassiveMoveSpeed(0);
		m_ppActivateBuddyDataPtr[nIndex]->TryInterruptSkill( -1, fCurrentTime, SKI_FORCE);
		m_ppActivateBuddyDataPtr[nIndex]->TryFinishSkill( -1, fCurrentTime, m_ppActivateBuddyDataPtr[nIndex]->GetCurrentLocation().x, m_ppActivateBuddyDataPtr[nIndex]->GetCurrentLocation().y );
		m_ppActivateBuddyDataPtr[nIndex]->ClearNextSkill();
		// stop all buffs
		m_ppActivateBuddyDataPtr[nIndex]->DeactiveAllSkillState();
		// Replace a buddy instance

		m_ppActivateBuddyDataPtr[nIndex]->GetAssignedBuddyInstance()->OnUnBind();
		GetBuddySchemeMgr().SetCurrentScheme(this, nIndex, INVALID_ACTOR_ID);

		SubAliveBuddyCount();
		PushBuddyInstance(m_ppActivateBuddyDataPtr[nIndex], nIndex, false);
		AddAliveBuddyCount();
		pNewPlayer = m_ppActivateBuddyDataPtr[nIndex];
		nChangedId = pNewPlayer->GetID();

		BuddyInstance* pkBuddy = pNewPlayer->GetAssignedBuddyInstance();
		if(NULL != pkBuddy)
		{
			pkBuddy->OnBind(pNewPlayer->GetID());

			GetBuddySchemeMgr().SetCurrentScheme(this, nIndex, nBuddyId);
			
			MG_RefreshPlayerBindBuddy refresh;
			refresh.m_lPlayerID = pNewPlayer->GetID();
			refresh.m_bEquipSlotStarLevel =pNewPlayer->GetBuddyEquipSlotStarState(); 
			pkBuddy->FillBuddyCSInfo(refresh.m_nBuddyInfo);

			BroadCastToArea(MGPT_REFRESH_PLAYER_BIND_BUDDY, &refresh);	
		}

		m_ppActivateBuddyDataPtr[nIndex]->SyncPropertyToClient();
	}
	else
	{
		// call a buddy instance
		// 这部分代码理应和Allocate中相应部分抽象成一个函数。暂时不这么做的原因是，梳理流程，确定ChangeMap的时机
		//						weixin commented.
		int32_t nMapLogicId = GetMapLogicID();
		LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
		LC_ServerMapLogic_Place* pkMapLogic	=	pkWorldManager->GetMapLogic(nMapLogicId);
		if (pkMapLogic == NULL)
			return false;
		Utility::UT_Vec3Int pos = m_kCurrentLocation;
		//pos.x += 100;
		//pos.y += 100;
		ModifyOffsetLocationByIndex(nIndex, pos);

		object_id_type instanceID = LC_LogicIDManager::GetSingletonPtr()->RequestLogicID(LOT_BUDDY);
		LC_ServerPlayer* pActivatePlayer = pkMapLogic->SpawnBuddyPlayer(m_iID, m_Instance + instanceID, pos, PLY_DEF_BUDDY_BITS, this, NULL, FACTION_PLAYER);	
		if (pActivatePlayer == NULL)
			return false;
		//pActivatePlayer->SetOwnerPlayer(this);
		pActivatePlayer->SetControlType(eControlType_Buddy);
		pActivatePlayer->GetFinalAttributeMap()->RecomputeAttribute(ATT_MAX_HP);
		pActivatePlayer->SetBuddyAllocateId(instanceID);

		bool bInitGame = false;
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(pkOwnerPlayer)
			bInitGame = pkOwnerPlayer->CheckInitGame();

		PushBuddyInstance(pActivatePlayer, nIndex, bInitGame == false? true:false);
		AddAliveBuddyCount();
		pActivatePlayer->ChangeMap(nMapLogicId, GetMapResID(), GetMapLogicType(), pos, true);
		pActivatePlayer->FlushMessageDirtyFlag();
		pActivatePlayer->GetAssignedBuddyInstance()->OnBind(pActivatePlayer->GetID());
		pNewPlayer = pActivatePlayer;
		pNewPlayer->SetAllInitGame(bInitGame);
		if (bCheckCD)
		{
			Protocol::MG_SyncPlayerEnter	msg;
			MC_MessagePackageHelp::Packet(msg,pActivatePlayer);
			SendMsgToClient(msg.GetMessageID(),&msg);
		}
	}

	GetBuddySchemeMgr().SetCurrentScheme(this, nIndex, nBuddyId);

	Send_SC_BuddyReply(nBuddyId,nErrorCode,0,0);
	SyncBuddyData_Usable();
	SyncBuddyData_Activate();

	pNewPlayer->UpdateDirtyFlag(DIRTY_FLAG_PROPERTY);
	pNewPlayer->UpdateDirtyFlag(DIRTY_FLAG_ATTRIBUTE);

	//出战后，同步buddy的血量
	//SyncActiviteBuddyProperty();

	if (GetLoadDataFromDBFlag())
	{
		SetCharInfoDirty();
	}

	AchievementEvent kEvent1;
	kEvent1.SetNum(GetActivateBuddyCombatScore());
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ACTIVATE_BUDDY_COMBATSCORE, kEvent1);

	return true;
}

int32_t LC_ServerPlayer::CheckUnBindBuddyInstance_Logic()
{
	int32_t nResult = RE_BUDDY_ERROR_DEACTIVATE_OK;
	//CF_WorldMapList
	int32_t nMapResId = GetMapResID();
	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(nMapResId);
	if  (pkMapEntry == NULL)
		return nResult;

	CF_BuddyLimit::DataEntry* pLimit = SafeGetCSVFileDataEntryPtr<CF_BuddyLimit>(pkMapEntry->_iBuddyLimit);
	if (pLimit == NULL)
		return nResult;

	if (pLimit->_NormalSwitch == 0)
		return RE_BUDDY_ERROR_ACTIVATE_MAP_DENY_FIGHT;

	if (pLimit->_FightSwitch == 0 && GetHatredList()->GetHatredCount() > 0)
	{
		return RE_BUDDY_ERROR_ACTIVATE_MAP_DENY;
	}

	return nResult;
}

int32_t LC_ServerPlayer::CheckBindBuddyInstance_Logic(BuddyInstance* pBuddy, bool bSwitch)
{
	int32_t nResult = RE_BUDDY_ERROR_ACTIVATE_OK;
	//CF_WorldMapList
	int32_t nMapResId = GetMapResID();
	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(nMapResId);
	if  (pkMapEntry == NULL)
		return nResult;

	CF_BuddyLimit::DataEntry* pLimit = SafeGetCSVFileDataEntryPtr<CF_BuddyLimit>(pkMapEntry->_iBuddyLimit);
	if (pLimit == NULL)
		return nResult;

	if (pLimit->_NormalSwitch == 0)
		return RE_BUDDY_ERROR_ACTIVATE_MAP_DENY_FIGHT;

	if (pLimit->_FightSwitch == 0 && GetHatredList()->GetHatredCount() > 0 && bSwitch)
	{
		return RE_BUDDY_ERROR_ACTIVATE_MAP_DENY;
	}

	return nResult;
}

int32_t LC_ServerPlayer::BuyBuddy(int32_t nTemplateId, bool bForce)
{
	int nRetCode = 0;
	int nResult = false;
	int nErrCode = RE_BUDDY_ERROR_BUY_OK;
	int nMode = 0;

	SingleBuddyData data;
	CF_Buddy* pBuddyConfig = CF_Buddy::GetSingletonPtr();


	CF_Buddy::DataEntry* pData = pBuddyConfig->GetEntryPtr(nTemplateId);
	if (pData == NULL)
	{
		nErrCode = RE_BUDDY_ERROR_BUY_NO_TEMPLATE;
		goto Exit0;
	}

	nRetCode = CheckUnlockedBuddyByTemplateID(nTemplateId);
	if (nRetCode)
	{
		if (bForce == false)
		{
			nErrCode = RE_BUDDY_ERROR_BUY_GOT;
			goto Exit0;
		}
		else
		{
			TryAddBuddyMoney(pData);
			nErrCode = RE_BUDDY_ERROR_BUY_RETURN_RES;
			goto Exit1;
		}
	}

	// Check Money
	if (!bForce)
	{
		nRetCode = TryReduceBuddyMoney(pData);
		if (!nRetCode)
		{
			nErrCode = RE_BUDDY_ERROR_BUY_NO_RES;
			goto Exit0;
		}
	}
	// Ok, buy
	// 1 add card
	BuyBuddy_Impl(nTemplateId);
	// 2 reduce resource

	// 3 sync data
	SyncBuddyData_Usable();
Exit1:
	nResult = true;
	if (GetLotteryStat())
		nMode = ProductMode::eProductMode_Lottery;
	else
		nMode = ProductMode::eProductMode_Normal;
Exit0:
	Send_SC_BuddyReply(nTemplateId,nErrCode,nMode,0);
	return nResult;
}

bool LC_ServerPlayer::IsInBaseSkill()
{
	bool bResult = false;

	int32_t nCurSkill  = GetCurrentStateType();
	if ( !IS_SKILL_TYPE(nCurSkill) )
		return false;
	if( NULL == m_pAssignedBuddyInstance)
		return false;
	LC_SkillAssetEntry* pFirstSkillEntry = m_pAssignedBuddyInstance->GetSkillAsset()->GetSkillAssetData()->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, 0);
	if ( pFirstSkillEntry == NULL )
		return false;
	if (nCurSkill == pFirstSkillEntry->GetTypeID())
		bResult = true;

	return bResult;
}

void LC_ServerPlayer::UpdateForBuddyController(float fCurrentTime, float fDeltaTime)
{
	if( NULL == m_pAssignedBuddyInstance)
		return;
	LC_SkillAssetEntry* pFirstSkillEntry = m_pAssignedBuddyInstance->GetSkillAsset()->GetSkillAssetData()->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, 0);
	if (m_kHatredList.GetHatredCount() == 0 && GetLogicCombatFlag())
	{
		if (!GetAIControl())
			SetLogicCombatFlag(false);
		// Check Cur Skillif ()
		if (pFirstSkillEntry && pFirstSkillEntry->GetTypeID() == GetCurrentStateType())
		{
			// Normal attack
			InterruptSkillCast(GET_PROCESS_TIME);
		}
		//TryStopAllBuddyAttack();
	}

	if ( !IsCurrentActivateBuddy() && !GetLogicCombatFlag())
	{
		if (pFirstSkillEntry && pFirstSkillEntry->GetTypeID() == GetCurrentStateType())
		{
			// Normal attack
			//InterruptSkillCast(GET_PROCESS_TIME);
			TryInterruptSkill( -1, fCurrentTime, SKI_FORCE);
			TryFinishSkill( -1, fCurrentTime, m_kCurrentLocation.x, m_kCurrentLocation.y );
		}
	}

	// target delay setting
#if 0
	// Enable this logic later
	if (m_nPlayerControlType == eControlType_Player)
	{
		object_id_type nTargetId = INVALID_ACTOR_ID;
		int nHatredCount = m_kHatredList.GetHatredCount();
		object_id_type nOrigTargetId = GetDefaultTargetID();
		if (nOrigTargetId == INVALID_ACTOR_ID)
		{
			if (nHatredCount > 0)
			{
				LC_ActorHatredEntry* pkHatredEntry = NULL;
				pkHatredEntry = m_kHatredList.GetSortHatredByIndex(0);
				if (NULL != pkHatredEntry)
				{
					nTargetId = pkHatredEntry->GetTargetID();
					SetDefaultTargetID( nTargetId );
					SetLogicCombatFlag(true);
				}
			}
		}
	}
#endif
	if (GetControlType() != eControlType_Buddy && GetAIControl() == false)
		return;
	//UpdateForBuddyController_CheckCDReady( fCurrentTime, fDeltaTime );
	UpdateForBuddyController_CheckUsableCount( fCurrentTime, fDeltaTime );
	m_fRollSkillTimer += fDeltaTime;
	if (m_fRollSkillTimer > RESET_ROLL_SKILL_TIMER)
	{
		ClearNextSkill();
		m_fRollSkillTimer = 0.00f;
	}
}

void LC_ServerPlayer::UpdateForBuddyController_CheckUsableCount(float fCurrentTime, float fDeltaTime)
{
	if (fDeltaTime < 0.0001f)
		return;

	if (m_pAssignedBuddyInstance == NULL)
		return;

	LC_SkillAsset* pSkillAsset = m_pAssignedBuddyInstance->GetSkillAsset();
	if (pSkillAsset == NULL)
		return;

	LC_SkillAssetData* pSkillAssetData = pSkillAsset->GetSkillAssetData();

	if ( GetGlobalSetting.nBuddySkillRollIndex >= 0 )
	{
		m_pNextSkillEntry = m_pAssignedBuddyInstance->GetSkillAsset()->GetSkillAssetData()->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, GetGlobalSetting.nBuddySkillRollIndex);
		return;
	}

	int nSize = pSkillAssetData->GetSkillCount((skill_cat_type)SKILL_TYPE_SECT);

	float fCurrent = GET_PROCESS_TIME;
	LC_SkillAssetEntry* pBaseSkillEntry = pSkillAssetData->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, 0);
	object_id_type nObjId = m_iID;
	int nBuddyTemplateId = m_nBuddyTemplateId;
	for ( int i = nSize - 1; i >= 0; i-- )
	{
		LC_SkillAssetEntry* pSkillEntry = pSkillAssetData->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, i);
		if (pSkillEntry == NULL)
			continue;
		SK_SkillExecute* pSkill = SK_Factory::GetSingletonPtr()->RequestSkillExcute(pSkillEntry->GetTypeID());
		if (pSkill)
		{
			ResultType iResult = CheckExecuteSkill(fCurrent, pSkill, 0);
			if (iResult != RE_SKILL_USABLE_COUNT_LIMIT && pSkillEntry->GetTypeID() != pBaseSkillEntry->GetTypeID())
			{
				if (GetCurrentStateType() == pBaseSkillEntry->GetTypeID())
				{
					TryInterruptSkill( -1, fCurrentTime, SKI_FORCE);
					TryFinishSkill( -1, fCurrentTime, GetCurrentLocation().x,GetCurrentLocation().y );
				}
				m_pNextSkillEntry = pSkillEntry;	
				break;
			}
		}
	}
	return;
}

void LC_ServerPlayer::UpdateForBuddyController_CheckCDReady(float fCurrentTime, float fDeltaTime)
{
	if (fDeltaTime < 0.0001f)
		return;

	if (m_pAssignedBuddyInstance == NULL)
		return;

	LC_SkillAsset* pSkillAsset = m_pAssignedBuddyInstance->GetSkillAsset();
	if (pSkillAsset == NULL)
		return;

	LC_SkillAssetData* pSkillAssetData = pSkillAsset->GetSkillAssetData();


	int nSize = pSkillAssetData->GetSkillCount((skill_cat_type)SKILL_TYPE_SECT);

	float fCurrent = GET_PROCESS_TIME;
	LC_SkillAssetEntry* pBaseSkillEntry = pSkillAssetData->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, 0);
	object_id_type nObjId = m_iID;
	int nBuddyTemplateId = m_nBuddyTemplateId;
	for ( int i = nSize - 1; i >= 0; i-- )
	{
		LC_SkillAssetEntry* pSkillEntry = pSkillAssetData->GetSkillAssetEntry((skill_cat_type)SKILL_TYPE_SECT, i);
		if (pSkillEntry == NULL)
			continue;
		SK_SkillExecute* pSkill = SK_Factory::GetSingletonPtr()->RequestSkillExcute(pSkillEntry->GetTypeID());
		if (pSkill)
		{
			ResultType iResult = CheckExecuteSkill(fCurrent, pSkill, 0);

			if (iResult != RE_SKILL_PENDING_FAIL_CD && pSkillEntry->GetTypeID() != pBaseSkillEntry->GetTypeID())
			{
				if (GetCurrentStateType() == pBaseSkillEntry->GetTypeID())
				{
					TryInterruptSkill( -1, fCurrentTime, SKI_FORCE);
					TryFinishSkill( -1, fCurrentTime, GetCurrentLocation().x,GetCurrentLocation().y );
				}
				m_pNextSkillEntry = pSkillEntry;	
				break;
			}
		}
	}
	return;
}

void LC_ServerPlayer::PostInitAllBuddyInstance()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->PostInitAllBuddyInstance();

	// ATTENTION: __RECURSIVE__ calling for this function  is __FORBIDDEN__

	BuddyChain_CalcCount();
	//放在最后等玩家所有缓存加载完，在统一走刷灵魂链的接口
}

void LC_ServerPlayer::UpdateAllBuddyInstance(float fCurrentTime, float fDeltaTime)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return ;
	if(!IsMainController())
		return pkOwnerPlayer->UpdateAllBuddyInstance( fCurrentTime,fDeltaTime);

	// ATTENTION: __RECURSIVE__ calling for this function  is __FORBIDDEN__
	mem::map<int32_t, BuddyInstance*>::iterator it = m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		BuddyInstance* pInstance = it->second;
		if (pInstance == NULL)
			continue;

		if ( pInstance->GetAssignedPlayerId() )
			continue;

		pInstance->Update(fCurrentTime, fDeltaTime);
	}
}

int32_t LC_ServerPlayer::TryAddBuddyMoney(CSVFile::CF_Buddy::DataEntry* pTemplate)
{
	if (pTemplate == NULL)
	{
		return false;
	}
	Utility::UT_SIMDataList kItemReq;
	Utility::ParseFmtString2DataIFs(pTemplate->Consumption, kItemReq);
	// just checking
	Utility::UT_SIMDataList::iterator it = kItemReq.begin();
	for (; it != kItemReq.end(); ++it)
	{
		UT_SIMDataInfo info = *it;
		int32_t nItemId = info.GetSkillID();
		int32_t nCount = info.GetSkillEnableLevel();
		//AddMoney
		LC_Helper::AddItem(GetPackAsset(), nItemId, nCount, 0, false);
		//AddItem(nItemId, nCount);
		if (GetLotteryStat())
			Activity::ACT_LotteryManager::AddSingleRewardItem(nItemId, nCount, true);
	}

	SyncBackPackToClient(PACK_TYPE_BASIC);
	return true;
}

int32_t LC_ServerPlayer::TryReduceBuddyMoney(CSVFile::CF_Buddy::DataEntry* pTemplate)
{
	Utility::UT_SIMDataList kItemReq;

	if (pTemplate == NULL)
	{
		return false;
	}

	Utility::ParseFmtString2DataIFs(pTemplate->Consumption, kItemReq);
	// just checking
	Utility::UT_SIMDataList::iterator it = kItemReq.begin();
	ResultType rResult;
	for (; it != kItemReq.end(); ++it)
	{
		UT_SIMDataInfo info = *it;
		int32_t nItemId = info.GetSkillID();
		int32_t nCount = info.GetSkillEnableLevel();
		rResult = TryDeleteItem(nItemId, nCount);
		if ( rResult != RE_SUCCESS)
			return false;
	}
	//埋点日志
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, BUDDY_OPERATE, OPERATE_LOGTYPE1);
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(pTemplate->_cID);
	// Reduce really
	it = kItemReq.begin();
	for (; it != kItemReq.end(); ++it)
	{
		UT_SIMDataInfo info = *it;
		int32_t nItemId = info.GetSkillID();
		int32_t nCount = info.GetSkillEnableLevel();
		//ConsumeItemsInPackageByID(nItemId, nCount);

		rResult = DeleteItem(nItemId, nCount, nLogCode,nParams);
	}

	return true;
}

int32_t LC_ServerPlayer::BuyBuddy_Impl(int32_t nTemplateId)
{
	int32_t nResult = false;
	mem::map<int32_t, SingleBuddyData>::iterator it = m_ppUsableBuddyData.find(nTemplateId);
	if ( it == m_ppUsableBuddyData.end() )
		return false;

	SingleBuddyData& data = it->second;
	if (data.bUnlock == true)
		return false;
	data.bUnlock = true;
	nResult = true;
	if ( nResult == true )
	{
		CF_Buddy* pBuddyConfig = CF_Buddy::GetSingletonPtr();

		CF_Buddy::DataEntry* pData = pBuddyConfig->GetEntryPtr(nTemplateId);
		if (pData == NULL)
			return false;

		BuddyInstance* pBuddy = CreateSingleBuddyInstance(pData, true);
		if (pBuddy == NULL)
			return false;

		pBuddy->OnCreate();
		pBuddy->GetBuddyAttrMgr().RefreshAllAttrMap(this,pBuddy);
		pBuddy->GetBuddyAttrMgr().RefreshHeroAllAttributeMap(this,pBuddy);
		pBuddy->GetBuddyAttrMgr().RefreshHeroGiveToOtherCoreAttrMap(this);
		if ( GetRiderCharType() != INVALID_ACTOR_ID )
		{
			int nFuncVal = GetAssignedBuddyInstance()->GetBuddyAttrMgr().GetHeroAllAttributeMap()->GetAttributeValue (ATT_MOVE_SPEED);
			pBuddy->GetBuddyAttrMgr().GetHeroAllAttributeMap()->AddAttributeValueFunc( ATT_MOVE_SPEED, nFuncVal );
		}
		pBuddy->GetBuddyAttrMgr().RefreshNewFinalAttrMap(this,pBuddy, false);
		pBuddy->SyncAllDataToClient();

		//buddy激活后的一系列操作  如:成就系统  开启宝具槽位穿戴功能
		OnAchieveEvent_BuddyInstanceCreate(pBuddy);
	}
	return nResult;
}
//--------------------------------------------------------
void LC_ServerPlayer::FindPathTo(const Utility::UT_Vec3Int& rkTarget)
{
	Utility::UT_LinePath& rMovePath = GetMovePath();
	int iPathPointCount = rMovePath.GetPathPointCount();
	if (iPathPointCount == 0 || UT_MathBase::LineLengthXYInt(rkTarget , m_kCurrentLocation) > 20)
	{
		if (PF_ServerPathManager::GetSingletonPtr())
		{
			LC_MapBase* pkMap = GetMap();
			if (!pkMap)
			{
				return;
			}
			int nMapResID = GetMapResID();
			bool bFindResult = PF_ServerPathManager::GetSingletonPtr()->FindPath(nMapResID , rMovePath, m_kCurrentLocation , rkTarget);
			if (!bFindResult)
			{
				rMovePath.Clear();
				SetCurrentLocation(GetCurrentLocation());
				SetMoveLineTargetLocation(GetCurrentLocation());
			}
		}
	}
}
//--------------------------------------------------------
void LC_ServerPlayer::CacheCurrentPath(const Utility::UT_Vec3Int&	rkCacheLocation)
{
	if (m_bCacheMovePath)
	{
		return;
	}
	m_bCacheMovePath = true;
	m_kCacheMovePath.Clone(m_kMovePath);
	if (m_kCacheMovePath.GetLinePathType() == UT_LinePath::LPT_FLIP)
	{
		if (m_kCacheMovePath.GetMoveStep() >= 1.0f)
		{
			m_kCacheMovePath.ReloadPathPointData();
			m_kCacheMovePath.GeneratePath();
		}
	}
	m_kCacheLocation = rkCacheLocation;
}
//--------------------------------------------------------
void LC_ServerPlayer::RecoverCurrentPath()
{
	if (!m_bCacheMovePath)
	{
		return;
	}
	m_bCacheMovePath = false;
	m_kMovePath.Clone(m_kCacheMovePath);
	m_kCacheMovePath.Clear();
}

#define MAX_SUMMOR_FRIEND_TALK_COUNT 6

struct SummorFriendTalkManager
{
	SummorFriendTalkManager()
	{
		CF_SummorFriendTalk* inst = SafeGetSingleton<CF_SummorFriendTalk>();
		CF_SummorFriendTalk::DataEntryMapExternIterator i = inst->GetIterator();
		while (i.HasMoreElements())
		{
			const CF_SummorFriendTalk::DataEntry* entry = i.PeekNextValuePtr();
			AddTalk(entry->_iType, entry->_kText);
			i.MoveNext();
		}
	}

	typedef mem::vector<StringType> TalkInfoListType;
	TalkInfoListType								TalkInfoLists[MAX_SUMMOR_FRIEND_TALK_COUNT];
	void AddTalk(int type, const StringType& Str)
	{
		if (type < 0 || type >= MAX_SUMMOR_FRIEND_TALK_COUNT)
		{
			return;
		}
		TalkInfoLists[type].push_back(Str);
	}
	StringType GetTalk(int type)
	{
		if (type < 0 || type >= MAX_SUMMOR_FRIEND_TALK_COUNT)
		{
			return "";
		}
		TalkInfoListType& list = TalkInfoLists[type];
		if (list.empty())
		{
			return "";
		}
		TalkInfoListType::size_type idx = UT_MathBase::RandInRangeInt(0, (int)list.size() - 1);
		return list[idx];
	}
};

static StringType _getSummorFriendTalk(int type)
{
	static SummorFriendTalkManager mgr;
	return mgr.GetTalk(type);
}

void	LC_ServerPlayer::SummorFriendTalk(int type , float CurrentTime)
{
	if (type < 0 || type > MAX_SUMMOR_FRIEND_TALK_COUNT)
	{
		return;
	}
	if (3 == type)
	{
		if (CurrentTime - m_fLastTalkTime < 30.0)
		{
			return;
		}
	}
	else
	{
		if (CurrentTime - m_fLastTalkTime < 5.0)
		{
			return;
		}
	}
	m_fLastTalkTime = CurrentTime;
	if (IsSummorFriend())
	{
		StringType text = _getSummorFriendTalk(type);
		if (text.empty())
		{
			return;
		}
	}
}

void LC_ServerPlayer::_updateComboCount(int iOldValue, int iAddCount)
{
	LC_PlayerBase::_updateComboCount(iOldValue, iAddCount);

	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_COMBO_COUNT);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
		pkGameEvent->SetEventParam(EP_COMBO_PLAYER_ID, GetID());
		pkGameEvent->SetEventParam(EP_COMBO_COUNT,	GetComboCount());
		pkGameEvent->SetEventParam(EP_COMBO_MAP_ID, GetMapResID());
		pkEventManager->InsertGameEvent(pkGameEvent);
	}

	//连击点数达到20的倍数，触发奖励
	int a = iOldValue / 20;
	int b = (iOldValue + iAddCount) / 20;
	attr_value_type iExp = 0;
	attr_value_type iSp = 0;
	if (b > a)
	{
		int iIndex = 0;
		iIndex = UT_MathBase::RandInRangeInt(0, 1);
		switch (iIndex)
		{
		case 0:
			{
				iExp = (attr_value_type)(UT_MathBase::Floor((GetNoPeakLevel() * 5 + 20) * 3.2f * (b - a) + 0.5f)); //round（（等级*5+20）/*/3*0.2*20*/，0）
				AddExpWithGamePlay(iExp, SYS_FUNC_TP_COMBO, b);
			}
			break;
		case 1:
			{
				iSp = (b - a) * 5; //5
				AddSkillLevelupPoints(iSp, SYS_FUNC_TP_COMBO, b);
			}
			break;
		}
	}

	if (iExp > 0 || iSp > 0)
	{
		//通知客户端
		LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
		if (pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_COMBO_REWARD);
			pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
			pkGameEvent->SetEventParam(EP_COMBO_REWARD_EXP,		iExp);
			pkGameEvent->SetEventParam(EP_COMBO_REWARD_SP,		iSp);
			SendGameEvent(pkGameEvent);
			pkEventManager->FreeGameEvent(pkGameEvent);
		}
	}

	//连击特效
	_updateComboEffect(iOldValue, iAddCount);
}


#define COMBO_EFFECT_TIME_INTERVAL_MIN 1.0
void LC_ServerPlayer::_updateComboEffect(int iOldValue, int iAddCount)
{
	if (GET_PROCESS_TIME - m_fComboEffectTime < COMBO_EFFECT_TIME_INTERVAL_MIN)
	{
		return;
	}
	if ((iOldValue < 20 && m_iComboCount >= 20) || (iOldValue < m_iComboCountAtLastRound + 20 && m_iComboCount >= m_iComboCountAtLastRound + 20))
	{
		_updateComboEffectCount(1);
	}
	else if (m_iComboEffectCount > 0 && m_iComboCount > 20)
	{
		int iIndex = UT_MathBase::RandInRangeInt(0, 99);
		if (iIndex >= 50)
		{
			_updateComboEffectCount(m_iComboEffectCount + 1);
		}
		else
		{
			_endComboEffectRound();
		}
	}
}

void LC_ServerPlayer::_updateComboEffectCount(int iCount)
{
	m_iComboEffectCount = iCount;

	//通知客户端
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_COMBO_EFFECT);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
		pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,		m_iComboEffectCount);

		SendGameEvent(pkGameEvent);
		pkEventManager->FreeGameEvent(pkGameEvent);
	}

	//更新数值
	m_fComboEffectTime = GET_PROCESS_TIME;
	if (m_iComboEffectCount == COMBO_EFFECT_ROUNT)
	{
		int iRound = m_iComboEffectRound + 1;
		_endComboEffectRound();
		m_iComboEffectRound = iRound;
	}
}

void LC_ServerPlayer::_endComboEffectRound()
{
	if (m_iComboEffectCount <= 0 && m_iComboEffectRound <= 0)
	{
		return;
	}

	//通知客户端
	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	LC_GameEvent* pkGameEvent			= pkEventManager->AllocGameEvent();
	if (pkGameEvent)
	{
		pkGameEvent->SetEventType(GLET_COMBO_EFFECT);
		pkGameEvent->SetEventParam(EVENT_SEND_TYPE_PARAM,	GENT_SELF);
		pkGameEvent->SetEventParam(EVENT_BASE_PARAM_1,		0);

		SendGameEvent(pkGameEvent);
		pkEventManager->FreeGameEvent(pkGameEvent);
	}
	m_iComboEffectCount = 0;
	m_iComboEffectRound = 0;
	m_iComboCountAtLastRound = m_iComboCount;
}

void LC_ServerPlayer::_clearComboCount()
{
	_endComboEffectRound();
	LC_PlayerBase::_clearComboCount();
	m_iComboCountAtLastRound	= 0;
}

void LC_ServerPlayer::UpdateDailySystem(uint32_t currentTime)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateDailySystem(currentTime);
	}

	if(currentTime < m_DailyTimeStamp)
	{
		return;
	}

	int deltaTime = 0;
	if(0 != m_DailyTimeStamp)
	{
		deltaTime = LC_Helper::GetDeltaDay(m_DailyTimeStamp, currentTime)+1;
	}
	m_DailyTimeStamp = (uint32_t)LC_Helper::GetTimeStampInCurDay(0, 0, 0) + ONE_DAY_SECONDS;

	//资源找回 在线玩家资源找回一定要是第一个调用
	pkOwnerPlayer->UpdateResourceRetrieveRecord();

	pkOwnerPlayer->GetPlayerGuildRobInfo()->PlayerGuildDaily(this);
	pkOwnerPlayer->DailyReceiveReward(true);
	pkOwnerPlayer->GetArenaBattleAssert()->ResetChallengeTime(GetVIPAsset().GetProfitValue(VIP_PROFIT_CHALLENGE));
	pkOwnerPlayer->GetRankAssert()->ClearRecord();
	pkOwnerPlayer->DailyRechargeReturnSettle();
	pkOwnerPlayer->GetResourceAlert().DailyReset();
	pkOwnerPlayer->GetFacebookRecord().DailyReset();
	pkOwnerPlayer->GetSubordinateAsset().DailyReset();

	//common stat
	pkOwnerPlayer->GetCommonStatAsset().CheckReset(pkOwnerPlayer, currentTime);
	pkOwnerPlayer->GetCommonStatAsset().OnLogin(pkOwnerPlayer, currentTime);

	LC_ServerTaskManager* pkTaskMgr = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL != pkTaskMgr)
	{
		pkTaskMgr->CheckReset(pkOwnerPlayer, currentTime);
	}	

	//promoter
	pkOwnerPlayer->GetPromoterAsset().Reset(currentTime);

	//treasure chests
	pkOwnerPlayer->GetTreasureChestsAsset().CheckReset(currentTime);

	//vip
	pkOwnerPlayer->GetVIPAsset().CheckReset(currentTime);
	pkOwnerPlayer->GetVIPAsset().SetTodayChargeFlag(false);

	//common shop
	pkOwnerPlayer->GetCommonShopAsset().CheckReset(currentTime);

	//Guild
	pkOwnerPlayer->GetPlayerGuildAssert()->CheckReset(currentTime);

	//story
	LC_GameStory_Manager* pkStoryMgr = SERVER_GET_GAMESTORY_MANAGER;
	if(NULL != pkStoryMgr)
	{
		pkStoryMgr->CheckReset(pkOwnerPlayer);
	}

	//每日清空
	pkOwnerPlayer->ClearDailyClean(currentTime);

	//神秘商店
	ServerMysticalShop::GetSingletonPtr()->RefreshItems(pkOwnerPlayer, false);

	//神秘宝藏
	pkOwnerPlayer->GetSecreteTreasureAsset().CheckReset(currentTime);

	//活动
	pkOwnerPlayer->GetACTScheduleAsset().CheckReset(currentTime);
	static Activity::ACT_ScheduleDataManager* pkScheduelDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	if(NULL != pkScheduelDataMgr)
	{
		pkScheduelDataMgr->OnLogin(pkOwnerPlayer, currentTime);
		pkScheduelDataMgr->CheckData(pkOwnerPlayer);
	}

	//竞技场
	pkOwnerPlayer->GetArenaAsset()->CheckDaily(currentTime);


	{
		pkOwnerPlayer->SetDailyFlag(true);
		pkOwnerPlayer->SetGuildRewardState(true);
	}

	CheckRefreshFDDayCron(deltaTime);
	pkOwnerPlayer->ResetDailyActivity();

	//GetCommonStatAsset().CheckReset(this, now);

	pkOwnerPlayer->SyncBuddyGrowthPackage();

	pkOwnerPlayer->ResetRefreshRewardTaskTimes();
	pkOwnerPlayer->ResetAcceptRewardTaskTimes();

	pkOwnerPlayer->ResetCollectBossJP();

	pkOwnerPlayer->GetQuickRaidAsset().ResetQuickRaidTimes(pkOwnerPlayer);

	pkOwnerPlayer->ResetEscortInfo();

	pkOwnerPlayer->GetVIPAsset().SetTodayGiftFlag(false);

	pkOwnerPlayer->GetRotaryTableAsset().UpdateRotaryTableVaildTimes(pkOwnerPlayer, 1);

	pkOwnerPlayer->NotifyPlayerLoginIn();

	pkOwnerPlayer->ResetGoalProcess();
	pkOwnerPlayer->ResetKillControllerAccountDailyCount();
	pkOwnerPlayer->ResetGameStoryJoinTimes();

	pkOwnerPlayer->ResetUsedVIPExtraRewardTimes();

	m_EntrustTask.ResetData( this );
	m_Lottery.ResetData( this );
	m_ChargeProfit.ResetData( this );
	m_SkyArenaData.Reset();
	pkOwnerPlayer->ResetHuanJingInvaildID();
	pkOwnerPlayer->ResetEveryDayTask();

	pkOwnerPlayer->GetRedPointAsset().ResetRedPointFlag(pkOwnerPlayer);
}

LC_ResourceAlert& LC_ServerPlayer::GetResourceAlert()
{
	return m_kResourceAlert;
}

ResultType LC_ServerPlayer::GetReward_ShunWangPlatform(int32_t type, int32_t param)
{
	if(!IsMainController())
	{
		return RE_FAIL;
	}

	LC_CommonStatAsset& kCmnStatAsset = GetCommonStatAsset();
	LC_CommonStatManager* pkMgr = LC_CommonStatManager::GetSingletonPtr();
	LC_CommonStatConfigDataEntry* pkConfig = pkMgr->GetCmnConfigDataEntry(type);
	if (NULL == pkConfig)
	{
		return RE_FAIL;
	}

	LC_CommonStatRewardDataEntry* pkCSRewardEntry = pkMgr->GetCmnRewardDataEntry(type, param);
	if (NULL == pkCSRewardEntry)
	{
		return RE_COMMON_STAT_LOGIN_BAD_KEY;
	}

	if (param > (int32_t)kCmnStatAsset.GetAccuCntShunWangPlatform(LC_CMN_STAT_TP_SHUNWANG_LOGIN_PLATFORM))
	{
		return RE_COMMON_STAT_LOGIN_DAYS_LACK;
	}

	LC_CommonStatEntry* pkCommonStatEntry = kCmnStatAsset.GetCommonStatEntry(type);
	if (NULL == pkCommonStatEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	if(pkCommonStatEntry->IsRewardReg(LC_ST_TP_FORERVER, pkCSRewardEntry->m_iSaveIndex))
	{
		return RE_COMMON_STAT_LOGIN_REWARDED;
	}

	if(pkConfig->m_iLoginPlatfromPage > 0 && !GetPlayerPlatformInfoAsset().CheckLoginPlatformPageMatch(pkConfig->m_iLoginPlatfromPage))
	{
		switch(pkConfig->m_iLoginPlatfromPage)
		{
		case YYP_SHUNWANG:
			return RE_ERROR_SHUNWANG_1;
		default:
			return RE_FAIL;
		}
	}

	//do the reward
	CommonStatOPCBArg opArg = CommonStatOPCBArg(GetID(), type, param, pkConfig, pkCSRewardEntry, NULL, (1 << LC_CMN_STAT_OP_DRAW), param);
	opArg.nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY24_OPERATE, OPERATE_LOGTYPE1);
	opArg.nLogParams.clear();
	opArg.nLogParams.push_back(param);
	opArg();

	return opArg.m_uiRslt;
}

ResultType LC_ServerPlayer::GetReward_ShunWangLoginReward(int32_t type, int32_t param)
{
	if(!IsMainController())
	{
		return RE_FAIL;
	}

	LC_CommonStatAsset& kCmnStatAsset = GetCommonStatAsset();
	LC_CommonStatManager* pkMgr = LC_CommonStatManager::GetSingletonPtr();
	LC_CommonStatConfigDataEntry* pkConfig = pkMgr->GetCmnConfigDataEntry(type);
	if (NULL == pkConfig)
	{
		return RE_FAIL;
	}

	LC_CommonStatRewardDataEntry* pkCSRewardEntry = pkMgr->GetCmnRewardDataEntry(type, param);
	if (NULL == pkCSRewardEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	LC_CommonStatEntry* pkCommonStatEntry = kCmnStatAsset.GetCommonStatEntry(type);
	if (NULL == pkCommonStatEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	if(pkCommonStatEntry->IsRewardReg(LC_ST_TP_FORERVER, pkCSRewardEntry->m_iSaveIndex))
	{ 
		return RE_COMMON_STAT_REWARDED;
	}

	if(pkConfig->m_iLoginPlatfromPage > 0 && !GetPlayerPlatformInfoAsset().CheckLoginPlatformPageMatch(pkConfig->m_iLoginPlatfromPage))
	{
		switch(pkConfig->m_iLoginPlatfromPage)
		{
		case YYP_SHUNWANG:
			return RE_ERROR_SHUNWANG_1;
		default:
			return RE_FAIL;
		}
	}

	//do the reward
	CommonStatOPCBArg opArg = CommonStatOPCBArg(GetID(), type, param, pkConfig, pkCSRewardEntry, NULL, (1 << LC_CMN_STAT_OP_DRAW), param);
	opArg.nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY25_OPERATE, OPERATE_LOGTYPE1);
	opArg.nLogParams.clear();
	opArg.nLogParams.push_back(param);
	opArg();

	return opArg.m_uiRslt;
}

ResultType LC_ServerPlayer::GetReward_ShunWangLevel(int32_t type, int32_t param)
{
	if(!IsMainController())
	{
		return RE_FAIL;
	}

	if (GetLevel() < param)
	{
		return RE_COMMON_STAT_LEVEL_LACK;
	}

	LC_CommonStatAsset& kCmnStatAsset = GetCommonStatAsset();
	LC_CommonStatManager* pkMgr = LC_CommonStatManager::GetSingletonPtr();
	LC_CommonStatConfigDataEntry* pkConfig = pkMgr->GetCmnConfigDataEntry(type);
	if (NULL == pkConfig)
	{
		return RE_FAIL;
	}

	LC_CommonStatRewardDataEntry* pkCSRewardEntry = pkMgr->GetCmnRewardDataEntry(type, param);
	if (NULL == pkCSRewardEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	LC_CommonStatEntry* pkCommonStatEntry = kCmnStatAsset.GetCommonStatEntry(type);
	if (NULL == pkCommonStatEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	if(pkCommonStatEntry->IsRewardReg(LC_ST_TP_FORERVER, pkCSRewardEntry->m_iSaveIndex))
	{
		return RE_COMMON_STAT_REWARDED;
	}

	if(pkConfig->m_iLoginPlatfromPage > 0 && !GetPlayerPlatformInfoAsset().CheckLoginPlatformPageMatch(pkConfig->m_iLoginPlatfromPage))
	{
		switch(pkConfig->m_iLoginPlatfromPage)
		{
		case YYP_SHUNWANG:
			return RE_ERROR_SHUNWANG_1;
		default:
			return RE_FAIL;
		}
	}

	//do the reward
	CommonStatOPCBArg opArg = CommonStatOPCBArg(GetID(), type, param, pkConfig, pkCSRewardEntry, NULL, (1 << LC_CMN_STAT_OP_DRAW), param);
	opArg();
	return opArg.m_uiRslt;
}

ResultType LC_ServerPlayer::GetReward_AntiWallowReward(int32_t type, int32_t param)
{
	if(!IsMainController())
	{
		return RE_FAIL;
	}

	LC_CommonStatAsset& kCmnStatAsset = GetCommonStatAsset();
	LC_CommonStatManager* pkMgr = LC_CommonStatManager::GetSingletonPtr();
	LC_CommonStatConfigDataEntry* pkConfig = pkMgr->GetCmnConfigDataEntry(type);
	if (NULL == pkConfig)
	{
		return RE_FAIL;
	}

	LC_CommonStatRewardDataEntry* pkCSRewardEntry = pkMgr->GetCmnRewardDataEntry(type, param);
	if (NULL == pkCSRewardEntry)
	{
		return RE_COMMON_STAT_LOGIN_BAD_KEY;
	}

	LC_CommonStatEntry* pkCommonStatEntry = kCmnStatAsset.GetCommonStatEntry(type);
	if (NULL == pkCommonStatEntry)
	{
		return RE_COMMON_STAT_BAD_KEY;
	}

	if(pkCommonStatEntry->IsRewardReg(LC_ST_TP_FORERVER, pkCSRewardEntry->m_iSaveIndex))
	{ 
		return RE_COMMON_STAT_REWARDED;
	}

	//do the reward
	CommonStatOPCBArg opArg = CommonStatOPCBArg(GetID(), type, param, pkConfig, pkCSRewardEntry, NULL, (1 << LC_CMN_STAT_OP_DRAW), param);
	opArg.nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY26_OPERATE, OPERATE_LOGTYPE1);
	opArg.nLogParams.clear();
	opArg.nLogParams.push_back(param);
	opArg();

	return opArg.m_uiRslt;
}

void LC_ServerPlayer::SyncGuildMapInfoToPlayer()
{
	const unique_id_impl& playerInstance = GetInstance();
	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogicPlaceVector* pkLogicMaps = pkWorldManager->GetMapLogicByRes(GetGlobalSetting.BestGuildMapID);
	if(NULL==pkLogicMaps)
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "SyncGuildMapInfoToPlayer-serverid:%d, c_id:%d, c_citizenship:%d, c_uid:%d r1", 
			GetGameServerID(), playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return;
	}

	LC_ServerMapLogicPlaceVector::iterator it=pkLogicMaps->begin();
	LC_ServerMapLogic_Place* pkBestGuildPlace = *it;
	if(NULL == pkBestGuildPlace)
	{
		GfxWriteLog( LOG_TAG_ERROR, LOG_SWITCH_ERROR, "SyncGuildMapInfoToPlayer-serverid:%d, c_id:%d, c_citizenship:%d, c_uid:%d r2", 
			GetGameServerID(), playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return;
	}
	pkBestGuildPlace->SyncWatchTowerInfoToPlayer(this);
}

void LC_ServerPlayer::ReceiveDailyReward_RongGuangYuanZheng()
{
	if(m_DailyReward == 1)
	{
		return;
	}

	int32_t rongGuangYuanZhengMaxMapId = GetFinishMaxMapIDByStoryID(GameStoryIDType_GloryExpedition);
	if(0 == rongGuangYuanZhengMaxMapId)
	{
		return;
	}

	CF_GloryExpeditionDailyRewards::DataEntry* pkData = CF_GloryExpeditionDailyRewards::GetSingletonPtr()->GetEntryPtr(rongGuangYuanZhengMaxMapId);
	if (NULL == pkData)
	{
		return;
	}

	MGPT_RLT_Daily_Reward resMsg;
	resMsg.m_nResult = RE_SUCCESS;
	if(RE_SUCCESS != LC_Helper::CanAddItemEx(this,pkData->_kReward, CIET_NONE))
	{
		resMsg.m_nResult = RE_ITEM_REWARD_PACKAGE_FULL;
	}
	else
	{
		//荣光远征每日奖励--埋点日志
		int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN9_OPERATE, OPERATE_LOGTYPE3);
		m_DailyReward = 1;

		PackOperateInfoList kItemOPs;
		LC_Helper::BuildAddItemOPs(pkData->_kReward, kItemOPs, SYS_FUNC_TP_DAILY_REWARD, rongGuangYuanZhengMaxMapId);
		LC_Helper::DoItemOPs(this, kItemOPs, SYS_FUNC_TP_DAILY_REWARD, rongGuangYuanZhengMaxMapId, true, nLogCode);
	}

	resMsg.m_DailyReward = m_DailyReward;
	SendMsgToClient(MGPT_RLT_RECEIVE_DAILY_REWARD, &resMsg);
}
int LC_ServerPlayer::_placeHolderMsg(MG_SyncPlaceHoldersInFOV& syncMsg, const CSObjectIdSet& rkIDList, float fCurrentTime, int iCount)
{
	int iPlaceHolderCount = iCount;
	LC_ServerPlaceHolder* pkPlaceHolder = NULL;
	CSObjectIdSet::const_iterator Iter, IterEnd;

	if (NULL==m_pkMap)
	{
		return 0;
	}

	if (MAX_PLACEHOLDER_LIST_SLOT <= iPlaceHolderCount)
	{
		return iPlaceHolderCount;
	}

	for(Iter = rkIDList.begin(), IterEnd = rkIDList.end(); Iter != IterEnd; ++Iter)
	{
		object_id_type lID = *Iter;
		pkPlaceHolder = (LC_ServerPlaceHolder*)(m_pkMap->FindObject(lID));
		if (NULL == pkPlaceHolder)
		{
			continue;
		}
		PlaceHolderEntry & akEntries = syncMsg.m_akPlaceHolderEntries[iPlaceHolderCount];
		if (pkPlaceHolder->GetPrivate() == true)
		{
			if (pkPlaceHolder->IsVisibleToMe(this->GetID()))
			{
				akEntries.m_lID			= lID;
				akEntries.m_lType			= pkPlaceHolder->GetType();
				akEntries.m_iCurrentLocationX	= pkPlaceHolder->GetCurrentLocation().x;
				akEntries.m_iCurrentLocationY	= pkPlaceHolder->GetCurrentLocation().y;
				akEntries.m_iZRotAngle			= (int16_t)pkPlaceHolder->GetSpawnZRotAngle();
				akEntries.m_lRewardType			= pkPlaceHolder->GetReward().m_eType;
				if (akEntries.m_lRewardType == LC_Reward::RT_ITEM)
				{
					akEntries.m_lRewardValue = pkPlaceHolder->GetReward().GetItemContext().GetBackPackValueByType(LPSFET_TYPE_ID);
				}
				else
				{
					akEntries.m_lRewardValue	= pkPlaceHolder->GetReward().m_Value;
				}
				akEntries.m_Identify	= 0;
				akEntries.m_isPrivate	= true;
				akEntries.m_playerID	= GetID();
				akEntries.m_EscapeTime = (int32_t)pkPlaceHolder->GetEsacpeTime(fCurrentTime);
				akEntries.m_FromLocationX = pkPlaceHolder->GetFromLocationPos().x;
				akEntries.m_FromLocationY = pkPlaceHolder->GetFromLocationPos().y;
			}
		}
		else
		{
			akEntries.m_lID			= lID;
			akEntries.m_lType			= pkPlaceHolder->GetType();
			akEntries.m_iCurrentLocationX	= pkPlaceHolder->GetCurrentLocation().x;
			akEntries.m_iCurrentLocationY	= pkPlaceHolder->GetCurrentLocation().y;
			akEntries.m_iZRotAngle			= (int16_t)pkPlaceHolder->GetSpawnZRotAngle();
			akEntries.m_lRewardType			= pkPlaceHolder->GetReward().m_eType;
			if (akEntries.m_lRewardType == LC_Reward::RT_ITEM)
			{
				akEntries.m_lRewardValue = pkPlaceHolder->GetReward().GetItemContext().GetBackPackValueByType(LPSFET_TYPE_ID);
			}
			else
			{
				akEntries.m_lRewardValue	= pkPlaceHolder->GetReward().m_Value;
			}
			akEntries.m_Identify	= 0;
			akEntries.m_isPrivate	= false;
			akEntries.m_EscapeTime = (int32_t)pkPlaceHolder->GetEsacpeTime(fCurrentTime);
			akEntries.m_FromLocationX = pkPlaceHolder->GetFromLocationPos().x;
			akEntries.m_FromLocationY = pkPlaceHolder->GetFromLocationPos().y;
			if(pkPlaceHolder->IsOwner(GetID()))
			{
				akEntries.m_playerID = GetID();
			}
			else
			{
				akEntries.m_playerID = 0;
			}
		}
		++iPlaceHolderCount;
		if (MAX_PLACEHOLDER_LIST_SLOT <= iPlaceHolderCount)
		{
			break;
		}
	}
	return iPlaceHolderCount; 
}

ResultType LC_ServerPlayer::SetRankTransferFailed(int mapResID)
{
	int mapID = GetMapResID();
	if(mapID != mapResID)
	{
		return RE_FAIL;
	}

	CF_WorldMapList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapResID);
	if(NULL==pkData || pkData->_iMapLogicType!=MT_REANSCRIPTION_RANK)
	{
		return RE_FAIL;
	}

	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* ptr = pkWorldManager->GetMapLogic(GetMapLogicID());
	if(NULL == ptr)
	{
		return RE_FAIL;
	}

	SetAttackFlag(false);
	ptr->SetPlaceState(PLACESTATE_FAIL);
	return RE_SUCCESS; 
}
int32_t LC_ServerPlayer::GetSkyArenaGroupNum()
{
	int32_t scoreValue = GetSkyArenaScoreValue();
	int ret = -1;
	for(CF_SkyArenaRank::DataEntryMapExternIterator kIt = CF_SkyArenaRank::GetSingletonPtr()->GetIterator(); kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_SkyArenaRank::DataEntry*pkTemplateData = kIt.PeekNextValuePtr();
		if(scoreValue >= pkTemplateData->_iScoreNeed)
		  ret = pkTemplateData->_iTeamNumber;
		else
		   break;
	}
	return ret;
}

int32_t LC_ServerPlayer::GetSkyArenaMaxStage()
{
	int32_t scoreValue = GetSkyArenaMaxScoreValue();
	int ret = 0;
	for(CF_SkyArenaRank::DataEntryMapExternIterator kIt = CF_SkyArenaRank::GetSingletonPtr()->GetIterator(); kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_SkyArenaRank::DataEntry*pkTemplateData = kIt.PeekNextValuePtr();
		if(scoreValue >= pkTemplateData->_iScoreNeed)
			ret = pkTemplateData->_iID;
		else
			break;
	}
	return ret;
}


ResultType LC_ServerPlayer::SetPlayStateEnd(int mapResID)
{
	int mapID = GetMapResID();
	if(mapID != mapResID)
		return RE_FAIL;

	CF_WorldMapList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapResID);
	if(NULL==pkData || pkData->_iMapLogicType!=MT_ARENA_SKY && pkData->_iMapLogicType!=MT_ARENA_SUMMIT_TEAM)
		return RE_FAIL;

	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* ptr = pkWorldManager->GetMapLogic(GetMapLogicID());
	if(NULL == ptr)
		return RE_FAIL;

	SetAttackFlag(false);
	ptr->SetPlaceState(PLACESTATE_END);
	return RE_SUCCESS; 
}

void LC_ServerPlayer::EnableBotManager(uint32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->EnableBotManager(time);
	}

	//m_BotInstanceMgr.Enable(time);
}

void LC_ServerPlayer::EnableNewVipBot(uint32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->EnableNewVipBot(time);
	}

	m_NewVIPReward.Enable(time);
}

void LC_ServerPlayer::SetNewVipState(bool state)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetNewVipState(state);
	}

	m_bNewVipState = state;
	SetNewVipLevel(0);
}

bool LC_ServerPlayer::GetNewVipState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetNewVipState();
	}

	return m_bNewVipState;
}

void LC_ServerPlayer::ResetBeginTime(uint32_t beginTime)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetBeginTime(beginTime);
	}

	m_NewVIPReward.ResetBeginTime(beginTime);
}

uint32_t LC_ServerPlayer::GetBeginTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetBeginTime();
	}

	return m_NewVIPReward.GetBeginTime();
}

void LC_ServerPlayer::ResetTimer_Normal(int index, uint32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetTimer_Normal(index, time);
	}

	m_NewVIPReward.ResetTimer_Normal(index, time);
}

uint32_t LC_ServerPlayer::GetTimer_Normal(int index)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetTimer_Normal(index);
	}

	return m_NewVIPReward.GetTimer_Normal(index);
}

int32_t LC_ServerPlayer::GetNewVipLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return -1;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetNewVipLevel();
	}

	return m_nNewVipLevel;
}

void LC_ServerPlayer::SetNewVipLevel(int32_t level)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetNewVipLevel(level);
	}

	m_nNewVipLevel = level;
	m_NewVIPReward.SetLevel(level);

	AchievementEvent kEvent;
	kEvent.SetNum(level);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_NEW_VIP, kEvent);

	if (m_nNewVipLevel>0)
	{
		LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_VIPLEVELUP);
			pkGameEvent->SetEventParam(EP_VIP_LEVEL_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_VIP_LEVEL, m_nNewVipLevel);			
			pkGameEvent->SetEventParam(EP_VIP_LEVEL_MAPID, GetMapResID());
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	pkOwnerPlayer->SetBroadCastFlag(LC_PlayerBase::E_DirtyFlag_ControllerProperty);
}

ResultType LC_ServerPlayer::AddNewVipReward(int vipLevel)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddNewVipReward(vipLevel);
	}

	//要求领奖的vip等级>现在的等级
	if(vipLevel >= m_nNewVipLevel)
	{
		return RE_FAIL;
	}

	bool tag = IsInVipRewardRecord(vipLevel);
	if(tag)
	{
		return RE_ALREADY_GET_REWARD;
	}

	CF_VipNew::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_VipNew>(vipLevel);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}
	//vip奖励--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(vipLevel);
	int32_t nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, VIP_OPERATE, OPERATE_LOGTYPE1);
	//背包满，不能领
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_sUpgradeReward, pkOwnerPlayer, SYS_FUNC_TP_NEWVIP_REWARD, vipLevel, mailTitle, mailDesc, false,false,false,nLogCode,nParams);
	if(RE_SUCCESS == res)
	{
		m_nVipRewardRecord.insert(vipLevel);
		SyncNewVipInfo();
	}

	return res;
}

void LC_ServerPlayer::SyncNewVipInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncNewVipInfo();
	}

	MG_Sync_NewVipInfo msg;
	msg.m_bState = GetNewVipState();
	if(msg.m_bState)
	{
		msg.m_nNewVipLevel = GetNewVipLevel();
		for(mem::set<int32_t>::iterator it=m_nVipRewardRecord.begin(); it!=m_nVipRewardRecord.end(); ++it)
		{
			msg.m_nVipRewardRecord.push_back(*it);
		}
	}
	SendMsgToClient(MGPT_SYNC_NEWVIPINFO, &msg);
}

bool LC_ServerPlayer::IsInVipRewardRecord(int vipLevel)
{
	return m_nVipRewardRecord.find(vipLevel) != m_nVipRewardRecord.end();
}

void LC_ServerPlayer::UpdateNewVipLevel()
{
	bool tag = GetNewVipState();
	if(!tag)
	{
		return;
	}

	int currentVipLevel = GetNewVipLevel();
	if(CheckCatchVipUpgradeCondition(currentVipLevel))
	{
		int newVipLevel = currentVipLevel+1;
		SetNewVipLevel(newVipLevel);
		m_NewVIPReward.SetLevel(newVipLevel);
		SyncNewVipInfo();
	}
}

bool LC_ServerPlayer::CheckCatchVipUpgradeCondition(int vipLevel)
{
	CF_VipNew::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_VipNew>(vipLevel);
	if(NULL == pkData)
	{
		return false;
	}

	const Utility::UT_SIMDataList& upgradeCondition = pkData->_sUpgradeTask;
	if(upgradeCondition.empty())
	{
		return false;
	}

	for(Utility::UT_SIMDataList::const_iterator it=upgradeCondition.begin(); it!=upgradeCondition.end(); ++it)
	{
		int taskID = it->ID();
		if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
		{
			return false;
		}
	}

	return true;
}

void LC_ServerPlayer::ResetGoalProcess()
{
	if(IsMainController())
	{
		bool tag = m_nGoalAsset.ResetGoalProcess();
		if(tag)
		{
			SyncGoalRecord();
		}
	}	
}

bool LC_ServerPlayer::DoGoalEvent(int type, GoalEvent* event)
{
	if(NULL == event)
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "event is null, c_cid:%d, c_citizenship:%d, c_uid:%d", instance.detail(), instance.catagory(), GetUserID());
		return false;
	}

	bool tag = m_nGoalAsset.OnGoalEvent(type, event);
	if(tag)
	{
		SyncGoalRecord();
	}

	return tag;
}

void LC_ServerPlayer::AddGoalAccountByType(int type, int64_t deltaValue, int param)
{
	if(deltaValue <= 0)
	{
		return;
	}

	mem::vector<int32_t> typeVec;
	CF_BestGuildGoal::DataEntryMapExternIterator kIter = CF_BestGuildGoal::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_BestGuildGoal::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(pkData->_Type == type)
		{
			if(param == 0)
			{
				typeVec.push_back(pkData->_lID);
			}
			else
			{
				for(Utility::UT_SIMDataList::iterator it=pkData->_Condition.begin(); it!=pkData->_Condition.end(); ++it)
				{
					if(it->IID() == param)
					{
						typeVec.push_back(pkData->_lID);
						break;
					}
				}
			}
		}
	}

	for(int i=0; i<typeVec.size(); ++i)
	{
		AddGoalAccountByID(typeVec[i], deltaValue);
	}	
}

void LC_ServerPlayer::AddGoalAccountByID(int id, int64_t deltaValue)
{
	if(deltaValue <= 0)
	{
		return;
	}

	m_nGoalAsset.AddGoalAccount(id, deltaValue);
	SyncGoalRecord();
}

void LC_ServerPlayer::SyncGoalRecord()
{
	MG_SyncGoalRecord msg;
	m_nGoalAsset.GetGoalRecord(msg.m_nGoalInfoRecord);

	SendMsgToClient(MGPT_SYNCGOALRECORD, &msg);
}

int32_t LC_ServerPlayer::GetKillControllerAccountDailyCount()
{
	return m_nKillControllerAccountDailyCount;
}

void LC_ServerPlayer::AddKillControllerAccountDailyCount(int num)
{
	if(num <= 0)
	{
		return;
	}

	m_nKillControllerAccountDailyCount += num;
}

void LC_ServerPlayer::ResetKillControllerAccountDailyCount()
{
	m_nKillControllerAccountDailyCount = 0;
}

void LC_ServerPlayer::ResetGameStoryJoinTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetGameStoryJoinTimes();
	}

	m_nGameStoryJoinTimes.clear();
	m_nJoinTimeStamp = 0;
}

void LC_ServerPlayer::UpdateGameStoryJoinTimes(int storyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateGameStoryJoinTimes(storyID);
	}

	int currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	bool tag = LC_Helper::CheckIsSameDay(m_nJoinTimeStamp, currentTime);
	if(!tag)
	{
		m_nGameStoryJoinTimes.clear();
		m_nJoinTimeStamp = currentTime;
	}

	mem::map<int32_t, int32_t>::iterator findIt = m_nGameStoryJoinTimes.find(storyID);
	if(findIt == m_nGameStoryJoinTimes.end())
	{
		m_nGameStoryJoinTimes.insert(std::make_pair(storyID, 1));
	}
	else
	{
		findIt->second += 1;
	}
}

int32_t LC_ServerPlayer::GetGameStoryJoinTimes(int storyID)
{	
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetGameStoryJoinTimes(storyID);
	}

	mem::map<int32_t, int32_t>::iterator findIt = m_nGameStoryJoinTimes.find(storyID);
	return findIt!=m_nGameStoryJoinTimes.end() ? findIt->second : 0;
}

ResultType LC_ServerPlayer::OpenResourceRetrieve()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->OpenResourceRetrieve();
	}

	ResultType res = m_nResourceRetrieveMgr.ActiveState();
	if(RE_SUCCESS == res)
	{
		SyncResourceRetrieveState();
	}
	return res;
}

ResultType LC_ServerPlayer::GetResourceRetrieverReward(int id, bool specialFind)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetResourceRetrieverReward(id, specialFind);
	}

	return m_nResourceRetrieveMgr.GetResourceRetrieverReward(id, specialFind);
}

void LC_ServerPlayer::SyncResourceRetrieverRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncResourceRetrieverRecord();
	}

	return m_nResourceRetrieveMgr.SyncResourceRetrieverRecord();
}

bool LC_ServerPlayer::ResourceRetrieveState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResourceRetrieveState();
	}

	return m_nResourceRetrieveMgr.IsActive();
}

void LC_ServerPlayer::SyncResourceRetrieveState()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncResourceRetrieveState();
	}

	m_nResourceRetrieveMgr.SyncState();
}

void LC_ServerPlayer::UpdateResourceRetrieveRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateResourceRetrieveRecord();
	}

	return m_nResourceRetrieveMgr.UpdateResourceRetrieveRecord();
}

uint32_t LC_ServerPlayer::GetAssignEscortTaskTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAssignEscortTaskTime();
	}

	return m_nAssignEscortTaskTime;
}

void LC_ServerPlayer::UpdateAssignEscortTaskTime(uint32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateAssignEscortTaskTime(time);
	}

	m_nAssignEscortTaskTime = time;
}

void LC_ServerPlayer::ResetEscortInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetEscortInfo();
	}

	m_nEscortTimes = 0;
	m_nRobbingTimes = 0;
	SyncRobbingTimes();
	SyncEscortTimes();
}

ResultType LC_ServerPlayer::CheckAcceptEscortTask()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckAcceptEscortTask();
	}

	ResultType res = RE_SUCCESS;
	int totalTime = GetGlobalSetting.EscortTimes+GetVIPAsset().GetProfitValue(GetGlobalSetting.EscortEnabledVIPID);
	if(GetEscortTimes()+1 > totalTime)
	{
		res = RE_ESCORT_TIME_NOT_ENOUGH;
	}

	return res;
}

int32_t LC_ServerPlayer::GetEscortTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetEscortTimes();
	}

	return m_nEscortTimes;
}

void LC_ServerPlayer::AddEscortTimes(int times)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddEscortTimes(times);
	}

	m_nEscortTimes += times;

	SyncEscortTimes();
}

ResultType LC_ServerPlayer::AddEscortReward(int EscortType, int npcID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddEscortReward(EscortType, npcID);
	}

	bool tag = CheckEscortVaild(EscortType, npcID);
	if(!tag)
	{
		return RE_FAIL;
	}

	ResultType res = TryAddEscortReward(EscortType, npcID);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	UpdateEscortNpcID(EscortType, npcID);
	return res;
}

void LC_ServerPlayer::AddEscortRecord(int EscortType, int npcID,  const StringType& name)
{
	if(EscortType!=ESCORT_ROBBING_SUCCESS && EscortType!=ESCORT_ROBBED_FAIL && EscortType!=ESCORT_ROBB_SUCCESS)
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddEscortRecord(EscortType, npcID, name);
	}

	if(ESCORT_ROBBING_SUCCESS == EscortType)
	{
		//劫镖剩余次数是否足够
		if(m_nRobbingTimes >= GetGlobalSetting.RobbingTimes)
		{
			MG_SyncEscortState msg;
			msg.m_nEscortType = EscortType;
			msg.m_nResult = RE_ESCORTING_TIMES_BE_LIMITED;
			SendMsgToClient(MGPT_SYNCESCORTSTATE, &msg);
			return;
		}
		else
		{
			AddRobbingTimes(1);
		}
	}

	mem::map<int, mem::vector<int32_t> >::iterator findIt = m_nEscortTypeNpcID.find(EscortType);
	if(findIt == m_nEscortTypeNpcID.end())
	{
		mem::vector<int32_t> EscortNpcID;
		EscortNpcID.push_back(npcID);
		m_nEscortTypeNpcID.insert(std::make_pair(EscortType, EscortNpcID));
	}
	else
	{
		findIt->second.push_back(npcID);
	}

	SyncEscortState(EscortType, npcID, name);
}

void LC_ServerPlayer::SyncEscortState(int EscortType, int npcID, const StringType& name)
{
	MG_SyncEscortState msg;
	msg.m_nEscortType = EscortType;
	msg.m_nNpcID = npcID;
	msg.m_nPlayer = TPSTR2STDSTR(name);

	SendMsgToClient(MGPT_SYNCESCORTSTATE, &msg);
}

void LC_ServerPlayer::SyncRobbingTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncRobbingTimes();
	}

	MG_SyncRobbingTimes msg;
	msg.m_nUsedRobbingTimes = m_nRobbingTimes;
	SendMsgToClient(MGPT_SYNCROBBINGTIMES, &msg);
}

void LC_ServerPlayer::SyncEscortTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncEscortTimes();
	}

	MG_SyncEscortTimes msg;
	msg.m_nUsedEscortTimes = GetEscortTimes();
	SendMsgToClient(MGPT_SYNCESCORTTIMES, &msg);
}

void LC_ServerPlayer::SendEscortRewardToMail()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SendEscortRewardToMail();
	}

	float percent = 1;
	StringType mailTitle;
	StringType mailContent;
	for(mem::map<int, mem::vector<int32_t> >::iterator it1=m_nEscortTypeNpcID.begin(); it1!=m_nEscortTypeNpcID.end(); ++it1)
	{
		switch(it1->first)
		{
		case ESCORT_ROBBING_SUCCESS:
			percent = GetGlobalSetting.RobbingPercent;
			mailTitle = "13;";
			mailContent = "14;";
			break;
		case ESCORT_ROBBED_FAIL:
			percent = GetGlobalSetting.RobbedPercent;
			mailTitle = "11;";
			mailContent = "12;";
			break;
		case ESCORT_ROBB_SUCCESS:
			percent = 1;
			mailTitle = "11;";
			mailContent = "12;";
			break;
		default:
			return;
		}

		for(mem::vector<int32_t>::iterator it2=it1->second.begin(); it2!=it1->second.end(); ++it2)
		{
			int charType = *it2;
			CF_EscortReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_EscortReward>(charType);
			if(NULL == pkData)
			{
				continue;
			}

			Utility::UT_SIMDataList itemList;
			switch(it1->first)
			{
			case ESCORT_ROBBING_SUCCESS:
				for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem3.begin(); it!=pkData->_sRewardItem3.end(); ++it)
				{
					itemList.push_back(*it);
				}
				break;
			case ESCORT_ROBBED_FAIL:
				for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem2.begin(); it!=pkData->_sRewardItem2.end(); ++it)
				{
					itemList.push_back(*it);
				}
				break;
			case ESCORT_ROBB_SUCCESS:
				for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem1.begin(); it!=pkData->_sRewardItem1.end(); ++it)
				{
					itemList.push_back(*it);
				}
				break;
			default:
				return;
			}

			UT_SIMDataInfo data;
			CF_EXPList::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_EXPList>(GetLevel());
			if(NULL != pkEntry)
			{
				data.SetItemInfo(SPEC_ITEM_TID_EXP, pkEntry->_lBaseXP*pkData->_iExp*percent, 0);
				itemList.push_back(data);

				data.clear();
				data.SetItemInfo(SPEC_ITEM_TID_BUDDY_EXP, pkEntry->_lBaseBuddyXP*pkData->_iBuddyExp*percent, 0);
				itemList.push_back(data);

				data.clear();
				data.SetItemInfo(SPEC_ITEM_TID_CASH, pkEntry->_lBaseCash*pkData->_iCash*percent, 0);
				itemList.push_back(data);
			}
			UT_ServerHelper::SendMailToPlayer(GetInstance(), mailTitle, mailContent, itemList);
		}
	}

	m_nEscortTypeNpcID.clear();
}

void LC_ServerPlayer::SyncEscortNpcState(int objectID, int charTypeID, int state)
{
	MG_SyncEscortNpcState msg;
	msg.m_nObjectID = objectID;
	msg.m_nCharTypeID = charTypeID;
	msg.m_nEscortNpcState = state;

	SendMsgToClient(MGPT_SYNCESCORTNPCSTATE, &msg);
}

void LC_ServerPlayer::SyncTaskFail(int taskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (pkOwnerPlayer == NULL)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncTaskFail(taskID);
	}

	MG_SyncTaskFail msg;
	msg.m_nTaskID = taskID;
	SendMsgToClient(MGPT_SYNCTASKFAIL, &msg);
}

bool LC_ServerPlayer::CheckEscortVaild(int EscortType, int npcID)
{
	mem::map<int, mem::vector<int32_t> >::iterator findIt = m_nEscortTypeNpcID.find(EscortType);
	if(findIt != m_nEscortTypeNpcID.end())
	{
		for(mem::vector<int32_t>::iterator it=findIt->second.begin(); it!=findIt->second.end(); ++it)
		{
			if(*it == npcID)
			{
				return true;
			}
		}
	}

	return false;
}

ResultType LC_ServerPlayer::TryAddEscortReward(int EscortType, int npcID)
{
	float percent = 1;
	int code = SYS_FUNC_TP_ESCORT_1;
	switch(EscortType)
	{
	case ESCORT_ROBBING_SUCCESS:
		percent = GetGlobalSetting.RobbingPercent;
		code = SYS_FUNC_TP_ESCORT_2;
		break;
	case ESCORT_ROBBED_FAIL:
		percent = GetGlobalSetting.RobbedPercent;
		code = SYS_FUNC_TP_ESCORT_3;
		break;
	case ESCORT_ROBB_SUCCESS:
		percent = 1;
		code = SYS_FUNC_TP_ESCORT_1;
		break;
	default:
		return RE_FAIL;
	}

	CF_EscortReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_EscortReward>(npcID);
	if(NULL == pkData)
	{
		return false;
	}

	Utility::UT_SIMDataList itemList;
	switch(EscortType)
	{
	case ESCORT_ROBBING_SUCCESS:
		for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem3.begin(); it!=pkData->_sRewardItem3.end(); ++it)
		{
			itemList.push_back(*it);
		}
		break;
	case ESCORT_ROBBED_FAIL:
		for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem2.begin(); it!=pkData->_sRewardItem2.end(); ++it)
		{
			itemList.push_back(*it);
		}
		break;
	case ESCORT_ROBB_SUCCESS:
		for(Utility::UT_SIMDataList::iterator it=pkData->_sRewardItem1.begin(); it!=pkData->_sRewardItem1.end(); ++it)
		{
			itemList.push_back(*it);
		}
		break;
	default:
		return false;
	}

	UT_SIMDataInfo data;
	CF_EXPList::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_EXPList>(GetLevel());
	if(NULL != pkEntry)
	{
		data.SetItemInfo(SPEC_ITEM_TID_EXP, pkEntry->_lBaseXP*pkData->_iExp*percent, 0);
		itemList.push_back(data);

		data.clear();
		data.SetItemInfo(SPEC_ITEM_TID_BUDDY_EXP, pkEntry->_lBaseBuddyXP*pkData->_iBuddyExp*percent, 0);
		itemList.push_back(data);

		data.clear();
		data.SetItemInfo(SPEC_ITEM_TID_CASH, pkEntry->_lBaseCash*pkData->_iCash*percent, 0);
		itemList.push_back(data);
	}

	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, itemList, this, code, npcID, mailTitle, mailDesc, false);
	return res;
}

void LC_ServerPlayer::UpdateEscortNpcID(int EscortType, int npcID)
{
	if(EscortType!=ESCORT_ROBBING_SUCCESS && EscortType!=ESCORT_ROBBED_FAIL && EscortType!=ESCORT_ROBB_SUCCESS)
	{
		return;
	}

	mem::map<int, mem::vector<int32_t> >::iterator findIt = m_nEscortTypeNpcID.find(EscortType);
	if(findIt != m_nEscortTypeNpcID.end())
	{
		for(mem::vector<int32_t>::iterator it=findIt->second.begin(); it!=findIt->second.end(); ++it)
		{
			if(*it == npcID)
			{
				it = findIt->second.erase(it);
				break;
			}
		}
	}
}

void LC_ServerPlayer::AddRobbingTimes(int times)
{
	m_nRobbingTimes += 1;
	SyncRobbingTimes();
}

bool LC_ServerPlayer::GetGuildRewardState() 
{
	return m_bGuildRewardIsVaild;
}

void LC_ServerPlayer::SetGuildRewardState(bool state) 
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetGuildRewardState(state);
	}

	if(!IsExistGuild())
	{
		return;
	}

	if(m_bGuildRewardIsVaild == state)
	{
		return;
	}

	bool send = state ? false : true;
	if(state)
	{
		if(GetDailyFlag())
		{
			send = true;
			SetDailyFlag(false);
		}
		else if(GetGuildRewardFlag())
		{
			send = true;
		}		
	}

	if(send)
	{
		m_bGuildRewardIsVaild = state;
		SyncGuildRewardState();
	}	
}

void LC_ServerPlayer::SetBuffLoginFlag(bool login)
{
	m_bLoginBuff = login;
}

bool LC_ServerPlayer::GetBuffLoginFlag()
{
	return m_bLoginBuff;
}

bool LC_ServerPlayer::GetGuildRewardFlag()
{
	return m_bGuildRewardFlag;
}

void LC_ServerPlayer::SetGuildRewardFlag(bool flag)
{
	m_bGuildRewardFlag = flag;
}

int32_t LC_ServerPlayer::ModifyDailyActivity(int32_t val)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return 0;

	if(!IsMainController())
	{
		return pkOwnerPlayer->ModifyDailyActivity(val);
	}

	if(0 == val)
	{
		return m_nDailyActivity;
	}

	m_nDailyActivity+= val;

	syncDailyActivity();

	return m_nDailyActivity;
}

ResultType LC_ServerPlayer::ReceiveDailyAcivityRewards(int32_t rewardID)
{
	int size = m_nDailyActivityRewardID.size();
	for(int i=0; i<size; ++i)
	{
		int id = m_nDailyActivityRewardID[i];
		if(rewardID == id)
		{
			return RE_DAILY_ACTIVITY_REWARD_HAS_RECEIVED;
		}
	}

	CF_DailyActivity::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_DailyActivity>(rewardID);
	if(NULL == pkData)
		return RE_FAIL;

	if(m_nDailyActivity < pkData->_lLiveness)
		return RE_DAILY_ACTIVITY_NOT_ENOUGH;

	if(!pkData->_sGiftInfos.empty())
	{
		//名号任务奖励--埋点日志
		vector<int> nParams;
		nParams.clear();
		nParams.push_back(rewardID);
		int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, MINGHAO_OPERATE, OPERATE_LOGTYPE2);
		Utility::UT_SIMDataList items;
		Utility::ParseFmtString2DataIFs(pkData->_sGiftInfos, items);
		UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, items, this, SYS_FUNC_TP_TASK_DAILYACTIVITY, pkData->_iLevel, "202;", "203;",true,false,false,nLogCode, nParams);
	}

	m_nDailyActivityRewardID.push_back(rewardID);

	return RE_SUCCESS;
}

void LC_ServerPlayer::syncDailyActivity()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->syncDailyActivity();
	}

	MG_SyncDailyActivity syncMsg;
	syncMsg.m_nDailyActivity = m_nDailyActivity;
	for(int i=0; i<m_nDailyActivityRewardID.size(); ++i)
	{
		syncMsg.m_nDailyActivityRewardID.push_back(m_nDailyActivityRewardID[i]);
	}

	SendMsgToClient(MGPT_SYNC_DAILY_ACTIVITY, &syncMsg);
}

void LC_ServerPlayer::ResetDailyActivity()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetDailyActivity();
	}

	m_nDailyActivity = 0;
	m_nDailyActivityRewardID.clear();

	syncDailyActivity();
}

void LC_ServerPlayer::InitActivateStarVein()
{

}

ResultType LC_ServerPlayer::ActivateStarVein(int32_t starVeinID)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result;

	if(!IsMainController())
	{
		return pkOwnerPlayer->ActivateStarVein(starVeinID);
	}

	CF_StarVeinList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_StarVeinList>(starVeinID);
	if(pkData == NULL)
	{
		return result;
	}

	result = CanActivateStarVein(starVeinID, pkData->PreStarVein);
	if(RE_SUCCESS != result)
	{
		return result;
	}

	if(pkData->ChallengeBoss)
	{
		//判断是否通关了副本
		if(!GetRaidAsset()->FindRaid(pkData->MapID))
		{
			return RE_NOT_KILL_STARVEIN_BOSS;
		}
	}
	else
	{
		//检测货币
		Utility::UT_SIMDataList& cost = pkData->StarVeinCost;
		bool flg = false;
		if(!cost.empty())
		{
			flg = pkOwnerPlayer->IsCashEnough((MoneyType)(cost[0].ParamA()), (CashType)(cost[0].IID()));
			if(!flg)
			{
				return RE_ACTIVE_STARVEIN_CASH_NOT_ENOUGH;
			}
		}

		if(!cost.empty())
		{
			//扣货币
			flg = pkOwnerPlayer->ReduceCash((MoneyType)(cost[0].ParamA()), (CashType)(cost[0].IID()), SYS_FUNC_TP_ACTIVATE_STARVEIN_CONSUME_CASH, starVeinID);
			if(!flg)
			{
				return RE_ACTIVE_STARVEIN_CASH_NOT_ENOUGH;
			}
		}		
	}

	AddStarVein(starVeinID);
	return result;
}

ResultType LC_ServerPlayer::GetStarVeinReward(int32_t id)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetStarVeinReward(id);
	}

	CF_StarVeinGoalList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_StarVeinGoalList>(id);
	if(pkData == NULL)
	{
		return result;
	}

	result = CanGetStarVeinReward(id, pkData->PreGoal);
	if(RE_SUCCESS != result)
	{
		return result;
	}

	int starVeinGoldType = pkData->GoalType;
	switch(starVeinGoldType)
	{
	case LC_STARVEIN_TYPE_BUDDY_STAR:
		result = CheckBuddyStarLevel(pkData->GoalCondition);
		break;
	case LC_STARVEIN_TYPE_BUDDY_LEVEL:
		result = CheckBuddyLevel(pkData->GoalCondition);
		break;
	case LC_STARVEIN_TYPE_BUDDY_SKILL_LEVEL:
		result = CheckBuddySkillLevel(pkData->GoalCondition);
		break;
	case LC_STARVEIN_TYPE_BUDDY_EQUIPSLOT_LEVEL:
		result = CheckBuddyEquipSlotLevel(pkData->GoalCondition);
		break;
	default:
		break;
	}

	if(RE_SUCCESS == result)
	{
		//领奖
		StringType mailTitle;
		StringType mailDesc;
		result = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_sReward, pkOwnerPlayer, SYS_FUNC_TP_GET_STARVEIN_GOLD_REWARD, id, mailTitle, mailDesc, false);
		if(RE_SUCCESS == result)
		{
			AddStarVeinGold(id);
		}
	}

	return result;
}

void LC_ServerPlayer::SyncActivateStarVein()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncActivateStarVein();
	}

	MG_SyncActivateStarVein syncMsg;
	for(int i=0; i<m_nActivateStarVeinID.size(); ++i)
	{
		syncMsg.m_nActivateStarVeinID.push_back(m_nActivateStarVeinID[i]);
	}

	SendMsgToClient(MGPT_SYNC_ACTIVATE_STARVEIN, &syncMsg);
}

void LC_ServerPlayer::SyncStarVeinGoalRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncStarVeinGoalRecord();
	}

	MG_SyncStarVeinGoalRecord syncMsg;
	for(int i=0; i<m_nStarVeinGoalID.size(); ++i)
	{
		syncMsg.m_nStarVeinGoalID.push_back(m_nStarVeinGoalID[i]);
	}

	SendMsgToClient(MGPT_SYNC_STARVEIN_GOAL_RECORD, &syncMsg);
}

int32_t LC_ServerPlayer::GetAllBuddyLevel()
{
	int allBuddyLevel = 0;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return allBuddyLevel;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAllBuddyLevel();
	}

	BuddyInstance* pInstance = NULL;
	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		pInstance = it->second;
		if (pInstance == NULL)
			continue;

		allBuddyLevel += pInstance->GetLevel();
	}
	return allBuddyLevel;
}

int32_t LC_ServerPlayer::GetAllBuddyStarLevel()
{
	int allBuddyStarLevel = 0;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return allBuddyStarLevel;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAllBuddyStarLevel();
	}

	BuddyInstance* pInstance = NULL;
	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		pInstance = it->second;
		if (pInstance == NULL)
			continue;

		allBuddyStarLevel += pInstance->GetStarLevel();
	}
	return allBuddyStarLevel;
}

int32_t LC_ServerPlayer::GetFinishMainTaskID()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetFinishMainTaskID();
	}

	return m_nFinishMainTaskID;
}

void LC_ServerPlayer::SetFinishMainTaskID(int32_t finishMainTaskID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetFinishMainTaskID(finishMainTaskID);
	}

	m_nFinishMainTaskID = finishMainTaskID;

	SyncFinishMainTask();

	UpdateRankUserValueByRankType(Rank_Type_FinishMainTaskID);
}

void LC_ServerPlayer::SyncFinishMainTask()
{
	MG_SyncFinishMainTaskID msg;
	msg.m_nFinishMainTaskID = GetFinishMainTaskID();
	SendMsgToClient(MGPT_SYNCFINISHMAINTASKID, &msg);
}

int32_t LC_ServerPlayer::GetRankTypeByRankGameStory(int32_t storyID)
{
	int32_t rankType = -1;
	switch(storyID)
	{
	case GameStoryIDType_Exp:
		rankType = Rank_Type_ExpTranscriptCount;
		break;
	case GameStoryIDType_jinjie2:
		rankType = Rank_Type_WuXiaShengTangCount;
		break;
	case GameStoryIDType_jinjie1:
		rankType = Rank_Type_MingYuShenYuanCount;
		break;
	case GameStoryIDType_jinjie3:
		rankType = Rank_Type_MiYuanHuiLangCount;
		break;
	case GameStoryIDType_DailyDungeons:
		rankType = Rank_Type_ZhiRanJiaoTuCount;
		break;
	case GameStoryIDType_Sub1:
		rankType = Rank_Type_SubVehicleCount;
		break;
	case GameStoryIDType_Sub2:
		rankType = Rank_Type_SubDevaEyeCount;
		break;
	case GameStoryIDType_Sub3:
		rankType = Rank_Type_SubMuhunCount;
		break;
	case GameStoryIDType_GloryExpedition:
		rankType = Rank_Type_RongGuangYuanZhengCount;
		break;
	default:
		break;
	}
	return rankType;
}

int32_t LC_ServerPlayer::GetMapFinishCountFromGameStoryID(int32_t storyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetMapFinishCountFromGameStoryID(storyID);
	}

	mem::map<int32_t, mem::set<int32_t> >::iterator findIt = m_nFinishGameStoryMapID.find(storyID);
	if(findIt == m_nFinishGameStoryMapID.end())
	{
		return 0;
	}

	return findIt->second.size();
}

int32_t LC_ServerPlayer::GetFinishMaxMapIDByStoryID(int32_t stroyID)
{
	int32_t rankType = GetRankTypeByRankGameStory(stroyID);
	if(-1 == rankType)
	{
		return 0;
	}

	mem::map<int32_t, mem::set<int32_t> >::iterator findIt = m_nFinishGameStoryMapID.find(stroyID);
	if(findIt==m_nFinishGameStoryMapID.end() || findIt->second.empty())
	{
		return 0;
	}

	mem::set<int32_t>::reverse_iterator it = findIt->second.rbegin();
	return it==findIt->second.rend() ? 0 :*it;
}

void LC_ServerPlayer::UpdateFinishCountFromGameStoryID(int32_t mapID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateFinishCountFromGameStoryID(mapID);
	}

	CF_WorldMapList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(mapID);
	if(NULL == pkData)
	{
		return;
	}

	int storyID = pkData->_iStoryID;
	int32_t rankType = GetRankTypeByRankGameStory(storyID);
	if(-1 != rankType)
	{
		mem::map<int32_t, mem::set<int32_t> >::iterator findIt = m_nFinishGameStoryMapID.find(storyID);
		if(findIt == m_nFinishGameStoryMapID.end())
		{
			mem::set<int32_t> mapIDs;
			mapIDs.insert(mapID);
			m_nFinishGameStoryMapID.insert(std::make_pair(storyID, mapIDs));
		}
		else
		{
			findIt->second.insert(mapID);
		}

		UpdateRankUserValueByRankType(rankType);
	}
}

bool LC_ServerPlayer::IsInActivateStarVeinRecord(int32_t starVeinID)
{
	return m_nActivateStarVeinID.end() != find(m_nActivateStarVeinID.begin(), m_nActivateStarVeinID.end(), starVeinID);
}

bool LC_ServerPlayer::IsInStarVeinGoldRecord(int32_t goldID)
{
	return m_nStarVeinGoalID.end() != find(m_nStarVeinGoalID.begin(), m_nStarVeinGoalID.end(), goldID);
}

void LC_ServerPlayer::AddStarVein(int starVeinID)
{
	if(!IsInActivateStarVeinRecord(starVeinID))
	{
		m_nActivateStarVeinID.push_back(starVeinID);
	}
}

void LC_ServerPlayer::AddStarVeinGold(int32_t starVeinGoldID)
{
	if(!IsInStarVeinGoldRecord(starVeinGoldID))
	{
		m_nStarVeinGoalID.push_back(starVeinGoldID);
	}
}

ResultType LC_ServerPlayer::CanActivateStarVein(int currentID, int preID)
{
	if(IsInActivateStarVeinRecord(currentID))
	{
		return RE_STARVEIN_ALREADY_BE_ACTIVATE;
	}

	if(0 == preID)
	{
		return RE_SUCCESS;
	}

	if(!IsInActivateStarVeinRecord(preID))
	{
		return RE_PRE_STARVEIN_NOT_ACTIVATE;
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::CanGetStarVeinReward(int currentID, int preID)
{
	if(IsInStarVeinGoldRecord(currentID))
	{
		return RE_STARVEIN_GOLD_REWARD_HAS_GET;
	}

	if(0 == preID)
	{
		return RE_SUCCESS;
	}

	if(!IsInStarVeinGoldRecord(preID))
	{
		return RE_PRE_STARVEIN_GOLD_REWARD_NOT_GET;
	}

	return RE_SUCCESS;
}

ResultType	LC_ServerPlayer::CheckBuddyStarLevel(int conditions)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckBuddyStarLevel(conditions);
	}

	int allBuddyStarLevel = GetAllBuddyStarLevel();
	result = allBuddyStarLevel>=conditions ? RE_SUCCESS : RE_FAIL;
	return result;
}

ResultType LC_ServerPlayer::CheckBuddyLevel(int conditions)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckBuddyLevel(conditions);
	}

	int allBuddyLevel = GetAllBuddyLevel();
	result = allBuddyLevel>=conditions ? RE_SUCCESS : RE_FAIL;
	return result;
}

ResultType	LC_ServerPlayer::CheckBuddySkillLevel(int conditions)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckBuddySkillLevel(conditions);
	}

	int allBuddySkillLevel = 0;
	BuddyInstance* pInstance = NULL;

	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		pInstance = it->second;
		if (pInstance == NULL)
			continue;

		LC_SkillAsset* pkSkillAsset = pInstance->GetSkillAsset();
		if(NULL == pkSkillAsset)
			continue;

		LC_SkillAssetData* pkSkillAssetData = pkSkillAsset->GetSkillAssetData();

		const LC_SkillAssetEntryMap& pkSkillMap = pkSkillAssetData->GetSkillAssetEntryMap();

		for(LC_SkillAssetEntryMap::const_iterator it=pkSkillMap.begin(); it!=pkSkillMap.end(); ++it)
		{
			allBuddySkillLevel += pkSkillAssetData->GetSkillLevel(it->first);
		}
	}

	result = allBuddySkillLevel>=conditions ? RE_SUCCESS : RE_FAIL;
	return result;
}

ResultType	LC_ServerPlayer::CheckBuddyEquipSlotLevel(int conditions)
{
	ResultType result = RE_FAIL;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return result; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckBuddySkillLevel(conditions);
	}

	BuddyInstance* pkBuddy = NULL;
	int totalEquilSlotLevel = 0;
	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		pkBuddy = it->second;
		if (pkBuddy == NULL)
		{
			continue;
		}

		totalEquilSlotLevel += pkBuddy->GetEquipSlotTotalLevel();
	}

	result = totalEquilSlotLevel>=conditions ? RE_SUCCESS : RE_FAIL;
	return result;
}

void LC_ServerPlayer::CheckRefreshFDDayCron(int32_t deltaTime)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckRefreshFDDayCron();
	}

	if(deltaTime <= 0)
	{
		return;
	}

	LC_VIPAsset& kVIPAsset = GetVIPAsset();
	uint32_t uiPreLvl = kVIPAsset.GetFDepositLevel();
	if(uiPreLvl>=1 && m_nFDFlag>-1 && m_nFDFlag<8)
	{
		if(m_nFDFlag+deltaTime<8)
		{
			m_nFDFlag += deltaTime;
		}
		else
		{
			m_nFDFlag = -1;
		}
		SyncFDDay();
	}
}

int32_t LC_ServerPlayer::GetNextFDTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetNextFDTime();
	}

	LC_ServerLogicManager* pkLogicManager = SERVER_GET_LOGIC_MANAGER();
	int32_t FDCronID = pkLogicManager->GetFDChargeCronID();

	UT_TimerManager* pkTimerMgr = UT_TimerManager::GetSingletonPtr();
	int64_t time = pkTimerMgr->GetTriTimestamp_Plus(FDCronID);

	return (int32_t)(time/1000);
}

ResultType LC_ServerPlayer::CanGetFirstDailyChargeReward()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL; 

	if(!IsMainController())
	{
		return pkOwnerPlayer->CanGetFirstDailyChargeReward();
	}

	int32_t day = GetFDDay();
	if(day < 1)
		return RE_FAIL;

	FirstDailyChargeRewardsMap::iterator it = m_firstDailyChargeRewards.find(day);
	if(it == m_firstDailyChargeRewards.end())
		return RE_SUCCESS;

	return it->second.tag == false ? RE_SUCCESS : RE_FAIL;
}

int32_t LC_ServerPlayer::GetFDDay()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetFDDay();
	}

	return m_nFDFlag;
}


void LC_ServerPlayer::SyncFDDay()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncFDDay();
	}

	if(m_nFDFlag==0)
		return;

	MG_SyncFDDay syncMsg;
	syncMsg.m_dayFlag = m_nFDFlag;
	SendMsgToClient(MGPT_SYNC_FD_DAY, &syncMsg);
}

void LC_ServerPlayer::SyncFDRewardRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncFDRewardRecord();
	}

	MG_SyncFDRewardRecord syncMsg;
	for(FirstDailyChargeRewardsMap::iterator it=m_firstDailyChargeRewards.begin(); it!=m_firstDailyChargeRewards.end(); ++it)
	{
		PS_FirstDailyChargeReward reward;
		reward.tag = it->second.tag;
		reward.day = it->second.day;
		reward.freeReward = it->second.freeReward;

		std::vector<PS_RewardRecord>& discountReward = it->second.disCountRewards;
		for(int i=0; i<discountReward.size(); ++i)
		{
			PS_RewardRecord record;
			record.disCountRewardID = discountReward[i].disCountRewardID;
			record.disCountRewardTimes = discountReward[i].disCountRewardTimes;

			reward.disCountRewards.push_back(record);
		}

		syncMsg.m_FDRewardRecord.push_back(reward);
	}

	SendMsgToClient(MGPT_SYNC_FD_CHARGE_REWARD, &syncMsg);
}

int LC_ServerPlayer::GetBuddyStarLevel()
{
	if (m_pAssignedBuddyInstance == NULL)
		return 0;
	return m_pAssignedBuddyInstance->GetStarLevel();
}

ResultType LC_ServerPlayer::GetFreeReward(uint32_t day, uint32_t RewarsID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetFreeReward(day, RewarsID);
	}

	if(!CheckCanReward(day, RewarsID, true))
	{
		return RE_FREE_REWARD_HAS_RECEIVE;
	}

	CF_FirstDailyCharge::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_FirstDailyCharge>(RewarsID);
	if(pkData == NULL)
		return RE_FAIL;

	Utility::UT_SIMDataList items;
	Utility::ParseFmtString2DataIFs(pkData->_sItem, items);
	//神选魔盒
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(day);
	nParams.push_back(RewarsID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY23_OPERATE, OPERATE_LOGTYPE1);
	StringType title;
	StringType desc;
	ResultType res =  UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, items, this, SYS_FUNC_TP_VIP_FDEPOSIT_FREE_REWARD, day, title, desc, false, false,false, nLogCode,nParams);
	if(RE_SUCCESS == res)
	{
		AddFDReward(day, RewarsID, true);
	}

	return res;
}

ResultType LC_ServerPlayer::GetDisCountReward(uint32_t day, uint32_t RewarsID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetDisCountReward(day, RewarsID);
	}

	if(!CheckCanReward(day, RewarsID, false))
	{
		return RE_FAIL;
	}

	CF_FirstDailyCharge::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_FirstDailyCharge>(RewarsID);
	if(NULL == pkData)
		return RE_FAIL;

	ResultType res = LC_Helper::CheckCashMap(this, pkData->_sActualPriceList);
	if (RE_SUCCESS != res)
	{
		return res;
	}

	Utility::UT_SIMDataList items;
	Utility::ParseFmtString2DataIFs(pkData->_sShopItem, items);
	res = LC_Helper::CanAddItemEx(this, items, CIET_NONE);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//神选魔盒
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(day);
	nParams.push_back(RewarsID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY23_OPERATE, OPERATE_LOGTYPE2);
	StringType title;
	StringType desc;
	res =  UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, items, this, SYS_FUNC_TP_VIP_FDEPOSIT_DISCOUNT_REWARD, day, title, desc, false, false,false, nLogCode,nParams);
	if(RE_SUCCESS == res)
	{
		LC_Helper::PayCashMap(this, pkData->_sActualPriceList, SYS_FUNC_TP_VIP_FDEPOSIT_DISCOUNT_REWARD, 0,1,false, nLogCode);
		AddFDReward(day, RewarsID, false);
	}

	return res;
}

bool LC_ServerPlayer::CheckCanReward(uint32_t day, uint32_t RewarsID, bool free)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return false;

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckCanReward(day, RewarsID, free);
	}

	FirstDailyChargeRewardsMap::iterator it = m_firstDailyChargeRewards.find(day);
	if(it==m_firstDailyChargeRewards.end())
		return true;

	if(it->second.tag)
		return false;

	CF_FirstDailyCharge::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_FirstDailyCharge>(RewarsID);
	if(NULL == pkData)
		return false;

	if(day != pkData->_iDay)
		return false;

	if(free)
	{
		return it->second.freeReward == 0? true : false;
	}
	else
	{
		std::vector<PS_RewardRecord>& record = it->second.disCountRewards;
		for(int i=0; i<record.size(); ++i)
		{
			if(record[i].disCountRewardID == RewarsID && record[i].disCountRewardTimes >= pkData->_iTime)
			{
				return false;
			}
		}
	}

	return true;
}

void LC_ServerPlayer::AddFDReward(uint32_t day, uint32_t RewardID, bool free)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddFDReward(day, RewardID, free);
	}

	FirstDailyChargeRewardsMap::iterator it = m_firstDailyChargeRewards.find(day);
	if(free)
	{
		if(it == m_firstDailyChargeRewards.end())
		{
			PS_FirstDailyChargeReward reward;
			reward.tag = false;
			reward.day = day;
			reward.freeReward = RewardID;

			m_firstDailyChargeRewards.insert(std::make_pair(day, reward));
		}
		else
		{
			it->second.freeReward = RewardID;
		}
	}
	else
	{
		if(it == m_firstDailyChargeRewards.end())
		{
			PS_FirstDailyChargeReward reward;
			reward.tag = false;
			reward.day = day;

			PS_RewardRecord record;
			record.disCountRewardID = RewardID;
			record.disCountRewardTimes = 1;
			reward.disCountRewards.push_back(record);

			m_firstDailyChargeRewards.insert(std::make_pair(day, reward));
		}
		else
		{
			bool add = false;
			std::vector<PS_RewardRecord>& records = it->second.disCountRewards;
			for(int i=0; i<records.size(); ++i)
			{
				if(records[i].disCountRewardID == RewardID)
				{
					add = true;
					records[i].disCountRewardTimes += 1;
				}
			}

			if(!add)
			{
				PS_RewardRecord record;
				record.disCountRewardID = RewardID;
				record.disCountRewardTimes = 1;
				records.push_back(record);
			}
		}
	}

	CheckRewardAll(day);
	SyncFDRewardRecord();
}

void LC_ServerPlayer::CheckRewardAll(uint32_t day)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckRewardAll(day);
	}

	FirstDailyChargeRewardsMap::iterator it = m_firstDailyChargeRewards.find(day);
	if(it == m_firstDailyChargeRewards.end())
		return;

	PS_FirstDailyChargeReward rewards;
	CF_FirstDailyCharge::DataEntryMapExternIterator kIter = CF_FirstDailyCharge::GetSingletonPtr()->GetIterator();
	while(kIter.HasMoreElements())
	{
		CF_FirstDailyCharge::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		if(pkEntry->_iDay == day)
		{
			if(pkEntry->_bType == 0)
			{
				rewards.freeReward = pkEntry->_iID;
			}
			else
			{
				PS_RewardRecord reward;
				reward.disCountRewardID = pkEntry->_iID;
				reward.disCountRewardTimes = pkEntry->_iTime;

				rewards.disCountRewards.push_back(reward);
			}
		}
		kIter.MoveNext();
	}

	if(it->second.freeReward != rewards.freeReward)
		return;

	std::vector<PS_RewardRecord>& currentDisCountRewards = it->second.disCountRewards;
	std::vector<PS_RewardRecord>& allDisCountRewards = rewards.disCountRewards;
	if(allDisCountRewards.size() != currentDisCountRewards.size())
		return;

	int count = 0;
	for(int i=0; i<allDisCountRewards.size(); ++i)
	{
		bool tag = false;
		uint32_t id = allDisCountRewards[i].disCountRewardID;
		uint32_t times = allDisCountRewards[i].disCountRewardTimes;

		for(int j=0; j<currentDisCountRewards.size(); ++j)
		{
			if(id ==currentDisCountRewards[j].disCountRewardID && times==currentDisCountRewards[j].disCountRewardTimes)
			{
				++count;
				tag = true;
				break;
			}
		}

		if(!tag)
		{
			return;
		}
	}

	if(count == allDisCountRewards.size())
	{
		it->second.tag = true;
		if(day == 7)
		{
			m_nFDFlag = -1;
			SyncFDDay();
		}
	}
}

int LC_ServerPlayer::GetSkillBookCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return 0;

	return pkOwnerPlayer->GetSkillBookAsset().GetSkillBookCount();
}

void LC_ServerPlayer::SyncSkillBookSlotInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncSkillBookSlotInfo();
	}

	MG_SyncSkillBookSlotInfo syncMsg;
	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		for(int j=0; j<m_nSkillBookSlotDataInfo[i].size(); ++j)
		{
			syncMsg.m_nSkillBookSlotDataInfo[i].push_back(m_nSkillBookSlotDataInfo[i][j]);
		}		
	}

	SendMsgToClient(MGPT_SYNC_SKILLBOOK_SLOTINFO, &syncMsg);
}

ResultType LC_ServerPlayer::ActivateSkillBook(int32_t skillBookID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return res;

	if(!IsMainController())
	{
		return pkOwnerPlayer->ActivateSkillBook(skillBookID);
	}

	CF_SkillBookInitAttribute::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SkillBookInitAttribute>(skillBookID);
	if(NULL == pkData)
	{
		return res;
	}

	//圣痕是否可以激活
	res = GetSkillBookAsset().CheckOpenSkillBook(skillBookID);
	if(res != RE_SUCCESS)
	{
		return res;
	}

	//vip等级是否够
	int VIPLevel = GetVIPLevel();
	if(VIPLevel < pkData->_VIPLevel)
	{
		return RE_VIP_LEVEL_LACK;
	}

	//指挥官等级是否足够
	int32_t playerLevel = GetCommanderLevel();	
	if(playerLevel < pkData->_UnlockLevel)
	{
		return RE_PLAYER_LEVEL_TOO_LOW;
	}

	//buddy总星级是否达到
	int32_t allBuddyStarLevel = GetAllBuddyStarLevel();
	if(allBuddyStarLevel < pkData->_UnlockHeroStars)
	{
		return RE_BUDDY_STARLEVEL_TOO_LOW;
	}

	//钱是否够
	res = LC_Helper::CheckCashMap(this, pkData->_Cost);
	if(res != RE_SUCCESS)
	{
		return res;
	}
	//激活圣痕
	res = GetSkillBookAsset().OpenSkillBook(skillBookID);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//扣钱
	res = LC_Helper::PayCashMap(this, pkData->_Cost, SYS_FUNC_TP_SKILLBOOK_ACTIVATE, skillBookID,1,false);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	return res;
}

ResultType LC_ServerPlayer::UnlockSkillBookSlot(int32_t index, int32_t slotID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return res;

	if(!IsMainController())
	{
		return pkOwnerPlayer->UnlockSkillBookSlot(index, slotID);
	}

	CF_SkillBookUnlock::DataEntryMapExternIterator it = CF_SkillBookUnlock::GetSingletonPtr()->GetIterator();
	CF_SkillBookUnlock::DataEntry* pkData = NULL;
	while(it.HasMoreElements())
	{
		pkData = it.PeekNextValuePtr();
		if (pkData->_index==index && pkData->_slotID==slotID)
		{
			break;
		}
		it.MoveNext();
	}

	if(NULL == pkData)
	{
		return res;
	}

	//指挥官等级是否够
	int32_t nLevel = GetCommanderLevel();
	if(nLevel < pkData->_UnlockLevel)
	{
		return RE_PLAYER_LEVEL_TOO_LOW;
	}

	//钱是否够
	res = LC_Helper::CheckCashMap(this, pkData->_UnlockCost);
	if(res != RE_SUCCESS)
	{
		return res;
	}

	bool flag = false;
	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		if(i==index && slotID<m_nSkillBookSlotDataInfo[i].size() && !m_nSkillBookSlotDataInfo[i][slotID].m_nSlotState)
		{
			flag= true;
			m_nSkillBookSlotDataInfo[i][slotID].m_nSlotState = true;
			break;
		}
	}

	if(flag)
	{
		//扣钱
		res = LC_Helper::PayCashMap(this, pkData->_UnlockCost, SYS_FUNC_TP_SKILLBOOK_UNLOCK_SLOT, slotID);
	}

	return res;
}

ResultType LC_ServerPlayer::WearSkillBook(int32_t index, int32_t slotID, int32_t skillBookID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
		return pkOwnerPlayer->WearSkillBook(index, slotID, skillBookID);
	LC_ServerPlayer* pkPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(index);
	IF_A_NA_PLAYER(pkPlayer)
		return RE_FAIL;
	return pkPlayer->PutOnSkillBook(index, slotID, skillBookID);
}

ResultType LC_ServerPlayer::UnWearSkillBook(int32_t index, int32_t slotID, int32_t skillBookID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
		return pkOwnerPlayer->UnWearSkillBook(index, slotID, skillBookID);
	LC_ServerPlayer* pkPlayer =  GetActivateBuddyByIndex(index);
	IF_A_NA_PLAYER(pkPlayer)
		return RE_FAIL;
	return pkPlayer->TakeOffSkillBook(index, slotID);
}

void LC_ServerPlayer::OnRefreshPlayerLevel_UnlockSkillBookSlot(bool loginIn)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->OnRefreshPlayerLevel_UnlockSkillBookSlot(loginIn);
	}

	int32_t nLevel = GetCommanderLevel();
	bool flag = false;

	CF_SkillBookUnlock::DataEntryMapExternIterator it = CF_SkillBookUnlock::GetSingletonPtr()->GetIterator();
	while(it.HasMoreElements())
	{
		CF_SkillBookUnlock::DataEntry* pkData = it.PeekNextValuePtr();
		int index = pkData->_index;
		int slotID = pkData->_slotID;
		if (pkData->_UnlockLevel<=nLevel && pkData->_UnlockCost.empty() && 0<=index && index<MAX_ACTIVE_BUDDY_NUM && 0<=slotID && slotID<m_nSkillBookSlotDataInfo[index].size())
		{
			if(!m_nSkillBookSlotDataInfo[index][slotID].m_nSlotState)
			{
				flag = true;
				m_nSkillBookSlotDataInfo[index][slotID].m_nSlotState = true;
			}
		}
		it.MoveNext();
	}

	if(!loginIn && flag)
	{
		SyncSkillBookSlotInfo();
	}
}

ResultType LC_ServerPlayer::CheckSkillBookSlotState(int32_t index, int32_t slotID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_ERROR_PARAM;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckSkillBookSlotState(index, slotID);
	}

	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		if(i==index && slotID<m_nSkillBookSlotDataInfo[i].size())
		{
			return m_nSkillBookSlotDataInfo[i][slotID].m_nSlotState ? RE_SKILLBOOKSLOT_ALREADY_UNLOCK : RE_SKILLBOOKSLOT_UNLOCKED;
		}
	}

	return RE_ERROR_PARAM;
}

void LC_ServerPlayer::SetSkillBookSlotState(int32_t index, int32_t slotID, bool slotState)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetSkillBookSlotState(index, slotID, slotState);
	}

	for(int i=0; i<MAX_ACTIVE_BUDDY_NUM; ++i)
	{
		if(i==index && slotID<m_nSkillBookSlotDataInfo[i].size() && m_nSkillBookSlotDataInfo[i][slotID].m_nSlotState != slotState)
		{
			m_nSkillBookSlotDataInfo[i][slotID].m_nSlotState = slotState;
			break;
		}
	}
}

void LC_ServerPlayer::SyncModifiedSkillBookSlotData(int32_t index, int32_t slotID, bool slotState, int32_t skillBookID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncModifiedSkillBookSlotData(index, slotID, slotState, skillBookID);
	}

	MG_SyncModifiedSkillBookSlotData syncMsg;
	syncMsg.m_nIndex = index;
	syncMsg.m_nSlotID = slotID;
	syncMsg.m_nSlotState = slotState;
	syncMsg.m_nSkillBookID = skillBookID;

	SendMsgToClient(MGPT_SYNC_SKILLBOOK_DELTA_SLOTINFO, &syncMsg);
}

ResultType LC_ServerPlayer::TakeOffSkillBook(int32_t index, int32_t slotID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	BuddyInstance* pkBuddy = GetAssignedBuddyInstance();
	if(NULL==pkBuddy || NULL==pkOwnerPlayer || index<0 || index>MAX_ACTIVE_BUDDY_NUM)
	{
		return RE_FAIL;
	}

	int buddyIndex = GetBuddyAbsoluteIndex();
	if(buddyIndex!=index || slotID<0 || slotID>pkOwnerPlayer->m_nSkillBookSlotDataInfo[index].size())
	{
		return RE_ERROR_PARAM;
	}

	int flag = false;
	int skillBookID = 0;
	if(pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSlotState)
	{
		//更新m_nSkillBookSlotDataInfo
		skillBookID = pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSkillBookID;
		pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSkillBookID = 0;
		flag = true;
	}

	if(!flag)
	{
		return RE_FAIL;
	}

	LC_SkillBookData* pkSkillData = GetSkillBookAsset().GetSkillBookData(skillBookID);
	if(NULL != pkSkillData)
	{
		pkSkillData->SetBuddyIndex(-1);

		//删技能
		mem::vector<int32_t> skillIDs;
		pkSkillData->GetSkillBookSkills(skillIDs);
		for(int j=0; j<skillIDs.size(); ++j)
		{
			RemoveSkillToBuddy(m_nBuddyTemplateId, skillIDs[j]);
		}
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::PutOnSkillBook(int32_t index, int32_t slotID, int32_t skillBookID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	IF_A_NA_PLAYER(pkOwnerPlayer)
		return RE_FAIL;
	BuddyInstance* pkDestBuddy = GetAssignedBuddyInstance();
	if( NULL==pkDestBuddy || index<0 || index>MAX_ACTIVE_BUDDY_NUM)
		return RE_FAIL;

	int buddyIndex = GetBuddyAbsoluteIndex();
	if(buddyIndex!=index || slotID<0 || slotID>pkOwnerPlayer->m_nSkillBookSlotDataInfo[index].size())
	{
		return RE_ERROR_PARAM;
	}

	int flag = false;
	//栏位是否已激活，要放的栏位上是否有圣痕，有，取下来
	if(pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSlotState)
	{
		flag = true;
		int oldSkillBookID = pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSkillBookID;
		if(oldSkillBookID != 0)
		{			
			TakeOffSkillBook(index, slotID);
		}
	}

	if(!flag)
	{
		return RE_FAIL;
	}

	LC_SkillBookData* pkSkillData = pkOwnerPlayer->GetSkillBookAsset().GetSkillBookData(skillBookID);
	if(NULL != pkSkillData)
	{
		//要佩戴的圣痕是否被别的buddy戴着，是，先从buddy身上脱下来
		int srcBuddyIndex = pkSkillData->GetBuddyIndex();
		if(srcBuddyIndex != -1)
		{			
			LC_ServerPlayer* pkSrcPlayer = pkOwnerPlayer->GetActivateBuddyByIndex(srcBuddyIndex);
			IF_A_NA_PLAYER(pkSrcPlayer)
				return RE_FAIL;

			int srcBuddySlotID = -1;
			for(int i=0; i<pkOwnerPlayer->m_nSkillBookSlotDataInfo[srcBuddyIndex].size(); ++i)
			{
				if(pkOwnerPlayer->m_nSkillBookSlotDataInfo[srcBuddyIndex][i].m_nSkillBookID == skillBookID)
				{
					srcBuddySlotID = i;
					break;
				}
			}

			ResultType res= pkSrcPlayer->TakeOffSkillBook(srcBuddyIndex, srcBuddySlotID);
			if(RE_SUCCESS != res)
			{
				return res;
			}
		}

		//给现在这个buddy穿上
		pkOwnerPlayer->m_nSkillBookSlotDataInfo[index][slotID].m_nSkillBookID = skillBookID;
		pkSkillData->SetBuddyIndex(index);

		//学技能
		mem::vector<int32_t> skillIDs;
		pkSkillData->GetSkillBookSkills(skillIDs);
		for(int i=0; i<skillIDs.size(); ++i)
		{
			int slotId = -1;
			LearnSkillToBuddy(m_nBuddyTemplateId, skillIDs[i], slotId, NULL, false);
		}
	}

	return RE_SUCCESS;
}


void LC_ServerPlayer::InitSkillBookProperty(int32_t index, int32_t slotID, int32_t skillBookID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	BuddyInstance* pkBuddy = GetAssignedBuddyInstance();
	if(NULL==pkBuddy || NULL==pkOwnerPlayer)
	{
		return;
	}

	int buddyIndex = GetBuddyAbsoluteIndex();
	if(buddyIndex != index)
		return;

	LC_SkillBookData* pkSkillData = GetSkillBookAsset().GetSkillBookData(skillBookID);
	if(NULL != pkSkillData && pkSkillData->GetBuddyIndex()==index)
	{
		//学技能
		mem::vector<int32_t> skillIDs;
		pkSkillData->GetSkillBookSkills(skillIDs);
		for(int i=0; i<skillIDs.size(); ++i)
		{
			int slotId = -1;
			LearnSkillToBuddy(m_nBuddyTemplateId, skillIDs[i], slotId);
		}
	}
}


int LC_ServerPlayer::GetActivateSkillBookCount()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetActivateSkillBookCount();
	}

	int count = GetSkillBookAsset().GetSkillBookCount();
	return count;
}

void LC_ServerPlayer::SyncBiographyRewardInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	MG_SyncBiographyPartReward syncMsg;
	for(BiographyRewardSet::iterator it=m_biographytRewardPartSet.begin(); it!=m_biographytRewardPartSet.end(); ++it)
	{
		syncMsg.m_nBiographyPartReward.push_back(*it);
	}
	pkOwnerPlayer->SendMsgToClient(MGPT_SYNC_BIOGRAPHYPART_REWARD, &syncMsg);
}

void LC_ServerPlayer::SyncBiography()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	MG_SyncBiography syncMsg;
	for(BiographyRewardSet::iterator it=m_biographySet.begin(); it!=m_biographySet.end(); ++it)
	{
		syncMsg.m_nBiography.push_back(*it);
	}
	pkOwnerPlayer->SendMsgToClient(MGPT_SYNC_BIOGRAPHY, &syncMsg);
}

ResultType LC_ServerPlayer::BiographyPartReward(int32_t biographyPartID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return res;
	}


	res = pkOwnerPlayer->CheckCanFinishBiographyPart(biographyPartID);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//领奖
	res = pkOwnerPlayer->GetBiographyPartReward(biographyPartID);
	return res;
}

void LC_ServerPlayer::GetFirstAssignBiographyPartID(mem::vector<int32_t>& biographyPartID)
{
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	while (kIter.HasMoreElements())
	{
		CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();

		//buddy是否已经激活
		if(pkEntry->_bBuddyActivate)
		{
			int buddyID = pkEntry->_iBuddyID;
			BuddyInstance* pkBuddy = GetBuddyInstanceByID(buddyID);
			if(NULL == pkBuddy)
			{
				kIter.MoveNext();
				continue;
			}
		}

		//是否完成前置任务
		int PreTaskID = pkEntry->_iActivateTaskID;
		if(0!=PreTaskID && !IsInFinishedTaskMap(PreTaskID) && !CanFinish(PreTaskID))
		{
			kIter.MoveNext();
			continue;
		}

		//是否完成前置传记
		int preBiographyID = pkEntry->_iPreBiographyID;
		if(0!=preBiographyID && (!IsInFinishBiographyMap(preBiographyID) || !CheckBiographyFinishCondition(PreTaskID)))
		{
			kIter.MoveNext();
			continue;
		}

		int biographyID = pkEntry->_iBiographyID;
		CF_Biography::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
		if(NULL!=pkData && !pkData->_iBiographyTaskID.empty())
		{
			Utility::UT_SIMDataList& biographyPartIDs = pkData->_iBiographyTaskID;
			int partID = pkData->_iBiographyTaskID[0].IID();
			biographyPartID.push_back(partID);
			AddAssignBiographyPartID(biographyID, partID);
		}		
		kIter.MoveNext();
	}
}

void LC_ServerPlayer::GetAssignBiographyPartIDByParam(mem::vector<int32_t>& biographyPartID, int param1, int param2)
{
	switch(param1)
	{
	case BUDDY_ASSIGN:
		{
			CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
			while (kIter.HasMoreElements())
			{
				CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
				if(/*NULL != pkEntry &&*/ pkEntry->_iBuddyID==param2)
				{
					//需要激活的buddy已经激活
					if(NULL != GetBuddyInstanceByID(pkEntry->_iBuddyID))
					{
						//check前置任务
						if(0==pkEntry->_iActivateTaskID || IsInFinishedTaskMap(pkEntry->_iActivateTaskID) || CanFinish(pkEntry->_iActivateTaskID))
						{
							//check前置传记任务
							if(0==pkEntry->_iPreBiographyID || (IsInFinishBiographyMap(pkEntry->_iPreBiographyID) || CheckBiographyFinishCondition(pkEntry->_iPreBiographyID)))
							{
								int biographyID = pkEntry->_iBiographyID;
								CF_Biography::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
								if(NULL!=pkData && !pkData->_iBiographyTaskID.empty())
								{
									Utility::UT_SIMDataList& biographyPartIDs = pkData->_iBiographyTaskID;
									int partID = pkData->_iBiographyTaskID[0].IID();
									biographyPartID.push_back(partID);
									AddAssignBiographyPartID(biographyID, partID);
								}
							}
						}
					}
				}
				kIter.MoveNext();
			}
		}
		break;
	case PRETASK_ASSIGN:
		{
			CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
			while (kIter.HasMoreElements())
			{
				CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
				if(/*NULL != pkEntry &&*/ pkEntry->_iActivateTaskID==param2)
				{
					//check前置任务
					if(IsInFinishedTaskMap(pkEntry->_iActivateTaskID) || CanFinish(pkEntry->_iActivateTaskID))
					{
						//不需要激活buddy  或者需要激活的buddy已经激活
						if(0==pkEntry->_bBuddyActivate || NULL!=GetBuddyInstanceByID(pkEntry->_iBuddyID))
						{
							//check前置传记任务
							if(0==pkEntry->_iPreBiographyID || (IsInFinishBiographyMap(pkEntry->_iPreBiographyID) || CheckBiographyFinishCondition(pkEntry->_iPreBiographyID)))
							{
								int biographyID = pkEntry->_iBiographyID;
								CF_Biography::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
								if(NULL!=pkData && !pkData->_iBiographyTaskID.empty())
								{
									Utility::UT_SIMDataList& biographyPartIDs = pkData->_iBiographyTaskID;
									int partID = pkData->_iBiographyTaskID[0].IID();
									biographyPartID.push_back(partID);
									AddAssignBiographyPartID(biographyID, partID);
								}
							}
						}
					}
				}
				kIter.MoveNext();
			}
		}
		break;
	case PREBIOGRAPHY_ASSIGN:
		{
			CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
			while (kIter.HasMoreElements())
			{
				CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
				if(/*NULL != pkEntry &&*/ pkEntry->_iPreBiographyID==param2)
				{
					//check前置传记任务
					if(IsInFinishBiographyMap(pkEntry->_iPreBiographyID) || CheckBiographyFinishCondition(pkEntry->_iPreBiographyID))
					{
						//check前置任务
						if(IsInFinishedTaskMap(pkEntry->_iActivateTaskID) || CanFinish(pkEntry->_iActivateTaskID))
						{
							//不需要激活buddy  或者需要激活的buddy已经激活
							if(0==pkEntry->_bBuddyActivate || NULL!=GetBuddyInstanceByID(pkEntry->_iBuddyID))
							{
								int biographyID = pkEntry->_iBiographyID;
								CF_Biography::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
								if(NULL!=pkData && !pkData->_iBiographyTaskID.empty())
								{
									Utility::UT_SIMDataList& biographyPartIDs = pkData->_iBiographyTaskID;
									int partID = pkData->_iBiographyTaskID[0].IID();
									biographyPartID.push_back(partID);
									AddAssignBiographyPartID(biographyID, partID);
								}
							}
						}
					}
				}
				kIter.MoveNext();
			}
		}
		break;
	default:
		break;
	}
}

void LC_ServerPlayer::GetBiographyTaskID(int32_t biographyPartID, TaskIDVec& taskSet)
{
	CF_BiographyTask::DataEntry* pkBiographyTaskData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(biographyPartID);
	if(NULL != pkBiographyTaskData && !pkBiographyTaskData->_sTaskID.empty())
	{
		Utility::UT_SIMDataList& taskID = pkBiographyTaskData->_sTaskID;
		for(int j=0; j<taskID.size(); ++j)
		{
			int id = taskID[j].IID();
			taskSet.push_back(id);
		}		
	}
}

bool LC_ServerPlayer::GetNextBiographyPartID(int32_t preBiographyID, int32_t& nextBiographyID)
{
	bool tag = false;
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	for ( ;kIter.HasMoreElements();kIter.MoveNext() )
	{
		CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		if(!pkEntry->_iBiographyTaskID.empty())
		{
			for(int i=0; i<pkEntry->_iBiographyTaskID.size(); ++i)
			{
				if(preBiographyID==pkEntry->_iBiographyTaskID[i].IID() && i<pkEntry->_iBiographyTaskID.size()-1)
				{
					tag = true;
					nextBiographyID = pkEntry->_iBiographyTaskID[i+1].IID();
					AddAssignBiographyPartID(pkEntry->_iBiographyID, nextBiographyID);
					break;
				}
			}

			if(tag)
			{
				break;
			}
		}
	}

	return tag;
}

bool LC_ServerPlayer::IsBiographyPreTask(int taskID)
{
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	while (kIter.HasMoreElements())
	{
		CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		if(pkEntry->_iActivateTaskID == taskID)
		{
			return true;
		}
		kIter.MoveNext();
	}

	return false;
}

void LC_ServerPlayer::AddAssignBiographyPartID(int32_t birgraphyID, int32_t biographyPartID)
{
	AssignBiographySet::iterator findIt = m_nAssignBiographySet.find(birgraphyID);
	if(findIt == m_nAssignBiographySet.end())
	{
		mem::set<int32_t> partID;
		partID.insert(biographyPartID);
		m_nAssignBiographySet.insert(std::make_pair(birgraphyID, partID));
	}
	else
	{
		findIt->second.insert(biographyPartID);
	}
	AddNextAssignBiographyPart(biographyPartID);
}

bool LC_ServerPlayer::IsAssignBiography(int32_t birgraphyID)
{
	return m_nAssignBiographySet.find(birgraphyID) != m_nAssignBiographySet.end();
}

bool LC_ServerPlayer::IsAssignBiographyPart(int32_t biographyPartID)
{
	for(AssignBiographySet::iterator it=m_nAssignBiographySet.begin(); it!=m_nAssignBiographySet.end(); ++it)
	{
		mem::set<int32_t>::iterator findIt = it->second.find(biographyPartID);
		return findIt != it->second.end();
	}
	return false;
}

void LC_ServerPlayer::AddFinishBiographyPartID(int32_t biographyPartID)
{
	m_nFinishBiographyPartSet.insert(biographyPartID);
	RemoveNextAssignBiographyPart(biographyPartID);
	UpdateFinishBiography();
}

bool LC_ServerPlayer::IsInFinishBiographyPartID(int32_t biographyPartID)
{
	return m_nFinishBiographyPartSet.find(biographyPartID) != m_nFinishBiographyPartSet.end();
}

bool LC_ServerPlayer::CheckBiographyFinish(int32_t biographyID)
{
	CF_Biography::DataEntry* pkBioData = SafeGetCSVFileDataEntryPtr<CF_Biography>(biographyID);
	if(NULL == pkBioData)
	{
		return false;
	}

	Utility::UT_SIMDataList& bioPartID = pkBioData->_iBiographyTaskID;
	for(Utility::UT_SIMDataList::iterator it=bioPartID.begin(); it!=bioPartID.end(); ++it)
	{
		int partID = it->ID();
		if(!IsInFinishBiographyPartID(partID))
		{
			return false;
		}
	}

	return true;
}

bool LC_ServerPlayer::AddFinishBiographyID(int32_t biographyID)
{
	return m_biographySet.insert(biographyID).second;
}

void LC_ServerPlayer::AddNextAssignBiographyPart(int32_t biographyPartID)
{
	m_nNextAssignBiographyPartSet.insert(biographyPartID);
}

void LC_ServerPlayer::RemoveNextAssignBiographyPart(int32_t biographyPartID)
{
	//每一个传记最后一张的传记章节必须在m_nNextAssignBiographyPartSet中
	mem::set<int32_t>::iterator findIt = m_nLastBiographyPartID.find(biographyPartID);
	if(findIt != m_nLastBiographyPartID.end())
	{
		return;
	}

	m_nNextAssignBiographyPartSet.erase(biographyPartID);
}

bool LC_ServerPlayer::IsLastBiographyPartID(int32_t biographyPartID)
{
	return m_nLastBiographyPartID.find(biographyPartID) != m_nLastBiographyPartID.end();
}

ResultType LC_ServerPlayer::CheckCanFinishBiographyPart(int32_t biographyID)
{
	CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(biographyID);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	if(IsInFinishBiographyRewardPartMap(biographyID))
	{
		return RE_BIOGRAPHY_REWARD_HAS_GET;
	}

	//任务是否全部完成
	Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
	for(int i=0; i<tasks.size(); ++i)
	{
		int taskID = tasks[i].IID();
		if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
		{
			return RE_TASK_NOT_FINISH;
		}
	}

	//历练是否全部达到
	Utility::UT_SIMDataList& achievements = pkData->_sAchievementID;
	for(int i=0; i<achievements.size(); ++i)
	{
		int achievementID = achievements[i].IID();
		ResultType res = CheckAchievementCanFinish(achievementID);
		if(RE_ACHIEVEMENT_REWARD_HAS_RECEIVED!=res && RE_SUCCESS!=res)
		{
			return RE_ACHIEVEMENT_NOT_FINISH;
		}
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::CheckFinishBiographyPart(int32_t biographyID)
{
	CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(biographyID);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	if(IsInFinishBiographyRewardPartMap(biographyID))
	{
		return RE_SUCCESS;
	}

	//任务是否全部完成
	Utility::UT_SIMDataList& tasks = pkData->_sTaskID;
	for(int i=0; i<tasks.size(); ++i)
	{
		int taskID = tasks[i].IID();
		if(!IsInFinishedTaskMap(taskID) && !CanFinish(taskID))
		{
			return RE_TASK_NOT_FINISH;
		}
	}

	//历练是否全部达到
	Utility::UT_SIMDataList& achievements = pkData->_sAchievementID;
	for(int i=0; i<achievements.size(); ++i)
	{
		int achievementID = achievements[i].IID();
		ResultType res = CheckAchievementCanFinish(achievementID);
		if(RE_ACHIEVEMENT_REWARD_HAS_RECEIVED!=res && RE_SUCCESS!=res)
		{
			return RE_ACHIEVEMENT_NOT_FINISH;
		}
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::GetBiographyPartReward(int32_t biographyID)
{
	//领奖
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return res;
	}

	CF_BiographyTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BiographyTask>(biographyID);
	if(NULL == pkData)
	{
		return res;
	}

	StringType mailTitle;
	StringType mailDesc;
	res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_kReward, pkOwnerPlayer, SYS_FUNC_TP_GET_BIOGRAPHY_REWARD, biographyID, mailTitle, mailDesc, false);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	pkOwnerPlayer->m_biographytRewardPartSet.insert(biographyID);

	return RE_SUCCESS;
}

void LC_ServerPlayer::UpdateFinishBiography()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if (NULL == pkOwnerPlayer)
	{
		return;
	}

	bool sync = false;
	CF_Biography::DataEntryMapExternIterator kIter = CF_Biography::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_Biography::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		int biographyID = pkEntry->_iBiographyID;
		if(pkOwnerPlayer->CheckBiographyFinish(pkEntry->_iBiographyID))
		{
			bool tag = AddFinishBiographyID(biographyID);
			if(tag)
			{
				sync = true;

				if(IsAssignBiography(biographyID))
				{
					continue;
				}

				//完成前置传记，派发角色传记任务
				LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
				if(m_kOpenAbilityAsset.IsAbilityEnabled(LC_ABT_TASK, STT_BIOGRAPHY_TASK))
				{
					pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_BIOGRAPHY_TASK), false, PREBIOGRAPHY_ASSIGN, biographyID);
				}
			}
		}
	}

	if(sync)
	{
		SyncBiography();
	}
}

bool LC_ServerPlayer::TryInsertItemToRecordSet( uint32_t nItemId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return false;
	if ( !IsMainController() )
		return pOwner->TryInsertItemToRecordSet(nItemId);

	// Find from package
	LC_PackAsset* pPackAsset = GetPackAsset();
	if (pPackAsset == NULL)
		return false;
	bool bRetCode = pPackAsset->IsExistItem(nItemId);
	if ( bRetCode )
	{
		InsertItemToRecordSet( nItemId );
		return false;
	}
	bRetCode = InsertItemToRecordSet( nItemId );
	if ( bRetCode == false )
		return false;

	MG_SC_NEW_ITEM_NOTIFY notify;
	notify.m_nItemId = nItemId;
	SendMsgToClient(MGPT_SC_NEW_ITEM_NOTIFY, &notify );
	return true;
}


bool LC_ServerPlayer::InsertItemToRecordSet( uint32_t nItemId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return false;
	if ( !IsMainController() )
		return pOwner->InsertItemToRecordSet(nItemId);

	CommonItemRecordSet::iterator it = m_CommonItemRecordSet.find( nItemId );
	if ( it != m_CommonItemRecordSet.end() )
		return false;

	m_CommonItemRecordSet.insert( nItemId );
	return true;
}

bool LC_ServerPlayer::FindItemInRecordSet( uint32_t nItemId )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return false;
	if ( !IsMainController() )
		return pOwner->FindItemInRecordSet(nItemId);

	CommonItemRecordSet::iterator it = m_CommonItemRecordSet.find( nItemId );
	if ( it != m_CommonItemRecordSet.end() )
		return true;

	return false;
}

void LC_ServerPlayer::GetActSubPlayerInfoCache(PlayerACTSubInfo& info)
{
	info.controller_level = m_nActSubPlayerInfo.controller_level;
	info.controller_combatScore = m_nActSubPlayerInfo.controller_combatScore;
	info.subvehicle_combatscore = m_nActSubPlayerInfo.subvehicle_combatscore;
	info.subdevaeye_combatscore = m_nActSubPlayerInfo.subdevaeye_combatscore;
	info.subwing_combatscore = m_nActSubPlayerInfo.subwing_combatscore;
	info.pet_combatscore = m_nActSubPlayerInfo.pet_combatscore;
}

void LC_ServerPlayer::SetActSubPlayerInfoCache(const PlayerACTSubInfo& info)
{
	m_nActSubPlayerInfo.controller_level = info.controller_level;
	m_nActSubPlayerInfo.controller_combatScore = info.controller_combatScore;
	m_nActSubPlayerInfo.subvehicle_combatscore = info.subvehicle_combatscore;
	m_nActSubPlayerInfo.subdevaeye_combatscore = info.subdevaeye_combatscore;
	m_nActSubPlayerInfo.subwing_combatscore = info.subwing_combatscore;
	m_nActSubPlayerInfo.pet_combatscore = info.pet_combatscore;
}

void LC_ServerPlayer::SyncPlayerACTSubInfo(const PlayerACTSubInfo& info)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->SyncPlayerACTSubInfo(info);
	}

	MG_SyncPlayerACTSubInfo syncMsg;
	syncMsg.m_nActivityType = ACTIVITY_NORMAL;
	syncMsg.m_nSave = GetSaveState();
	if(syncMsg.m_nSave)
	{
		syncMsg.m_nController_level = info.controller_level;
		syncMsg.m_nController_combatScore = info.controller_combatScore;
		syncMsg.m_nSubvehicle_combatscore = info.subvehicle_combatscore;
		syncMsg.m_nSubdevaeye_combatscore = info.subdevaeye_combatscore;
		syncMsg.m_nSubwing_combatscore = info.subwing_combatscore;
		syncMsg.m_nPet_combatscore = info.pet_combatscore;
	}

	SendMsgToClient(MGPT_SYNC_PLAYER_ACT_SUBINFO, &syncMsg);
}

void LC_ServerPlayer::UpdateACTSubInfo(float currentTime)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->UpdateACTSubInfo(currentTime);
	}

	/*
	mem::vector<uint64_t> input;
	input.push_back(GetGlobalSetting.ACTSubordinateScheduleID);
	int activiteTime = 0;
	UT_ServerHelper::RedisGetData_Int(UT_REDIS_KEY_ACT_SUBORDINATE_TIME, input, activiteTime);
	*/

	int32_t activiteTime = UT_ServerHelper::GetSubSaveTime();
	//活动已经结束 && GetSaveState()=false  则：玩家的数据还未存到redis
	if(activiteTime!=0 && !GetSaveState())
	{
		//存数据
		PlayerACTSubInfo info;
		info.controller_level = GetLevel();
		info.controller_combatScore = GetControllerCombatScore(); 
		info.subvehicle_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_VEHICLE);//坐骑战斗力
		info.subdevaeye_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_DEVA_EYE);//宠物战斗力
		info.subwing_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_MUHUN);//背饰战斗力
		info.pet_combatscore = GetTotalPetCombatScore();//玩具总战力

		std::stringstream ss;
		boost::ajson::save_to_buff(info, ss);
		std::string data = ss.str().c_str();

		mem::vector<uint64_t> key;
		key.push_back(m_Instance);

		UT_ServerHelper::RedisSetData_String(UT_REDIS_KEY_ACT_SUB_PLAYER_INFO, key, data, false, true);

		SetSaved();

		//达标结束时，将玩家的数据缓存在gs上，领奖的时候，用这份数据去判断
		SetActSubPlayerInfoCache(info);
		SyncPlayerACTSubInfo(info);
	}
}

bool LC_ServerPlayer::GetSaveState()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return false;
		}
		return pkOwnerPlayer->GetSaveState();
	}

	return m_bACTSubSave;
}

void LC_ServerPlayer::SetSaved()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->SetSaved();
	}

	m_bACTSubSave = true;
}

void LC_ServerPlayer::GetActSubPlusPlayerInfoCache(PlayerACTSubInfo& info)
{
	info.controller_level = m_nActSubPlusPlayerInfo.controller_level;
	info.controller_combatScore = m_nActSubPlusPlayerInfo.controller_combatScore;
	info.subvehicle_combatscore = m_nActSubPlusPlayerInfo.subvehicle_combatscore;
	info.subdevaeye_combatscore = m_nActSubPlusPlayerInfo.subdevaeye_combatscore;
	info.subwing_combatscore = m_nActSubPlusPlayerInfo.subwing_combatscore;
	info.pet_combatscore = m_nActSubPlusPlayerInfo.pet_combatscore;
}

void LC_ServerPlayer::SetActSubPlusPlayerInfoCache(const PlayerACTSubInfo& info)
{
	m_nActSubPlusPlayerInfo.controller_level = info.controller_level;
	m_nActSubPlusPlayerInfo.controller_combatScore = info.controller_combatScore;
	m_nActSubPlusPlayerInfo.subvehicle_combatscore = info.subvehicle_combatscore;
	m_nActSubPlusPlayerInfo.subdevaeye_combatscore = info.subdevaeye_combatscore;
	m_nActSubPlusPlayerInfo.subwing_combatscore = info.subwing_combatscore;
	m_nActSubPlusPlayerInfo.pet_combatscore = info.pet_combatscore;
}

void LC_ServerPlayer::SyncPlayerACTSubInfo_Plus(const PlayerACTSubInfo& info)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->SyncPlayerACTSubInfo_Plus(info);
	}

	MG_SyncPlayerACTSubInfo syncMsg;
	syncMsg.m_nActivityType = ACTIVITY_PLUS;
	syncMsg.m_nSave = GetSaveState_Plus();
	if(syncMsg.m_nSave)
	{
		syncMsg.m_nController_level = info.controller_level;
		syncMsg.m_nController_combatScore = info.controller_combatScore;
		syncMsg.m_nSubvehicle_combatscore = info.subvehicle_combatscore;
		syncMsg.m_nSubdevaeye_combatscore = info.subdevaeye_combatscore;
		syncMsg.m_nSubwing_combatscore = info.subwing_combatscore;
		syncMsg.m_nPet_combatscore = info.pet_combatscore;
	}

	SendMsgToClient(MGPT_SYNC_PLAYER_ACT_SUBINFO, &syncMsg);
}

void LC_ServerPlayer::UpdateACTSubInfo_Plus(float currentTime)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->UpdateACTSubInfo_Plus(currentTime);
	}

	/*
	mem::vector<uint64_t> input;
	input.push_back(GetGlobalSetting.ACTSubordinateScheduleID_Plus);
	int activiteTime = 0;
	UT_ServerHelper::RedisGetData_Int(UT_REDIS_KEY_ACT_SUBORDINATE_TIME_PLUS, input, activiteTime);
	*/

	int32_t activiteTime = UT_ServerHelper::GetSubPlusSaveTime();
	//活动已经结束 && GetSaveState_Plus()=false  则：玩家的数据还未存到redis
	if(activiteTime!=0 && !GetSaveState_Plus())
	{
		//存数据
		PlayerACTSubInfo info;
		info.controller_level = GetLevel();
		info.controller_combatScore = GetControllerCombatScore(); 
		info.subvehicle_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_VEHICLE);//坐骑战斗力
		info.subdevaeye_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_DEVA_EYE);//宠物战斗力
		info.subwing_combatscore = GetSumSubSystemCombatScore(LC_SUB_TP_MUHUN);//背饰战斗力
		info.pet_combatscore = GetTotalPetCombatScore();//玩具总战力

		std::stringstream ss;
		boost::ajson::save_to_buff(info, ss);
		std::string data = ss.str().c_str();

		mem::vector<uint64_t> key;
		key.push_back(m_Instance);

		UT_ServerHelper::RedisSetData_String(UT_REDIS_KEY_ACT_SUB_PLAYER_INFO_PLUS, key, data, false, true);

		SetSaved_Plus();

		SetActSubPlusPlayerInfoCache(info);
		SyncPlayerACTSubInfo_Plus(info);
	}
}

bool LC_ServerPlayer::GetSaveState_Plus()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return false;
		}
		return pkOwnerPlayer->GetSaveState_Plus();
	}

	return m_bACTSubSave_Plus;
}

void LC_ServerPlayer::SetSaved_Plus()	
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->SetSaved_Plus();
	}

	m_bACTSubSave_Plus = true;
}

ResultType LC_ServerPlayer::ResetShopTimes(int32_t shopType, int& resetTimes)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	int currentResetTimes = 0;
	CashType moneyType = (CashType)(0);
	int moneyCount = 0;
	ResultType res = checkReset(pkOwnerPlayer, shopType, currentResetTimes, moneyType, moneyCount);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	res = pkOwnerPlayer->ResetShop(shopType);
	if(RE_SUCCESS == res)
	{
		//商城刷新--埋点日志
		int nLogCode = 0;
		vector<int> nParams;
		nParams.clear();
		nParams.push_back(currentResetTimes+1);
		switch(shopType)
		{
		case SHOP_TYPE_UNBINDYUANBAO:
			nLogCode = LC_Helper::SerializeOperateLogCode(SHOP_LOGTYPE, DIAMOND_SHOP,OPERATE_LOGTYPE2);
			break;
		case SHOP_TYPE_GUILD:
			nLogCode = LC_Helper::SerializeOperateLogCode(SHOP_LOGTYPE, GUILD_SHOP,OPERATE_LOGTYPE2);
			break;
		case SHOP_TYPE_MONEY_COURAGE:
			nLogCode = LC_Helper::SerializeOperateLogCode(SHOP_LOGTYPE, BRAVERY_SHOP,OPERATE_LOGTYPE2);
			break;
		case SHOP_TYPE_BOSS_JP:
			nLogCode = LC_Helper::SerializeOperateLogCode(SHOP_LOGTYPE, JP_SHOP,OPERATE_LOGTYPE2);
			break;
		case SHOP_TYPE_LIMIT:
			nLogCode = LC_Helper::SerializeOperateLogCode(SHOP_LOGTYPE, LIMITS_SHOP,OPERATE_LOGTYPE2);
			break;
		}
		pkOwnerPlayer->ReduceCash(moneyCount, moneyType, SYS_FUNC_TP_RESET_SHOP, shopType,nLogCode,nParams);
		res = pkOwnerPlayer->AddShopResetTimes(shopType, 1);
		if(RE_SUCCESS == res)
		{
			resetTimes = currentResetTimes+1;
		}
	}
	return res;
}

int32_t LC_ServerPlayer::GetShopResetTimes(int32_t shopType)
{
	mem::map<int, int>::iterator findIt = m_ShopTimes.find(shopType);
	if(findIt != m_ShopTimes.end())
	{
		return findIt->second;
	}
	return 0;
}

ResultType LC_ServerPlayer::AddShopResetTimes(int32_t shopType, int value)
{
	if(shopType==SHOP_TYPE_UNBINDYUANBAO || shopType==SHOP_TYPE_GUILD || shopType==SHOP_TYPE_MONEY_COURAGE || shopType==SHOP_TYPE_BOSS_JP || shopType==SHOP_TYPE_LIMIT)
	{
		mem::map<int, int>::iterator findIt = m_ShopTimes.find(shopType);
		if(findIt != m_ShopTimes.end())
		{
			findIt->second += value;
		}
		else
		{
			m_ShopTimes.insert(std::make_pair(shopType, value));
		}
		return RE_SUCCESS;
	}
	return RE_ERROR_PARAM;
}

void LC_ServerPlayer::clearShopResetTimes(int32_t shopType)
{
	mem::map<int, int>::iterator findIt = m_ShopTimes.find(shopType);
	if(findIt != m_ShopTimes.end())
	{
		findIt->second = 0;
	}
}

ResultType LC_ServerPlayer::checkReset(LC_ServerPlayer* pkPlayer, int32_t shopType, int32_t& shopTimes, CashType& moneyType, int32_t& moneyCount)
{
	//检测剩余购买次数
	int totalResetTimes = pkPlayer->GetVIPAsset().GetProfitValue(shopType);
	shopTimes = pkPlayer->GetShopResetTimes(shopType);
	if(shopTimes+1 > totalResetTimes)
	{
		return RE_RESET_SHOPB_TIMES_BE_LIMITED;
	}

	//检测花费
	switch(shopType)
	{
	case SHOP_TYPE_UNBINDYUANBAO:
		moneyType = (CashType)(GetGlobalSetting.shoplistID1CostType);
		moneyCount = GetGlobalSetting.shoplistID1CostNumInit + GetGlobalSetting.shoplistID1CostNumPlus*shopTimes;
		break;
	case SHOP_TYPE_GUILD:
		moneyType = (CashType)(GetGlobalSetting.shoplistID2CostType);
		moneyCount = GetGlobalSetting.shoplistID2CostNumInit + GetGlobalSetting.shoplistID2CostNumPlus*shopTimes;
		break;
	case SHOP_TYPE_MONEY_COURAGE:
		moneyType = (CashType)(GetGlobalSetting.shoplistID3CostType);
		moneyCount = GetGlobalSetting.shoplistID3CostNumInit + GetGlobalSetting.shoplistID3CostNumPlus*shopTimes;
		break;
	case SHOP_TYPE_BOSS_JP:
		moneyType = (CashType)(GetGlobalSetting.shoplistID4CostType);
		moneyCount = GetGlobalSetting.shoplistID4CostNumInit + GetGlobalSetting.shoplistID4CostNumPlus*shopTimes;
		break;
	case SHOP_TYPE_LIMIT:
		moneyType =  (CashType)(GetGlobalSetting.shoplistID5CostType);
		moneyCount = GetGlobalSetting.shoplistID5CostNumInit + GetGlobalSetting.shoplistID5CostNumPlus*shopTimes;
		break;
	default:
		return RE_FAIL;
	}

	bool tag = pkPlayer->IsCashEnough(moneyCount, moneyType);
	if(!tag)
	{
		return RE_RESET_CASH_NOT_ENOUGH;
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::ResetShop(int32_t shopType)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}


	bool flag = LC_Helper::CheckResetShopType(shopType);
	if(flag)
	{
		CActShopManager* pkManager = CActShopManager::GetSingletonPtr();
		const mem::vector<const CSVFile::CF_ACTShopA::DataEntry*>* pkCSVDataVector = pkManager->GetActShopCSVDataByShopType(shopType);
		if(NULL == pkCSVDataVector)
		{
			return RE_FAIL;
		}

		for(int i=0; i<(*pkCSVDataVector).size(); ++i)
		{
			const CSVFile::CF_ACTShopA::DataEntry* pkData = (*pkCSVDataVector)[i];
			if(NULL == pkData)
			{
				continue;
			}

			if(pkData->_iType == shopType)
			{
				Activity::ACT_ScheduleManager* pkScheduleMgr = Activity::ACT_ScheduleManager::GetSingletonPtr();
				if (!pkScheduleMgr->IsScheduleValid(pkOwnerPlayer->GetServerID(), pkData->_iSchedule))
				{
					continue;
				}

				Activity::ACT_ScheduleSaveActivity* pkSaveActivity = pkOwnerPlayer->GetACTScheduleAsset().GetScheduleSaveActivity(Activity::ACT_SCHEDULE_TP_SHOP);
				if (NULL == pkSaveActivity)
				{
					continue;
				}

				Activity::ACT_ScheduleSaveCatagory* pkSaveCatagory = pkSaveActivity->GetScheduleSaveCatagory(pkData->_iType);
				if (NULL == pkSaveCatagory)
				{
					continue;
				}

				Activity::ACT_ScheduleSaveEntry* pkSaveSchedule = pkSaveCatagory->GetScheduleSaveEntry(pkData->_iSchedule);
				if (NULL == pkSaveSchedule)
				{
					continue;
				}

				Activity::ACT_ScheduleSaveCommon* pkSaveDetail = pkSaveSchedule->GetScheduleSaveDetail(pkData->_iKey);
				if (NULL == pkSaveDetail)
				{
					continue;
				}

				Utility::UT_SIMDataMap::const_iterator it = pkData->_kLimits.begin();
				for (; it!=pkData->_kLimits.end(); ++it)
				{
					const Utility::UT_SIMDataInfo& rkLimit = it->second;
					if(!GameLogic::IS_VALID_STAT_TYPE(rkLimit.StatType()))
					{
						continue;
					}

					int32_t iStatKey = GET_SCHEDULE_KEY(rkLimit.StatType(), Activity::ACT_SCHEDULE_DETAIL_COUNT);
					int buyTimes = pkSaveDetail->GetValue(iStatKey);
					if(buyTimes > 0)
					{
						//tag = true;
						pkSaveDetail->SetValue(iStatKey, 0);
						pkSaveSchedule->UpdateDirtyFlag();
						pkSaveCatagory->UpdateDirtyFlag();
						pkSaveActivity->UpdateDirtyFlag();
					}
				}
			}
		}

		//去掉货源充足，暂时无法刷新的限制
		//if(!tag)
		//{
		//	return RE_RESET_SHOPB_NOT_BUY;
		//}

		pkOwnerPlayer->GetACTScheduleAsset().UpdateDirtyFlag();
		RefreshShopItem(shopType);
		return RE_SUCCESS;
	}
	return RE_ERROR_PARAM;
}


void LC_ServerPlayer::RefreshShopItem(int32_t shopType)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RefreshShopItem(shopType);
	}

	ClearShopItem(shopType);

	mem::set<int32_t> shopAID;
	mem::set<int32_t> rankID;

	CActShopManager* pkManager = CActShopManager::GetSingletonPtr();
	bool tag1 = pkManager->GetShopTypeToShopIDByShopType(shopType, shopAID);
	bool tag2 = pkManager->GetShopTypeToRankByShopType(shopType, rankID);
	if(!tag1 || !tag2)
	{
		return;
	}

	CF_ShopGroupOpenSetting::DataEntry *pkData = NULL;
	for(mem::set<int32_t>::iterator it=rankID.begin(); it!=rankID.end(); ++it)
	{
		int vaildConditionCount = 0;
		int indexID = *it;
		pkData = SafeGetCSVFileDataEntryPtr<CF_ShopGroupOpenSetting>(indexID);
		if(NULL==pkData)
		{
			continue;
		}

		for(Utility::UT_SIMDataList::iterator it = pkData->_kBuyConditions.begin(); it != pkData->_kBuyConditions.end(); ++it)
		{
			switch(it->IID())
			{
			case Activity::ACT_SHOP_COND_CONTROLLER_LEVEL:
				{
					int controllerLevel = GetLevel();
					if(controllerLevel >= it->ParamA())
					{
						++vaildConditionCount;
					}
				}
				break;
			case Activity::ACT_SHOP_COND_CHARGE_UNBINDYUANBAO_NUM:
				{
					int chargeYuanBao = GetVIPAsset().GetCredit();
					if(chargeYuanBao >= it->ParamA())
					{
						++vaildConditionCount;
					}
				}
				break;
			case Activity::ACT_SHOP_COND_PRETASK:
				{
					int taskID = it->ParamA();
					bool tag = IsInFinishedTaskMap(taskID);
					if(tag)
					{
						++vaildConditionCount;
					}
				}
				break;
			default:
				break;
			}
		}

		if(vaildConditionCount == pkData->_kBuyConditions.size())
		{
			//条件满足
			mem::vector<int32_t> vaildConditionID;
			int percentCount = 0;
			for(mem::set<int32_t>::iterator it=shopAID.begin(); it!=shopAID.end();)
			{
				int id = *it;
				CF_ACTShopA::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_ACTShopA>(id);
				if(pkEntry!=NULL && pkEntry->_uiRank==indexID)
				{
					it = shopAID.erase(it);
					int count = 0;
					for(Utility::UT_SIMDataList::iterator it = pkEntry->_kBuyConditions.begin(); it != pkEntry->_kBuyConditions.end(); ++it)
					{
						switch(it->IID())
						{
						case Activity::ACT_SHOP_COND_CONTROLLER_LEVEL:
							{
								int controllerLevel = GetLevel();
								if(controllerLevel >= it->ParamA())
								{
									++count;
								}
							}
							break;
						case Activity::ACT_SHOP_COND_CHARGE_UNBINDYUANBAO_NUM:
							{
								int chargeYuanBao = GetVIPAsset().GetCredit();
								if(chargeYuanBao >= it->ParamA())
								{
									++count;
								}
							}
							break;
						case Activity::ACT_SHOP_COND_PRETASK:
							{
								int taskID = it->ParamA();
								bool tag = IsInFinishedTaskMap(taskID);
								if(tag)
								{
									++count;
								}
							}
							break;
						default:
							break;
						}
					}

					if(count == pkEntry->_kBuyConditions.size())
					{
						percentCount += pkEntry->_iRate;
						vaildConditionID.push_back(id);
					}
				}
				else
				{
					++it;
				}
			}

			int32_t randomNum = UT_MathBase::RandInRangeInt(1, percentCount);
			int num = 0;
			for(int i=0; i<vaildConditionID.size(); ++i)
			{
				int id = vaildConditionID[i];
				CF_ACTShopA::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_ACTShopA>(id);
				num += pkEntry->_iRate;
				if(num >= randomNum)
				{
					switch(pkEntry->_iType)
					{
					case SHOP_TYPE_UNBINDYUANBAO:
						m_nUnbindYuanbaoShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, id));
						break;
					case SHOP_TYPE_GUILD:
						m_nGuildShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, id));
						break;
					case SHOP_TYPE_MONEY_COURAGE:
						m_nMoneyCourageShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, id));
						break;
					case SHOP_TYPE_BOSS_JP:
						m_nBossJPShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, id));
						break;
					case SHOP_TYPE_LIMIT:
						m_nLimitShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, id));
						break;
					}
					break;
				}
			}
		}
		else
		{
			//条件不满足
			int shopID = 0;
			for(mem::set<int32_t>::iterator it=shopAID.begin(); it!=shopAID.end();)
			{
				int id = *it;
				CF_ACTShopA::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_ACTShopA>(id);
				if(pkEntry!=NULL && pkEntry->_uiRank==indexID)
				{
					if(shopID == 0)
					{
						shopID = id;
					}
					it = shopAID.erase(it);
				}
				else
				{
					++it;
				}
			}

			CF_ACTShopA::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_ACTShopA>(shopID);
			if(NULL != pkEntry)
			{
				switch(pkEntry->_iType)
				{
				case SHOP_TYPE_UNBINDYUANBAO:
					m_nUnbindYuanbaoShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, shopID));
					break;
				case SHOP_TYPE_GUILD:
					m_nGuildShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, shopID));
					break;
				case SHOP_TYPE_MONEY_COURAGE:
					m_nMoneyCourageShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, shopID));
					break;
				case SHOP_TYPE_BOSS_JP:
					m_nBossJPShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, shopID));
					break;
				case SHOP_TYPE_LIMIT:
					m_nLimitShopItemInfo.insert(std::make_pair(pkEntry->_uiRank, shopID));
					break;
				}
			}
		}
	}
}

void LC_ServerPlayer::ClearShopItem(int32_t shopType)
{
	switch(shopType)
	{
	case SHOP_TYPE_UNBINDYUANBAO:
		m_nUnbindYuanbaoShopItemInfo.clear();
		break;
	case SHOP_TYPE_GUILD:
		m_nGuildShopItemInfo.clear();
		break;
	case SHOP_TYPE_MONEY_COURAGE:
		m_nMoneyCourageShopItemInfo.clear();
		break;
	case SHOP_TYPE_BOSS_JP:
		m_nBossJPShopItemInfo.clear();
		break;
	case SHOP_TYPE_LIMIT:
		m_nLimitShopItemInfo.clear();
		break;
	}
}

void LC_ServerPlayer::UpdataACTShopInfo(int32_t scheduleID)
{
	int shopType = 0;
	if(scheduleID == GetGlobalSetting.UnbindYuanbaoShopScheduleID)
	{
		shopType = SHOP_TYPE_UNBINDYUANBAO;
	}
	else if(scheduleID == GetGlobalSetting.GuildShopScheduleID)
	{
		shopType = SHOP_TYPE_GUILD;
	}
	else if(scheduleID == GetGlobalSetting.MomeyCourageScheduleID)
	{
		shopType = SHOP_TYPE_MONEY_COURAGE;
	}
	else if(scheduleID == GetGlobalSetting.BossJPScheduleID)
	{
		shopType = SHOP_TYPE_BOSS_JP;
	}
	else if(scheduleID == GetGlobalSetting.LimitScheduleID)
	{
		shopType = SHOP_TYPE_LIMIT;
	}
	else
	{
		return;
	}

	int currentShopStartTime = GetShopStartTime(shopType);

	mem::vector<uint64_t> input;
	input.push_back(scheduleID);
	int startTime = -1;
	UT_ServerHelper::RedisGetData_Int(UT_REDIS_KEY_ACT_SHOP_START_TIME, input, startTime);
	if(startTime!=-1 && startTime>currentShopStartTime)
	{
		clearShopResetTimes(shopType);
		ClearShopItem(shopType);
		SetShopStartTime(shopType, startTime);
	}
}

void LC_ServerPlayer::GetShopItem(int32_t shopType, std::map<int32_t, int32_t>& itemInfo)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetShopItem(shopType, itemInfo);
	}

	switch(shopType)
	{
	case SHOP_TYPE_UNBINDYUANBAO:
		{
			if(m_nUnbindYuanbaoShopItemInfo.empty())
			{
				RefreshShopItem(shopType);
			}

			for(mem::map<int32_t, int32_t>::iterator it=m_nUnbindYuanbaoShopItemInfo.begin(); it!=m_nUnbindYuanbaoShopItemInfo.end(); ++it)
			{
				itemInfo.insert(std::make_pair(it->first, it->second));
			}
		}
		break;
	case SHOP_TYPE_GUILD:
		{
			if(m_nGuildShopItemInfo.empty())
			{
				RefreshShopItem(shopType);
			}

			for(mem::map<int32_t, int32_t>::iterator it=m_nGuildShopItemInfo.begin(); it!=m_nGuildShopItemInfo.end(); ++it)
			{
				itemInfo.insert(std::make_pair(it->first, it->second));
			}
		}
		break;
	case SHOP_TYPE_MONEY_COURAGE:
		{
			if(m_nMoneyCourageShopItemInfo.empty())
			{
				RefreshShopItem(shopType);
			}

			for(mem::map<int32_t, int32_t>::iterator it=m_nMoneyCourageShopItemInfo.begin(); it!=m_nMoneyCourageShopItemInfo.end(); ++it)
			{
				itemInfo.insert(std::make_pair(it->first, it->second));
			}
		}
		break;
	case SHOP_TYPE_BOSS_JP:
		{
			if(m_nBossJPShopItemInfo.empty())
			{
				RefreshShopItem(shopType);
			}

			for(mem::map<int32_t, int32_t>::iterator it=m_nBossJPShopItemInfo.begin(); it!=m_nBossJPShopItemInfo.end(); ++it)
			{
				itemInfo.insert(std::make_pair(it->first, it->second));
			}
		}
		break;
	case SHOP_TYPE_LIMIT:
		{
			if(m_nLimitShopItemInfo.empty())
			{
				RefreshShopItem(shopType);
			}

			for(mem::map<int32_t, int32_t>::iterator it=m_nLimitShopItemInfo.begin(); it!=m_nLimitShopItemInfo.end(); ++it)
			{
				itemInfo.insert(std::make_pair(it->first, it->second));
			}
		}
		break;
	default:
		return;
	}
}


bool LC_ServerPlayer::CheckShopVaild(int32_t shopType, int shopAID)
{
	bool tag = false;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return tag;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckShopVaild(shopType, shopAID);
	}

	CF_ACTShopA::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_ACTShopA>(shopAID);
	if(NULL != pkData)
	{
		switch(shopType)
		{
		case SHOP_TYPE_UNBINDYUANBAO:
			{
				mem::map<int32_t, int32_t>::iterator it = m_nUnbindYuanbaoShopItemInfo.find(pkData->_uiRank);
				if(it!=m_nUnbindYuanbaoShopItemInfo.end() && it->second==shopAID)
				{
					tag = true;
				}
			}
			break;
		case SHOP_TYPE_GUILD:
			{
				mem::map<int32_t, int32_t>::iterator it = m_nGuildShopItemInfo.find(pkData->_uiRank);
				if(it!=m_nGuildShopItemInfo.end() && it->second==shopAID)
				{
					tag = true;
				}
			}
			break;
		case SHOP_TYPE_MONEY_COURAGE:
			{
				mem::map<int32_t, int32_t>::iterator it = m_nMoneyCourageShopItemInfo.find(pkData->_uiRank);
				if(it!=m_nMoneyCourageShopItemInfo.end() && it->second==shopAID)
				{
					tag = true;
				}
			}
			break;
		case SHOP_TYPE_BOSS_JP:
			{
				mem::map<int32_t, int32_t>::iterator it = m_nBossJPShopItemInfo.find(pkData->_uiRank);
				if(it!=m_nBossJPShopItemInfo.end() && it->second==shopAID)
				{
					tag = true;
				}
			}
			break;
		case SHOP_TYPE_LIMIT:
			{
				mem::map<int32_t, int32_t>::iterator it = m_nLimitShopItemInfo.find(pkData->_uiRank);
				if(it!=m_nLimitShopItemInfo.end() && it->second==shopAID)
				{
					tag = true;
				}
			}
			break;
		default:
			return true;
		}
	}

	if(true == tag)
	{
		CF_ShopGroupOpenSetting::DataEntry* pkEntry = SafeGetCSVFileDataEntryPtr<CF_ShopGroupOpenSetting>(pkData->_uiRank);
		if(pkEntry != NULL)
		{
			int vaildConditionCount = 0;
			for(Utility::UT_SIMDataList::iterator it = pkData->_kBuyConditions.begin(); it != pkData->_kBuyConditions.end(); ++it)
			{
				switch(it->IID())
				{
				case Activity::ACT_SHOP_COND_CONTROLLER_LEVEL:
					{
						int controllerLevel = GetLevel();
						if(controllerLevel >= it->ParamA())
						{
							++vaildConditionCount;
						}
					}
					break;
				case Activity::ACT_SHOP_COND_CHARGE_UNBINDYUANBAO_NUM:
					{
						int chargeYuanBao = GetVIPAsset().GetCredit();
						if(chargeYuanBao >= it->ParamA())
						{
							++vaildConditionCount;
						}
					}
					break;
				case Activity::ACT_SHOP_COND_PRETASK:
					{
						int taskID = it->ParamA();
						bool tag = IsInFinishedTaskMap(taskID);
						if(tag)
						{
							++vaildConditionCount;
						}
					}
					break;
				default:
					break;
				}
			}

			return vaildConditionCount==pkData->_kBuyConditions.size() ? true : false;
		}
	}
	return false;
}

int32_t LC_ServerPlayer::GetShopStartTime(int32_t shopType)
{
	mem::map<int, int>::iterator it = m_ShopStartTime.find(shopType);
	if(it != m_ShopStartTime.end())
	{
		return it->second;
	}

	return 0;
}

void LC_ServerPlayer::SetShopStartTime(int32_t shopType, int32_t startTime)
{
	mem::map<int, int>::iterator it = m_ShopStartTime.find(shopType);
	if(it != m_ShopStartTime.end())
	{
		it->second = startTime;
	}
	else
	{
		m_ShopStartTime.insert(std::make_pair(shopType, startTime));
	}
}

int32_t LC_ServerPlayer::GetCollectBossJP()
{
	return m_nCollectBossJP;
}

void LC_ServerPlayer::AddCollectBossJP(int32_t value)
{
	if(value <= 0)
	{
		return;
	}

	m_nCollectBossJP += value;
	SyncCollectBossJP();
}

void LC_ServerPlayer::ResetCollectBossJP()
{
	m_nCollectBossJP = 0;
	SyncCollectBossJP();
}

void LC_ServerPlayer::SyncCollectBossJP()
{
	MG_SyncCollectBossJP msg;
	msg.m_nCollectBossJP = m_nCollectBossJP;
	SendMsgToClient(MGPT_SYNCCOLLECTBOSSJP, &msg);
}

void LC_ServerPlayer::UpdataInvestmentCardStartTime()
{
	CF_InvestmentCard::DataEntryMapExternIterator kIter = CF_InvestmentCard::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_InvestmentCard::DataEntry* pkData = kIter.PeekNextValuePtr();

		uint64_t nKey1 = LC_Helper::BuildKey(pkData->_iType, pkData->_iSchedule, 0, 0);
		int32_t startTime = UT_ServerHelper::GetBattlePassStartTime(nKey1);

		uint64_t nKey2 = LC_Helper::BuildKey(pkData->_iType, pkData->_iSchedule, startTime, 0);
		int32_t endTime = UT_ServerHelper::GetBattlePassEndTime(nKey2);

		uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		if(startTime!=0 && endTime!=0 && currentTime<endTime)
		{
			UpdateInvestmentCardActivityStartTime(pkData->_iType, startTime);
		}
	}
}

void LC_ServerPlayer::CheckInvestmentCardFinished()
{
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	CF_InvestmentCard::DataEntryMapExternIterator kIter = CF_InvestmentCard::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_InvestmentCard::DataEntry* pkData = kIter.PeekNextValuePtr();
		int32_t startTime = GetInvestmentCardActivityStartTime(pkData->_iType);
		if(startTime != 0)
		{
			uint64_t nKey = LC_Helper::BuildKey(pkData->_iType, pkData->_iSchedule, startTime, 0);
			int32_t endTime = UT_ServerHelper::GetBattlePassEndTime(nKey);
			if(endTime!=0 && currentTime>=endTime)
			{
				//活动已经结束，给玩家发奖
				investmentCardReward(pkData->_iType);
				removeInvestmentCard(pkData->_iType);
				clearInvestmentRewardRecord(pkData->_iType);
				RemoveInvestmentCardActivityStartTime(pkData->_iType);
			}
		}
	}
}

void LC_ServerPlayer::SyncInvestmentCardRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncInvestmentCardRecord();
	}

	MG_SyncInvestmentCardRecord sync;
	for(mem::set<int32_t>::iterator it=m_nInvestmentCardRecord.begin(); it!=m_nInvestmentCardRecord.end(); ++it)
	{
		sync.m_nInvestmentTypeID.push_back(*it);
	}
	SendMsgToClient(MGPT_SYNCINVESTMENTCARDRECORD, &sync);
}

ResultType LC_ServerPlayer::BuyInvestmentCard(int32_t invesmentCardType)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->BuyInvestmentCard(invesmentCardType);
	}

	CF_InvestmentCard::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_InvestmentCard>(invesmentCardType);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	//活动是否开启
	bool tag = UT_ServerHelper::CheckActivityVaild(pkData->_iSchedule);
	if(!tag)
	{
		return RE_ACTIVITY_NOT_VALID;
	}

	tag = IsInInvestmentCardRecord(invesmentCardType);
	if(tag)
	{
		return RE_INVESTMENT_CARD_ALREADY_BUY;
	}

	//钱是否够
	res = LC_Helper::CheckCashMap(this, pkData->_kPrices);
	if(res != RE_SUCCESS)
	{
		return res;
	}

	tag = addInvestmentCardRecord(invesmentCardType);
	if(!tag)
	{
		return RE_FAIL;
	}

	//扣钱
	res = LC_Helper::PayCashMap(this, pkData->_kPrices, SYS_FUNC_TP_BUY_INVESTMENT_CARD, invesmentCardType);
	if(res != RE_SUCCESS)
	{
		return res;
	}

	return RE_SUCCESS;	
}


void LC_ServerPlayer::SyncInvestmentCardRewardRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncInvestmentCardRewardRecord();
	}

	MG_SyncInvestmentCardRewardRecord sync;
	for(mem::set<int32_t>::iterator it=m_nInvestmentCardFreeRewardID.begin(); it!=m_nInvestmentCardFreeRewardID.end(); ++it)
	{
		sync.m_nFreeRewardAchievementID.push_back(*it);
	}
	for(mem::set<int32_t>::iterator it=m_nInvestmentCardHighRewardID.begin(); it!=m_nInvestmentCardHighRewardID.end(); ++it)
	{
		sync.m_nHighRewardAchievementID.push_back(*it);
	}
	SendMsgToClient(MGPT_SYNCINVESTMENTCARDREWARDRECORD, &sync);
}

ResultType LC_ServerPlayer::AddInvestmentCardReward(int id, int& rewardType)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddInvestmentCardReward(id, rewardType);
	}

	CF_InvestmentCardTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_InvestmentCardTask>(id);
	if(NULL==pkData )
		return res;
	CF_InvestmentCard::DataEntry* pkDataEntry = SafeGetCSVFileDataEntryPtr<CF_InvestmentCard>(pkData->_iType);
	if(NULL==pkDataEntry)
		return res;

	//活动是否开启
	bool tag = UT_ServerHelper::CheckActivityVaild(pkDataEntry->_iSchedule);
	if(!tag)
	{
		return RE_ACTIVITY_NOT_VALID;
	}

	CashType cashType = GetCashByInvesmentCardType(pkData->_iType);
	int64_t cashCount = GetCashNumByCashType(cashType);
	if(cashCount < pkData->_logicVal)
	{
		return LC_Helper::GetCashErrorCodeByCashType(cashType);
	}

	UT_SIMDataList rewardList;
	rewardType = getInvestmentCardReward(pkData->_iID, rewardList, false);
	if(rewardType == InvestmentReward_None)
	{
		return res;
	}

	//奖励
	if(!rewardList.empty())
	{
		StringType mailTitle;
		StringType mailDesc;
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, rewardList, this, SYS_FUNC_TP_INVESTMENT_CARD_REWARD, pkData->_iID, mailTitle, mailDesc, false);
		if(RE_SUCCESS != res)
		{
			return res;
		}
	}

	switch(rewardType)
	{
	case InvestmentReward_Free:
		{
			addFreeRewardRecord(pkData->_iID);
		}
		break;
	case InvestmentReward_High:
		{
			addHighRewardRecord(pkData->_iID);
		}
		break;
	case InvestmentReward_Both:
		{
			addFreeRewardRecord(pkData->_iID);
			addHighRewardRecord(pkData->_iID);
		}
		break;
	default:
		return RE_FAIL;
	}

	updateInvestmentCardAchievementFinished(pkData->_iID);

	return RE_SUCCESS;
}

void LC_ServerPlayer::investmentCardReward(int32_t invesmentCardType)
{	
	CF_InvestmentCard::DataEntry* pkEntryData = SafeGetCSVFileDataEntryPtr<CF_InvestmentCard>(invesmentCardType);
	if(NULL == pkEntryData)
	{
		return;
	}

	UT_SIMDataList rewardList;
	CF_InvestmentCardTask::DataEntryMapExternIterator kIter = CF_InvestmentCardTask::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_InvestmentCardTask::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(pkData->_iType==invesmentCardType && IsRewardVaild(pkData->_iID))
		{
			CashType cashType = GetCashByInvesmentCardType(invesmentCardType);
			int64_t cashCount = GetCashNumByCashType(cashType);
			if(cashCount < pkData->_logicVal)
			{
				continue;
			}
			getInvestmentCardReward(pkData->_iID, rewardList, true);
		}
	}

	//奖励发邮件
	UT_ServerHelper::SendMailToPlayer(GetInstance(), pkEntryData->_emailTitle, pkEntryData->_emailDesc, rewardList);
	ResetCash(GetCashByInvesmentCardType(invesmentCardType));
}

int32_t LC_ServerPlayer::getInvestmentCardReward(int32_t id, UT_SIMDataList& rewardList, bool addRewardRecord)
{
	int32_t rewardType = InvestmentReward_None;
	CF_InvestmentCardTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_InvestmentCardTask>(id);
	if(NULL == pkData)
	{
		return rewardType;
	}

	//判断领奖类型
	bool tag = IsInFreeRewardRecord(id);
	if(!tag)
	{
		rewardType = InvestmentReward_Free;
	}

	int32_t invesmentCardType = pkData->_iType;
	tag = IsInInvestmentCardRecord(invesmentCardType);
	if(tag && !IsInHighRewardRecord(id))
	{
		rewardType = (rewardType==InvestmentReward_None) ? InvestmentReward_High : InvestmentReward_Both;
	}

	switch(rewardType)
	{
	case InvestmentReward_Free:
		{
			for(UT_SIMDataList::iterator it=pkData->_kFreeItems.begin(); it!=pkData->_kFreeItems.end(); ++it)
			{
				rewardList.push_back(*it);
			}
		}
		break;
	case InvestmentReward_High:
		{
			for(UT_SIMDataList::iterator it=pkData->_kHighItems.begin(); it!=pkData->_kHighItems.end(); ++it)
			{
				rewardList.push_back(*it);
			}
		}
		break;
	case InvestmentReward_Both:
		{
			for(UT_SIMDataList::iterator it=pkData->_kFreeItems.begin(); it!=pkData->_kFreeItems.end(); ++it)
			{
				rewardList.push_back(*it);
			}

			for(UT_SIMDataList::iterator it=pkData->_kHighItems.begin(); it!=pkData->_kHighItems.end(); ++it)
			{
				rewardList.push_back(*it);
			}
		}
		break;
	default:
		return rewardType;
	}

	if(!addRewardRecord)
	{
		return rewardType;
	}

	switch(rewardType)
	{
	case InvestmentReward_Free:
		{
			addFreeRewardRecord(id);
		}
		break;
	case InvestmentReward_High:
		{
			addHighRewardRecord(id);
		}
		break;
	case InvestmentReward_Both:
		{
			addFreeRewardRecord(id);
			addHighRewardRecord(id);
		}
		break;
	default:
		return rewardType;
	}

	updateInvestmentCardAchievementFinished(id);
	return rewardType;
}

ResultType LC_ServerPlayer::checkInvestmentAchievementCondition(int iAchievementID, bool checkAndAdd)
{
	CAchievementManager* pkMgr = CAchievementManager::GetSingletonPtr();
	const LC_AchievementDataEntry_New* pkEntry = pkMgr->GetAchievementEntryByID(iAchievementID);
	if(NULL == pkEntry)
	{
		return RE_FAIL;
	}

	if(ACHIEVEMENT_INVESTMENT_CARD != pkEntry->_iAchievementType)
	{
		return RE_XLSX_ERROR;
	}

	ResultType res = RE_SUCCESS;
	if(checkAndAdd)
	{
		res = AddAchievementReward(iAchievementID);
	}
	else
	{
		res = CheckAchievementCanFinish(iAchievementID);
	}

	return res;
}

int32_t LC_ServerPlayer::GetInvestmentCardActivityStartTime(int32_t invesmentCardType)
{
	mem::map<int32_t, int32_t>::iterator it = m_nInvestmentCardStartTime.find(invesmentCardType);
	if(it != m_nInvestmentCardStartTime.end())
	{
		return it->second;
	}

	return 0;
}

void LC_ServerPlayer::UpdateInvestmentCardActivityStartTime(int32_t invesmentCardType, int startTime)
{
	bool tag = false;
	mem::map<int32_t, int32_t>::iterator it = m_nInvestmentCardStartTime.find(invesmentCardType);
	if(it != m_nInvestmentCardStartTime.end())
	{
		if(it->second != startTime)
		{
			tag = true;
			it->second = startTime;
		}
	}
	else
	{
		tag = true;
		m_nInvestmentCardStartTime.insert(std::make_pair(invesmentCardType, startTime));
	}

	if(tag)
	{
		ResetCash(GetCashByInvesmentCardType(invesmentCardType));
		SyncInvestmentCardRewardRecord();
		SyncInvestmentCardRecord();
	}
}

void LC_ServerPlayer::RemoveInvestmentCardActivityStartTime(int32_t invesmentCardType)
{
	m_nInvestmentCardStartTime.erase(invesmentCardType);
}

CashType LC_ServerPlayer::GetCashByInvesmentCardType(int32_t invesmentCardType)
{
	switch(invesmentCardType)
	{
	case InvestmentCard_YongZheLing:
		return CT_ACTIVE_MERIT;
	case InvestmentCard_ShouLieLing:
		return CT_REWARD_MEDAL;
	case InvestmentCard_ZhengZhanLing:
		return CT_DAILY_MERIT;
	case	InvestmentCard_RongYaoLing:
		return CT_GUILD_MERIT;
	case	InvestmentCard_JiJieLing:
		return CT_CHAPTER_HONOUR;
	case InvestmentCard_Vehicle:
		return CT_CASH_TYPE_34;
	case InvestmentCard_Devaeye:
		return CT_CASH_TYPE_35;
	case InvestmentCard_Wing:
		return CT_CASH_TYPE_36;
	}
	return CT_CASHTYPE_INVAILD;
}

bool LC_ServerPlayer::IsInInvestmentCardRecord(int32_t invesmentCardType)
{
	return m_nInvestmentCardRecord.find(invesmentCardType)!=m_nInvestmentCardRecord.end() ? true : false;
}

bool LC_ServerPlayer::addInvestmentCardRecord(int32_t invesmentCardType)
{
	return m_nInvestmentCardRecord.insert(invesmentCardType).second;
}

void LC_ServerPlayer::removeInvestmentCard(int32_t invesmentCardType)
{
	m_nInvestmentCardRecord.erase(invesmentCardType);
}

bool LC_ServerPlayer::IsInFreeRewardRecord(int32_t id)
{
	return m_nInvestmentCardFreeRewardID.find(id)!=m_nInvestmentCardFreeRewardID.end();
}

bool LC_ServerPlayer::IsInHighRewardRecord(int32_t id)
{
	return m_nInvestmentCardHighRewardID.find(id)!=m_nInvestmentCardHighRewardID.end();
}

bool LC_ServerPlayer::IsRewardVaild(int32_t id)
{
	return !(IsInFreeRewardRecord(id)&&IsInHighRewardRecord(id));
}

void LC_ServerPlayer::clearInvestmentRewardRecord(int32_t invesmentCardType)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->clearInvestmentRewardRecord(invesmentCardType);
	}

	CF_InvestmentCardTask::DataEntryMapExternIterator kIter = CF_InvestmentCardTask::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_InvestmentCardTask::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(pkData->_iType == invesmentCardType)
		{
			m_nInvestmentCardFreeRewardID.erase(pkData->_iID);
			m_nInvestmentCardHighRewardID.erase(pkData->_iID);
		}
	}
}

void LC_ServerPlayer::addFreeRewardRecord(int32_t id)
{
	m_nInvestmentCardFreeRewardID.insert(id);
}

void LC_ServerPlayer::addHighRewardRecord(int32_t id)
{
	m_nInvestmentCardHighRewardID.insert(id);
}

void LC_ServerPlayer::updateInvestmentCardAchievementFinished(int32_t id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->updateInvestmentCardAchievementFinished(id);
	}

	CF_InvestmentCardTask::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_InvestmentCardTask>(id);
	if(NULL==pkData || (pkData->_iType!=InvestmentCard_RongYaoLing && pkData->_iType!=InvestmentCard_ShouLieLing))
	{
		return;
	}

	if(IsInFreeRewardRecord(id) && IsInHighRewardRecord(id))
	{
		int achievementID = pkData->_logicVal;
		checkInvestmentAchievementCondition(achievementID, true);
	}
}

bool LC_ServerPlayer::CheckTimeLimitedActivityValid(int32_t ACTShopTimeLimitedID)
{
	for(int i=0; i<m_nTimeLimitedRecord.size(); ++i)
	{
		const TimeLimitedInfo& info = m_nTimeLimitedRecord[i];
		if(info.shopTimeLimitedID==ACTShopTimeLimitedID && info.state==ACTIVITY_IN_PROGRESS)
		{
			return true;
		}
	}

	return false;
}

void LC_ServerPlayer::SetTimeLimitedActivityState(int32_t ACTShopTimeLimitedID, ActivityState state)
{
	for(int i=0; i<m_nTimeLimitedRecord.size(); ++i)
	{
		TimeLimitedInfo& info = m_nTimeLimitedRecord[i];
		if(info.shopTimeLimitedID == ACTShopTimeLimitedID)
		{
			info.state = state;

			MG_SyncTimeLimitedActivityState syncMsg;
			syncMsg.m_activity.m_bState = info.state;
			syncMsg.m_activity.m_nID = info.id;
			syncMsg.m_activity.m_shopTimeLimitedID = info.shopTimeLimitedID;
			syncMsg.m_activity.m_nEndTimeStamp = info.endTimeStamp;
			SendMsgToClient(MGPT_SYNC_TIMELIMITED_ACTIVITY_STATE, &syncMsg);
		}
	}
	return;
}

void LC_ServerPlayer::SyncPlayerTimeLimitedActivity()
{
	MG_SyncPlayerTimeLimitedActivity syncMsg;
	for(int i=0; i<m_nTimeLimitedRecord.size(); ++i)
	{
		const TimeLimitedInfo& info = m_nTimeLimitedRecord[i];
		if(info.state == ACTIVITY_IN_PROGRESS)
		{
			PS_ActivityTimeLimitedInfo data;
			data.m_bState = info.state;
			data.m_nID = info.id;
			data.m_shopTimeLimitedID = info.shopTimeLimitedID;
			data.m_nEndTimeStamp = info.endTimeStamp;

			syncMsg.m_activetyInfo.push_back(data);
		}
	}

	SendMsgToClient(MGPT_SYNC_PLAYER_TIMELIMITED_ACTIVITY, &syncMsg);
}

void LC_ServerPlayer::TimeLimitInfoEvent(TimeLimitEvent& event)
{
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	CF_TimeLimitedActivity::DataEntry* pkEntry = NULL;
	bool tag = false;
	CF_TimeLimitedActivity::DataEntryMapExternIterator kIter = CF_TimeLimitedActivity::GetSingletonPtr()->GetIterator();
	while (kIter.HasMoreElements())
	{
		pkEntry = kIter.PeekNextValuePtr();
		if(pkEntry->_iTaskID!=0 && pkEntry->_iTaskID==event.taskID)
		{
			tag = true;
			break;
		}

		if(pkEntry->_iTransferID!=0 && pkEntry->_iTransferID==event.resMapID)
		{
			tag = true;
			break;
		}

		if(pkEntry->_iControllerLevel!=0 && pkEntry->_iControllerLevel==event.controllerLevel)
		{
			tag = true;
			break;
		}

		if(!pkEntry->_iEndLessTower.empty())
		{
			int gamestoryID = pkEntry->_iEndLessTower[0].IID();
			int process = pkEntry->_iEndLessTower[0].ParamA();

			if(event.storyID==gamestoryID && event.floorID==process)
			{
				tag = true;
				break;
			}
		}

		kIter.MoveNext();
	}

	if(tag)
	{
		//checkCreditValue
		int shopTimeLimitedID = 0;
		int creditValue = GetVIPAsset().GetCredit();

		int id = 0;
		Utility::UT_SIMDataList& creditMoney = pkEntry->_iTimeLimtedSchedleIDs;		
		for(UT_SIMDataList::iterator it=creditMoney.begin(); it!=creditMoney.end(); ++it)
		{
			if(creditValue >= it->IID())
			{
				id = it->ParamA();
			}
			else
			{
				break;
			}	
		}

		shopTimeLimitedID = id;
		int flag = false;
		for(int i=0; i<m_nTimeLimitedRecord.size(); ++i)
		{
			if(m_nTimeLimitedRecord[i].id == pkEntry->_iID)
			{
				flag = true;
				break;
			}
		}

		if(!flag)
		{
			TimeLimitedInfo info;
			info.id = pkEntry->_iID;
			info.shopTimeLimitedID = shopTimeLimitedID;
			info.endTimeStamp = currentTime + pkEntry->_iVaildTime*ONE_MINUTE_SECONDS;
			m_nTimeLimitedRecord.push_back(info);

			SetTimeLimitedActivityState(info.shopTimeLimitedID, ACTIVITY_IN_PROGRESS);
		}
	}

}

void LC_ServerPlayer::UpdateTimeLimitedActivity()
{
	uint32_t Time = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	for(int i=0; i<m_nTimeLimitedRecord.size(); ++i)
	{
		if(ACTIVITY_IN_PROGRESS==m_nTimeLimitedRecord[i].state && m_nTimeLimitedRecord[i].endTimeStamp<=Time)
		{
			SetTimeLimitedActivityState(m_nTimeLimitedRecord[i].shopTimeLimitedID, ACTIVITY_OVERTIME);
		}
	}
}

ResultType LC_ServerPlayer::AssignRewardTask(int assignChannel, int endTime)
{
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
		return RE_FAIL;
	}

	uint32_t assignType = pkTaskManager->GetAssignType(STT_REWARD_TASK);
	if(0==assignType)
	{
		return RE_FAIL;
	}

	bool refreshByClient = false;
	switch(assignChannel)
	{
	case AssignRewardTaskType_Activity:
	case AssignRewardTaskType_OpenLevel:
		{
			if(0!=endTime && endTime == GetRewardTaskEndTime())
			{
				return RE_SUCCESS;
			}

			ClearAssignTask(assignType);
		}		
		break;
	case AssignRewardTaskType_FinishAssignTask:
		break;
	case AssignRewardTaskType_PlayerRefresh:
		refreshByClient = true;
		break;
	default:
		return RE_FAIL;
	}

	ResultType res = pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_REWARD_TASK), refreshByClient);
	if(RE_SUCCESS==res && endTime!=0)
	{
		SetRewardTaskEndTime(endTime);
	}
	return res;
}

ResultType LC_ServerPlayer::RefreshRewardTask()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RefreshRewardTask();
	}

	//活动是否开启
	bool tag = UT_ServerHelper::CheckActivityVaild(GetGlobalSetting.RewardTaskActivityScheduleID_1);
	if(!tag)
	{
		return RE_ACTIVITY_NOT_VALID;
	}

	ResultType res = RE_FAIL;
	bool cost = false;
	int refreshTime = GetRefreshRewardTaskTimes();
	if(refreshTime >= GetGlobalSetting.RefreshFreeTimes)
	{
		cost = true;
	}

	Utility::LC_ComMap consumeMap;
	int payTimes = 0;
	if(cost)
	{
		//钱够不
		payTimes = refreshTime-GetGlobalSetting.RefreshFreeTimes;
		int money = GetGlobalSetting.RefreshCostNumInit + (payTimes*GetGlobalSetting.RefreshCostNumPlus);	
		consumeMap.insert(std::make_pair(GetGlobalSetting.RefreshType, money));
		res = LC_Helper::CheckCashMap(this, consumeMap);
		if(RE_SUCCESS != res)
		{
			return res;
		}
	}
	//悬赏任务--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(refreshTime+1);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, OFFERAWARD_OPERATE,OPERATE_LOGTYPE2);
	//刷新
	res = AssignRewardTask(AssignRewardTaskType_PlayerRefresh);
	if(RE_SUCCESS == res)
	{
		AddRefreshRewardTaskTimes();

		if(cost)
		{//扣钱
			res = LC_Helper::PayCashMap(this, consumeMap, SYS_FUNC_TP_REFRESH_REWARDTASK, payTimes+1,1,false,nLogCode);
		}
	}
	return res;


	/*
	int vipLevel = GetVIPAsset().GetVIPLevel();
	LC_VIPCmnManager* pkMgr = LC_VIPCmnManager::GetSingletonPtr();
	if(pkMgr == NULL)
	{
	return RE_FAIL;
	}

	LC_VIPProfitDataEntry* pkDataEntry = pkMgr->GetVIPProfitDataEntry(VIP_PROFIT_REFRESH_TIMES);
	if(pkDataEntry == NULL)
	{
	return RE_FAIL;
	}

	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
	return RE_FAIL;
	}

	int totalTimes = pkDataEntry->GetValue(vipLevel, false);
	if(totalTimes < 1)
	{
	return RE_REFRESH_REWARDTASK_VIPLEVEL_ERROR;
	}

	int refreshTime = GetRefreshRewardTaskTimes();
	if(refreshTime >= totalTimes)
	{
	return RE_REFRESH_REWARDTASK_TIMES_BE_LIMITED;
	}

	uint32_t assignType = pkTaskManager->GetAssignType(STT_REWARD_TASK);
	LC_AssignTaskInfo* pkAssignTaskInfo = m_pkTaskMap->GetAssignTaskInfo();
	if(NULL==pkAssignTaskInfo || 0==assignType)
	{
	return RE_FAIL;
	}

	int preCount = pkAssignTaskInfo->GetAssignTaskCount(assignType);

	//钱够不
	Utility::LC_ComMap consumeMap;
	int money = GetGlobalSetting.RefreshCostNumInit + (refreshTime * GetGlobalSetting.RefreshCostNumPlus);	
	consumeMap.insert(std::make_pair(GetGlobalSetting.RefreshType, money));
	ResultType res = LC_Helper::CheckCashMap(this, consumeMap);
	if(RE_SUCCESS != res)
	{
	return res;
	}

	//刷新
	pkTaskManager->AssignTask(this, pkTaskManager->GetAssignType(STT_REWARD_TASK), true);

	//现在派发的任务
	int currentCount = pkAssignTaskInfo->GetAssignTaskCount(assignType);
	if(currentCount > preCount)
	{
	AddRefreshRewardTaskTimes();
	//扣钱
	res = LC_Helper::PayCashMap(this, consumeMap, SYS_FUNC_TP_REFRESH_REWARDTASK, refreshTime+1);
	}
	return res;
	*/
}

void LC_ServerPlayer::SyncRefreshRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncRefreshRewardTaskTimes();
	}

	MG_SyncRefreshRewardTaskTimes sync;
	sync.m_nTimes = GetRefreshRewardTaskTimes();
	SendMsgToClient(MGPT_SYNCREFRESHREWARDTASKTIMES, &sync);
}

int32_t LC_ServerPlayer::AddRefreshRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddRefreshRewardTaskTimes();
	}

	++m_nRefreshRewardTaskTimes;

	SyncRefreshRewardTaskTimes();
	return m_nRefreshRewardTaskTimes;
}

int32_t LC_ServerPlayer::GetRefreshRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRefreshRewardTaskTimes();
	}

	return m_nRefreshRewardTaskTimes;
}

void LC_ServerPlayer::ResetRefreshRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetRefreshRewardTaskTimes();
	}

	m_nRefreshRewardTaskTimes = 0;

	SyncRefreshRewardTaskTimes();
}

bool LC_ServerPlayer::CheckRefreshRewardTask()
{
	//派发的悬赏任务全部完成后，重新刷新悬赏任务

	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return false;
		return pkOwnerPlayer->CheckRefreshRewardTask( );
	}
	LC_ServerTaskManager* pkTaskManager = (LC_ServerTaskManager*)LC_TaskManager::GetSingletonPtr();
	if(NULL == pkTaskManager)
	{
		return false;
	}

	LC_AssignTaskInfo* pkAssignTaskInfo = m_pkTaskMap->GetAssignTaskInfo();

	uint32_t assignType = pkTaskManager->GetAssignType(STT_REWARD_TASK);
	LC_AssignTaskData* pkAssignTaskData = pkAssignTaskInfo->GetAssignTaskData(assignType);
	if(NULL == pkAssignTaskData)
	{
		return false;
	}

	TaskIDSet taskIDs = pkAssignTaskData->GetAssignTaskIDs();
	if(taskIDs.empty())
	{
		return false;
	}

	for(TaskIDSet::iterator it=taskIDs.begin(); it!=taskIDs.end(); ++it)
	{
		if(!IsInFinishedTaskMap(*it))
		{
			return false;
		}
	}

	//全部完成了
	ClearAssignTask(assignType);
	AssignRewardTask(AssignRewardTaskType_FinishAssignTask, 0);
	return true;
}

int LC_ServerPlayer::GetAcceptRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return -1;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAcceptRewardTaskTimes();
	}

	return m_nAcceptRewardTaskTimes;
}

void LC_ServerPlayer::ModifyAcceptRewardTaskTimes(bool add, int value)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ModifyAcceptRewardTaskTimes(add, value);
	}

	if(0 == value)
	{
		return;
	}

	bool tag = false;
	if(add)
	{
		m_nAcceptRewardTaskTimes += value;
		tag = true;
	}
	else if(m_nAcceptRewardTaskTimes >= value)
	{
		m_nAcceptRewardTaskTimes -= value;
		tag = true;
	}
	else
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "ModifyAcceptRewardTaskTimes param error! c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAcceptRewardTaskTimes:%d, value:%d, oper:%d\n", 
			instance.detail(), instance.catagory(), GetUserID(), m_nAcceptRewardTaskTimes, value, add);
	}

	if(tag)
	{
		SyncAcceptRewardTaskTimes();
	}
}

void LC_ServerPlayer::ResetAcceptRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetAcceptRewardTaskTimes();
	}

	m_nAcceptRewardTaskTimes = 0;
	SyncAcceptRewardTaskTimes();
}

void LC_ServerPlayer::SyncAcceptRewardTaskTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncAcceptRewardTaskTimes();
	}

	MG_SyncAcceptRewardTaskTimes msg;
	msg.m_nAcceptRewardTaskTimes = m_nAcceptRewardTaskTimes;
	SendMsgToClient(MGPT_SYNCACCEPTREWARDTASKTIMES, &msg);
}

int32_t LC_ServerPlayer::GetRewardTaskEndTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRewardTaskEndTime();
	}

	return m_nRewardTaskEndTime;
}

void LC_ServerPlayer::SetRewardTaskEndTime(int32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetRewardTaskEndTime(time);
	}

	m_nRewardTaskEndTime = time;
}

ResultType LC_ServerPlayer::GetChapterRaidStarReward(int chapterID, int rewardIndex)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetChapterRaidStarReward(chapterID, rewardIndex);
	}

	int starNum = GetRaidStarNumByChapterID(chapterID);

	//星星是否够
	CF_GloryExpedition::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_GloryExpedition>(chapterID);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	bool tag = false;
	UT_SIMDataList reward;
	switch(rewardIndex)
	{
	case 1:
		{
			tag = starNum>=pkData->_iStarNumber1 ? true : false;
			reward = pkData->_kReward1;
			break;
		}
	case 2:
		{
			tag = starNum>=pkData->_iStarNumber2 ? true : false;
			reward = pkData->_kReward2;
			break;
		}
	case 3:
		{
			tag = starNum>=pkData->_iStarNumber3 ? true : false;
			reward = pkData->_kReward3;
			break;
		}
	default:
		return RE_FAIL;
	}

	if(!tag)
	{
		return RE_CHAPTER_RAID_STARNUM_NOT_ENOUGH;
	}

	//是否已经领过了
	mem::map<int, mem::vector<int> >::iterator findIt = m_nChapterRewardRecord.find(chapterID);
	if(findIt != m_nChapterRewardRecord.end())
	{
		mem::vector<int>::iterator it = find(findIt->second.begin(), findIt->second.end(), rewardIndex);
		if(it != findIt->second.end())
		{
			return RE_CHAPTER_RAID_STARNUM_REWARD_HAS_GET;
		}
	}
	//荣光远征进度奖励--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(chapterID);
	nParams.push_back(rewardIndex);
	int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN9_OPERATE, OPERATE_LOGTYPE4);
	//领奖
	StringType mailTilte;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, reward, this,SYS_FUNC_TP_CHAPTER_RAIDSTRANUM_REWARD, chapterID, mailTilte, mailDesc, false, false,false,nLogCode,nParams);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	UpdateChapterRaidStarRewardRecord(chapterID, rewardIndex);

	return RE_SUCCESS;
}

void LC_ServerPlayer::AddRaidStarNumByChapterID(int mapID, int chapterID, int num)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer || num<0)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddRaidStarNumByChapterID(mapID, chapterID, num);
	}

	int chapterCount = 0;	
	mem::map<int, int>::iterator findIt = m_nChapterRaidStarNum.find(chapterID);
	if(findIt != m_nChapterRaidStarNum.end())		
	{
		findIt->second += num;
		chapterCount = findIt->second;
	}
	else
	{
		m_nChapterRaidStarNum.insert(std::make_pair(chapterID, num));
		chapterCount = num;
	}

	SyncChapterRaidStarNum(chapterID, chapterCount);
	AddTotalRaidStarNum(num);
}

int32_t LC_ServerPlayer::GetRaidStarNumByChapterID(int chapterID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRaidStarNumByChapterID(chapterID);
	}

	mem::map<int, int>::iterator findIt = m_nChapterRaidStarNum.find(chapterID);
	if(findIt != m_nChapterRaidStarNum.end())
	{
		return findIt->second;
	}

	return 0;
}

int32_t LC_ServerPlayer::GetRaidStarNum()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRaidStarNum();
	}

	return m_nTotalRaidStarNum;
}

void LC_ServerPlayer::SyncTotalRaidStarNum()
{
	MG_SyncTotalRaidStarNum sync;
	sync.m_nTotalStarNum = m_nTotalRaidStarNum;
	SendMsgToClient(MGPT_SYNCTOTALRAIDSTARNUM, &sync);
}

void LC_ServerPlayer::SyncAllChapterRaidStarNum()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncAllChapterRaidStarNum();
	}

	for(mem::map<int, int>::iterator it=m_nChapterRaidStarNum.begin(); it!=m_nChapterRaidStarNum.end(); ++it)
	{
		SyncChapterRaidStarNum(it->first, it->second);
	}
}

void LC_ServerPlayer::SyncAllChapterRaidStarRewardRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncAllChapterRaidStarRewardRecord();
	}

	for(mem::map<int, mem::vector<int> >::iterator it=m_nChapterRewardRecord.begin(); it!=m_nChapterRewardRecord.end(); ++it)
	{
		SyncChapterRaidStarRewardRecord(it->first);
	}
}

void LC_ServerPlayer::UpdateChapterRaidStarRewardRecord(int chapterID, int rewardIndex)
{
	mem::map<int, mem::vector<int> >::iterator findIt = m_nChapterRewardRecord.find(chapterID);
	if(findIt != m_nChapterRewardRecord.end())
	{
		findIt->second.push_back(rewardIndex);
	}
	else
	{
		mem::vector<int> vec;
		vec.push_back(rewardIndex);
		m_nChapterRewardRecord.insert(std::make_pair(chapterID, vec));
	}

	SyncChapterRaidStarRewardRecord(chapterID);
}

int32_t LC_ServerPlayer::AddTotalRaidStarNum(int32_t num)
{
	if(num <= 0)
	{
		return m_nTotalRaidStarNum;
	}

	m_nTotalRaidStarNum += num;

	SyncTotalRaidStarNum();

	return m_nTotalRaidStarNum;
}

uint64_t LC_ServerPlayer::GetRongGuangYuanZhengMapValue()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRongGuangYuanZhengMapValue();
	}

	return LC_Helper::EncodeScore(GetFinishMaxMapIDByStoryID(GameStoryIDType_GloryExpedition), m_nTotalRaidStarNum);
}

void LC_ServerPlayer::SyncChapterRaidStarNum(int chapterID, int num)
{
	MG_SyncChapterRaidStarNum msg;
	msg.m_nChapterID = chapterID;
	msg.m_nChapterStarNum = num;
	SendMsgToClient(MGPT_SYNCCHAPTERRAIDSTARNUM, &msg);
}

void LC_ServerPlayer::SyncChapterRaidStarRewardRecord(int chapterID)
{
	mem::map<int, mem::vector<int> >::iterator findIt = m_nChapterRewardRecord.find(chapterID);
	if(findIt != m_nChapterRewardRecord.end())
	{
		MG_SyncChapterRaidStarRewardRecord msg;
		msg.m_nChapterID = chapterID;
		for(int i=0; i<findIt->second.size(); ++i)
		{
			msg.m_nRewardIndex.push_back(findIt->second[i]);
		}

		SendMsgToClient(MGPT_SYNCCHAPTERRAIDSTARREWARDRECORD, &msg);
	}
}

void LC_ServerPlayer::LoadRongGuangYuanZhengData(const ::char_data_define::PBRongGuangYuanZheng& data)
{
	for(int i=0; i<data.chapterrewardrecord_size(); ++i)
	{
		mem::vector<int> vec;
		vec.reserve(data.chapterrewardrecord(i).rewardindex_size());
		for(int j=0; j<data.chapterrewardrecord(i).rewardindex_size(); ++j)
		{
			vec.push_back(data.chapterrewardrecord(i).rewardindex(j));
		}

		int chapterID = data.chapterrewardrecord(i).chapterid();
		m_nChapterRewardRecord.insert(std::make_pair(chapterID, vec));
	}

	for(int i=0; i<data.chapterraidstarnum_size(); ++i)
	{
		m_nChapterRaidStarNum.insert(std::make_pair(data.chapterraidstarnum(i).chapterid(), data.chapterraidstarnum(i).raidstarnum()));
	}

	m_nTotalRaidStarNum = data.totalraidstarnum();

	GetYuanZhengPointAsset().LoadData(data.yuanzhengpoint());
}

void LC_ServerPlayer::SaveRongGuangYuanZhengData(::char_data_define::PBRongGuangYuanZheng* pkData)
{
	if(NULL == pkData)
	{
		return;
	}

	for(mem::map<int, mem::vector<int> >::iterator it=m_nChapterRewardRecord.begin(); it!=m_nChapterRewardRecord.end(); ++it)
	{
		::char_data_define::char_ChapterRewardRecord* data = pkData->add_chapterrewardrecord();
		data->set_chapterid(it->first);
		for(int j=0; j<it->second.size(); ++j)
		{
			data->add_rewardindex(it->second[j]);
		}
	}

	for(mem::map<int, int>::iterator it=m_nChapterRaidStarNum.begin(); it!=m_nChapterRaidStarNum.end(); ++it)
	{
		::char_data_define::char_ChapterRaidStarNum* data = pkData->add_chapterraidstarnum();
		data->set_chapterid(it->first);
		data->set_raidstarnum(it->second);
	}

	pkData->set_totalraidstarnum(m_nTotalRaidStarNum);

	GetYuanZhengPointAsset().SaveData(pkData->mutable_yuanzhengpoint());
}

void LC_ServerPlayer::GetSubEquipAttr(int32_t subType, LC_ActorAttributeMap* pkAttrMap, int& nAppendixScore)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->GetSubEquipAttr(pkAttrMap, nAppendixScore);
}

void LC_ServerPlayer::GetSubEquipSlotMoldingAttr(int subType, LC_ActorAttributeMap* pkAttrMap)
{
	if(NULL == pkAttrMap)
	{
		return;
	}

	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->GetSubEquipSlotMoldingAttr(this, pkAttrMap);
}

void LC_ServerPlayer::GetSubEquipSlotMoldingSuitValueAttr(int subType, LC_ActorAttributeMap* pkAttrMap)
{
	if(NULL == pkAttrMap)
	{
		return;
	}

	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->GetSubEquipSlotMoldingSuitValueAttr(pkAttrMap);
}

void LC_ServerPlayer::GetSubEquipSlotMoldingSuitPercentAttr(int subType, LC_ActorAttributeMap* pkAttrMap)
{
	if(NULL == pkAttrMap)
	{
		return;
	}

	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->GetSubEquipSlotMoldingSuitPercentAttr(pkAttrMap);
}

void LC_ServerPlayer::EquipSubItem(int32_t subType, int32_t srcSlotIndex)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->EquipSubItem(this, srcSlotIndex);
}

void LC_ServerPlayer::UnEquipSubItem(int32_t subType, int32_t srcSlotIndex)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->UnEquipSubItem(this, srcSlotIndex);
}


void LC_ServerPlayer::SubEquipAdvance(int32_t subType, int32_t slotIndex)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->SubEquipAdvance(this, slotIndex);
}

int32_t LC_ServerPlayer::GetControllerEquipSlotMoldingSpiritLevel(int slotIndex)
{
	return GetCommandEquipPack().GetEquipSuiteId(slotIndex);
}

int32_t LC_ServerPlayer::GetControllerEquipSlotReinforceLevel(int slotIndex)
{
	return GetCommandEquipPack().GetEquipIntensifyLevel(slotIndex);
}

int32_t LC_ServerPlayer::GetControllerEquipSlotRefineLevel(int slotIndex)
{
	return GetCommandEquipPack().GetEquipRefineLevel(slotIndex);
}

void LC_ServerPlayer::UpgradeSubStage(int32_t subType, int stage)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL==pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpgradeSubStage(subType, stage);
	}

	LC_SubUpgradeData* pkSub = GetSubordinateAsset().GetSubData(subType);
	if (NULL == pkSub)
	{
		return;
	}

	int32_t preStage= pkSub->GetStage();
	uint64_t preCombatScore = GetSumSubSystemCombatScore(subType);
	GetSubordinateAsset().UpgradeSubStage(subType, stage);
	int32_t curStage = pkSub->GetStage();

	int32_t reasonType = SPART_None;
	switch(subType)
	{
	case LC_SUB_TP_VEHICLE:
		reasonType = SPART_Sub_Vehicle_1;
		break;
	case LC_SUB_TP_DEVA_EYE:
		reasonType = SPART_Sub_Devaeye_1;
		break;
	case LC_SUB_TP_MUHUN:
		reasonType = SPART_Sub_Wing_1;
		break;
	case LC_SUB_TP_TALISMAN:
		reasonType = SPART_Sub_MingHao_1;
		break;
	}
	GetCommanderAttrMgr().RefreshAllSubAttributeMap(this, false, reasonType, subType);

	if(preStage != curStage)
	{
		MG_SyncUseItemUpgradeSub syncMsg;
		syncMsg.m_nSubType = subType;
		syncMsg.m_nSubCurrentStage = curStage;
		syncMsg.m_nPreCombatScore = preCombatScore;
		syncMsg.m_nCurCombatScore = GetSumSubSystemCombatScore(subType);		
		SendMsgToClient(MGPT_SYNC_USEITEMUPGRADESUB, &syncMsg);
	}
	
	bool bDirty;
	SyncSubordinateInfo(bDirty);
	SetDirtyFlag(DIRTY_FLAG_SUBORDINATE_INFO, false);
}

mem::map<int, int>* LC_ServerPlayer::GetControllerMoldingSpiritSuitInfo()
{
	return GetCommandEquipPack().GetControllerMoldingSpiritSuitInfo();
}

void LC_ServerPlayer::GetSubEquipItemInfo(int32_t subType, std::map<int32_t,PS_SubEquipSlotItemInfo>& data)
{
	data.clear();
	CCommanderSubEquipPack* pkSubPack = GetSubEquipPackByType(subType);
	if(NULL != pkSubPack)
	{
		pkSubPack->GetItemInfo(data);
	}
}

CCommanderSubEquipPack* LC_ServerPlayer::GetSubEquipPackByType(int32_t subType)
{
	switch(subType)
	{
	case LC_SUB_TP_VEHICLE:
		{
			return &m_nCommanderSubEquipPack_Vehicle;
		}
	case LC_SUB_TP_DEVA_EYE:
		{
			return &m_nCommanderSubEquipPack_DevaEye;
		}
	case LC_SUB_TP_MUHUN:
		{
			return &m_nCommanderSubEquipPack_Muhun;
		}		
	}
	return NULL;
}

void LC_ServerPlayer::UpdateSubAttributeMapBySubType(int32_t subType, LC_ActorAttributeMap& attrMap)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->UpdateSubAttributeMap(this);
	LC_ActorAttributeMap* pkAttr = pkSubEquipPack->GetAttributeMap();
	if(NULL != pkAttr)
	{
		attrMap.CopyFrom(pkAttr);
	}
}

void LC_ServerPlayer::EquipAllSubItem(bool login)
{
	int arr[] = {LC_SUB_TP_VEHICLE, LC_SUB_TP_DEVA_EYE, LC_SUB_TP_MUHUN};
	for(int i=0; i<sizeof(arr)/sizeof(arr[0]); ++i)
	{
		int subType = arr[i];
		CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
		if(NULL != pkSubEquipPack)
		{
			pkSubEquipPack->EquipAllSubItem(this);
		}
	}

	GetCommanderAttrMgr().RefreshAllSubAttributeMap(this, login);
}

void LC_ServerPlayer::UpdateSubEquipSlotMoldingSpiritLevel(int32_t subType, int32_t slotIndex)
{
	CCommanderSubEquipPack* pkSubEquipPack = GetSubEquipPackByType(subType);
	if(NULL == pkSubEquipPack)
	{
		return;
	}

	pkSubEquipPack->UpdateSubEquipSlotMoldingSpirit(this, slotIndex);
}

void LC_ServerPlayer::UpdateStoryEndTime(int storyID, int32_t time)
{
	switch(storyID)
	{
	case GameStoryIDType_Monkey:
		UpdateYiJiTuXiEndTime(time);
		break;
	case GameStoryIDType_Chest:
		UpdateYiJiXunBaoEndTime(time);
		break;
	case GameStoryIDType_PetIsland:
		UpdatePetIslandsEndTime(time);
		break;
	}
}

ResultType LC_ServerPlayer::GetYiJiTuXiStageReward(int id)
{
	CF_YiJiTuXiStageReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_YiJiTuXiStageReward>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	bool tag = UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Monkey);
	if(!tag)
	{
		return RE_DOMAIN_NOT_OPEN;
	}

	tag = GetYiJiTuXiRewardID(id);
	if(tag)
	{
		return RE_ALREADY_GET_REWARD;
	}
	
	int num = GetCashType29().GetMoney();
	if(num < pkData->_KillCount)
	{
		return RE_NUM_BE_LIMITED;
	}

	tag = GetYiJiTuXiRewardID(pkData->_preRewardId);
	if(!tag)
	{
		return RE_PRE_REWARD_NOT_GET;
	}
	//遗迹突袭--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(id);
	int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN3_OPERATE, OPERATE_LOGTYPE2);
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_Reward, this, SYS_FUNC_TP_YIJITUXI_STAGE_REWARD, id, mailTitle, mailDesc, false, false,false, nLogCode);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	AddYiJiTuXiRewardID(id, true);

	return res;
}

bool LC_ServerPlayer::GetYiJiTuXiRewardID(int id)
{
	if(0 == id)
	{
		return true;
	}

	for(int i=0; i<m_nYiJiTuXiStageRewardRecord.size(); ++i)
	{
		if(m_nYiJiTuXiStageRewardRecord[i] == id)
		{
			return true;
		}
	}

	return false;
}

void LC_ServerPlayer::AddYiJiTuXiRewardID(int id, bool sync)
{
	m_nYiJiTuXiStageRewardRecord.push_back(id);

	if(sync)
	{
		SyncYiJiTuXiRewardRecord();
	}
}

void LC_ServerPlayer::SyncYiJiTuXiRewardRecord(bool checkVaild)
{
	if(checkVaild && false==UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Monkey))
	{
		return;
	}

	MG_SyncYiJiTuXiRewardRecord msg;
	for(int i=0; i<m_nYiJiTuXiStageRewardRecord.size(); ++i)
	{
		msg.m_nRewardIDRecord.push_back(m_nYiJiTuXiStageRewardRecord[i]);
	}

	SendMsgToClient(MGPT_SYNCYIJITUXIREWARDRECORD, &msg);
}

void LC_ServerPlayer::SendYiJiTuXiReward()
{
	if(m_nYiJiTuXiSendFlag)
	{
		return;
	}

	GameStory::LC_GameStory_Manager* pkGameStoryMgr =  SERVER_GET_GAMESTORY_MANAGER;
	if(NULL == pkGameStoryMgr)
	{
		return;
	}


	int killNum = GetCashType29().GetMoney();

	Utility::UT_SIMDataList rewardList;
	CF_YiJiTuXiStageReward::DataEntryMapExternIterator kIter = CF_YiJiTuXiStageReward::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_YiJiTuXiStageReward::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(killNum>=pkData->_KillCount && !GetYiJiTuXiRewardID(pkData->_iID))
		{
			for(UT_SIMDataList::iterator it=pkData->_Reward.begin(); it!=pkData->_Reward.end(); ++it)
			{
				rewardList.push_back(*it);
			}

			AddYiJiTuXiRewardID(pkData->_iID);
		}
	}

	if(!rewardList.empty())
	{
		//遗迹突袭--埋点日志
		int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN3_OPERATE, OPERATE_LOGTYPE2);
		UT_ServerHelper::SendMailToPlayer(GetInstance(), "59;", "60;", rewardList, false, nLogCode);
	}

	m_nYiJiTuXiSendFlag = true;
	ResetYiJiTuXiRewardRecord();
}

void LC_ServerPlayer::ResetYiJiTuXiRewardRecord(int32_t time)
{
	m_nYiJiTuXiStageRewardRecord.clear();
	SyncYiJiTuXiRewardRecord();

	UpdateYiJiTuXiEndTime(time);

	ClearResetAllCommonStatFlag(GameStoryIDType_Monkey);
}

void LC_ServerPlayer::UpdateYiJiTuXiEndTime(uint32_t endTime)
{
	m_nYiJiTuXiEndTime = endTime;

	if(0 != endTime)
	{
		m_nYiJiTuXiSendFlag = false;
	}
}

int32_t LC_ServerPlayer::GetYiJiTuXiEndTime()
{
	return m_nYiJiTuXiEndTime;
}

ResultType LC_ServerPlayer::GetYiJiXunBaoStageReward(int id)
{
	int32_t storyID = GameStoryIDType_Chest;
	CF_YiJiXunBaoStageReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_YiJiXunBaoStageReward>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	GameStory::LC_GameStory_Manager* pkGameStoryMgr =  SERVER_GET_GAMESTORY_MANAGER;
	if(NULL == pkGameStoryMgr)
	{
		return RE_FAIL;
	}

	bool tag = UT_ServerHelper::CheckStoryIsActive(storyID);
	if(!tag)
	{
		return RE_DOMAIN_NOT_OPEN;
	}

	tag = GetYiJiXunBaoRewardID(id);
	if(tag)
	{
		return RE_ALREADY_GET_REWARD;
	}

	int killNum = pkGameStoryMgr->GetKillSpecialMonsterCount(this, storyID);

	if(killNum < pkData->_KillCount)
	{
		return RE_NUM_BE_LIMITED;
	}

	tag = GetYiJiXunBaoRewardID(pkData->_preRewardId);
	if(!tag)
	{
		return RE_PRE_REWARD_NOT_GET;
	}
	//遗迹寻宝--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(id);
	int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN4_OPERATE, OPERATE_LOGTYPE2);
	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_Reward, this, SYS_FUNC_TP_YIJIXUNBAO_STAGE_REWARD, id, mailTitle, mailDesc, false, true,false,nLogCode,nParams);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	AddYiJiXunBaoRewardID(id, true);

	return res;
}

bool LC_ServerPlayer::GetYiJiXunBaoRewardID(int id)
{
	if(0 == id)
	{
		return true;
	}

	for(int i=0; i<m_nYiJiXunBaoStageRewardRecord.size(); ++i)
	{
		if(m_nYiJiXunBaoStageRewardRecord[i] == id)
		{
			return true;
		}
	}

	return false;
}

void LC_ServerPlayer::AddYiJiXunBaoRewardID(int id, bool sync)
{
	m_nYiJiXunBaoStageRewardRecord.push_back(id);

	if(sync)
	{
		SyncYiJiXunBaoRewardRecord();
	}
}

void LC_ServerPlayer::SyncYiJiXunBaoRewardRecord(bool checkVaild)
{
	if(checkVaild && false==UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Chest))
	{
		return;
	}

	MG_SyncYiJiXunBaoRewardRecord msg;
	for(int i=0; i<m_nYiJiXunBaoStageRewardRecord.size(); ++i)
	{
		msg.m_nRewardIDRecord.push_back(m_nYiJiXunBaoStageRewardRecord[i]);
	}

	SendMsgToClient(MGPT_SYNCYIJIXUNBAOREWARDRECORD, &msg);
}

void LC_ServerPlayer::SendYiJiXunBaoReward()
{
	if(m_nYiJiXunBaoSendFlag)
	{
		return;
	}

	GameStory::LC_GameStory_Manager* pkGameStoryMgr =  SERVER_GET_GAMESTORY_MANAGER;
	if(NULL == pkGameStoryMgr)
	{
		return;
	}

	int killNum = pkGameStoryMgr->GetKillSpecialMonsterCount(this, GameStoryIDType_Chest);

	Utility::UT_SIMDataList rewardList;
	CF_YiJiXunBaoStageReward::DataEntryMapExternIterator kIter = CF_YiJiXunBaoStageReward::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_YiJiXunBaoStageReward::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(killNum>=pkData->_KillCount && !GetYiJiXunBaoRewardID(pkData->_iID))
		{
			for(UT_SIMDataList::iterator it=pkData->_Reward.begin(); it!=pkData->_Reward.end(); ++it)
			{
				rewardList.push_back(*it);
			}

			AddYiJiXunBaoRewardID(pkData->_iID);
		}
	}

	UT_ServerHelper::SendMailToPlayer(GetInstance(), "61;", "62;", rewardList);

	m_nYiJiXunBaoSendFlag = true;
	ResetYiJiXunBaoRewardRecord();
}

int32_t LC_ServerPlayer::GetYiJiXunBaoEndTime()
{
	return m_nYiJiXunBaoEndTime;
}

void LC_ServerPlayer::ResetYiJiXunBaoRewardRecord(int32_t time)
{
	m_nYiJiXunBaoStageRewardRecord.clear();
	SyncYiJiXunBaoRewardRecord();

	UpdateYiJiXunBaoEndTime(time);
	ClearResetAllCommonStatFlag(GameStoryIDType_Chest);
	
	if(0 != time)
	{
		m_nYiJiXunBaoSendFlag = false;
	}
}

ResultType LC_ServerPlayer::GetPetIslandsStageReward(int id)
{
	int storyID = GameStoryIDType_PetIsland1;
	CF_PetIslandStageReward::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_PetIslandStageReward>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	GameStory::LC_GameStory_Manager* pkGameStoryMgr =  SERVER_GET_GAMESTORY_MANAGER;
	if(NULL == pkGameStoryMgr)
	{
		return RE_FAIL;
	}

	bool tag = UT_ServerHelper::CheckStoryIsActive(storyID);
	if(!tag)
	{
		return RE_DOMAIN_NOT_OPEN;
	}

	tag = GetPetIslandsRewardID(id);
	if(tag)
	{
		return RE_ALREADY_GET_REWARD;
	}

	int killNum = pkGameStoryMgr->GetKillSpecialMonsterCount(this, storyID);
	if(killNum < pkData->_KillCount)
	{
		return RE_NUM_BE_LIMITED;
	}

	tag = GetPetIslandsRewardID(pkData->_preRewardId);
	if(!tag)
	{
		return RE_PRE_REWARD_NOT_GET;
	}

	StringType mailTitle;
	StringType mailDesc;
	ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_Reward, this, SYS_FUNC_TP_PETISLANDS_STAGE_REWARD, id, mailTitle, mailDesc, false);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	AddPetIslandsRewardID(id, true);

	return res;
}

bool LC_ServerPlayer::GetPetIslandsRewardID(int id)
{
	if(0 == id)
	{
		return true;
	}

	for(int i=0; i<m_nPetIslandsStageRewardRecord.size(); ++i)
	{
		if(m_nPetIslandsStageRewardRecord[i] == id)
		{
			return true;
		}
	}

	return false;
}

void LC_ServerPlayer::AddPetIslandsRewardID(int id, bool sync)
{
	m_nPetIslandsStageRewardRecord.push_back(id);

	if(sync)
	{
		SyncPetIslandsRewardRecord();
	}
}

void LC_ServerPlayer::SyncPetIslandsRewardRecord(bool checkVaild)
{
	if(checkVaild && false==UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_PetIsland))
	{
		return;
	}

	MG_SyncPetIslandsRewardRecord msg;
	for(int i=0; i<m_nPetIslandsStageRewardRecord.size(); ++i)
	{
		msg.m_nRewardIDRecord.push_back(m_nPetIslandsStageRewardRecord[i]);
	}

	SendMsgToClient(MGPT_SYNCPETISLANDSREWARDRECORD, &msg);
}

void LC_ServerPlayer::SendPetIslandsReward()
{
	if(m_nPetIslandsSendFlag)
	{
		return;
	}

	GameStory::LC_GameStory_Manager* pkGameStoryMgr =  SERVER_GET_GAMESTORY_MANAGER;
	if(NULL == pkGameStoryMgr)
	{
		return;
	}

	int killNum = pkGameStoryMgr->GetKillSpecialMonsterCount(this, GameStoryIDType_PetIsland1);

	Utility::UT_SIMDataList rewardList;
	CF_PetIslandStageReward::DataEntryMapExternIterator kIter = CF_PetIslandStageReward::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_PetIslandStageReward::DataEntry* pkData = kIter.PeekNextValuePtr();
		if(killNum>=pkData->_KillCount && !GetPetIslandsRewardID(pkData->_iID))
		{
			for(UT_SIMDataList::iterator it=pkData->_Reward.begin(); it!=pkData->_Reward.end(); ++it)
			{
				rewardList.push_back(*it);
			}

			AddPetIslandsRewardID(pkData->_iID);
		}
	}

	UT_ServerHelper::SendMailToPlayer(GetInstance(), "63;", "64;", rewardList);
	m_nPetIslandsSendFlag = true;
	ResetPetIslandsRewardRecord();
}

int32_t LC_ServerPlayer::GetPetIslandsEndTime()
{
	return m_nPetIslandsEndTime;
}

void LC_ServerPlayer::ResetPetIslandsRewardRecord(int32_t time)
{
	m_nPetIslandsStageRewardRecord.clear();
	SyncPetIslandsRewardRecord();

	UpdatePetIslandsEndTime(time);

	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland1);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland2);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland3);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland4);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland5);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland6);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland7);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland8);
	ClearResetAllCommonStatFlag(GameStoryIDType_PetIsland9);

	if(0 != time)
	{
		m_nPetIslandsSendFlag = false;
	}
}

void LC_ServerPlayer::UpdateResetAllCommonStatFlag(int storyID)
{
	m_nResetAllCommonStatID.insert(storyID);
}

bool LC_ServerPlayer::GetResetAllCommonStatFlag(int storyID)
{
	mem::set<int>::iterator findIt = m_nResetAllCommonStatID.find(storyID);
	return findIt==m_nResetAllCommonStatID.end() ? true : false;
}

void LC_ServerPlayer::ClearResetAllCommonStatFlag(int storyID)
{
	m_nResetAllCommonStatID.erase(storyID);
}

void LC_ServerPlayer::UpdateYiJiXunBaoEndTime(uint32_t endTime)
{
	m_nYiJiXunBaoEndTime = endTime;
	if(0 != endTime)
	{
		m_nYiJiXunBaoSendFlag = false;
	}
}

void LC_ServerPlayer::UpdatePetIslandsEndTime(uint32_t endTime)
{
	m_nPetIslandsEndTime = endTime;
	if(0 != endTime)
	{
		m_nPetIslandsSendFlag = false;
	}
}

ResultType LC_ServerPlayer::BuyRareSubDevaEyeTransform(int shopID)
{
	CF_ShopList::DataEntry* shopEntry = SafeGetCSVFileDataEntryPtr<CF_ShopList>(shopID);
	if(shopEntry == NULL)
	{
		return RE_TASK_NOT_VALID_SHOPID;
	}

	LC_ShopIDMap kShopIDMap;
	kShopIDMap[shopID] = 1;

	ResultType res = LC_Helper::IsShopAvailable(this, kShopIDMap);
	if(RE_SUCCESS != res)
	{
		return res;
	}
	//绝版特卖
	vector<int> nParams; 
	nParams.clear();
	nParams.push_back(shopID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE,ACTIVITY5_OPERATE,OPERATE_LOGTYPE1);
	res = LC_Helper::PayForShop(this, kShopIDMap, SYS_FUNC_TP_RARESUBDEVAEYE, GetInstance(), NULL, nLogCode,nParams);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	return RE_SUCCESS;
}

void LC_ServerPlayer::SetKillNPCExpFlag(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetKillNPCExpFlag(tag);
	}

	m_bKillNPCExpFlag = tag;
}

bool LC_ServerPlayer::GetKillNPCExpFlag()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetKillNPCExpFlag();
	}

	return m_bKillNPCExpFlag;
}

float LC_ServerPlayer::GetKillNPCExpPercent()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 1.0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetKillNPCExpPercent();
	}

	bool tag = GetKillNPCExpFlag();
	return tag ? 1.0+GetGlobalSetting.KillNPCExpPercent : 1.0;
}

void LC_ServerPlayer::SyncBuddyGrowthPackage()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return;
		return pkOwnerPlayer->SyncBuddyGrowthPackage();
	}

	MG_SyncBuddyGrowthPackage syncMsg;
	mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.begin();
	for ( ;it != m_ppUsableBuddyInstance.end(); ++it )
	{
		int32_t nTemplateId = it->first;
		BuddyInstance* pData = it->second;
		if (pData == NULL)
			continue;

		PS_SingleBuddyGrowthPackage record;
		pData->SetDataToProtocolStruct(record);
		syncMsg.m_nBuddyGrowthRecords.push_back(record);
	}

	SendMsgToClient(MGPT_SYNC_BUDDY_GROWTH_PACKAGE, &syncMsg);
}

ResultType LC_ServerPlayer::BuyBuddyGrowthPackage(int32_t buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
	{
		return pkOwnerPlayer->BuyBuddyGrowthPackage(buddyID);
	}
	BuddyInstance* m_pkBuddy = pkOwnerPlayer->GetBuddyInstanceByID(buddyID);
	if(NULL == m_pkBuddy)
	{
		return RE_FAIL;
	}

	return m_pkBuddy->BuyGrowthPackage();
}

ResultType LC_ServerPlayer::GetBuddyGrowthReward(int32_t buddyID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
	{	
		return pkOwnerPlayer->GetBuddyGrowthReward(buddyID);
	}

	BuddyInstance* m_pkBuddy = pkOwnerPlayer->GetBuddyInstanceByID(buddyID);
	if(NULL == m_pkBuddy)
	{
		return RE_FAIL;
	}

	return m_pkBuddy->GetGrowthReward();
}

void LC_ServerPlayer::SyncCollectionInfo()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return;
		return pkOwnerPlayer->SyncCollectionInfo();
	}

	MG_SyncCollectionInfo syncMsg;
	for(CollectionIDMap::iterator it1=m_collectionActivationIDMap.begin(); it1!=m_collectionActivationIDMap.end(); ++it1)
	{
		syncMsg.m_nCollectionActivationID.push_back(it1->first);
	}

	for(CollectionRewardSet::iterator it2=m_collectionRewardSet.begin(); it2!=m_collectionRewardSet.end(); ++it2)
	{
		syncMsg.m_nCollectionRewardID.push_back(*it2);
	}

	SendMsgToClient(MGPT_SYNC_COLLECTION_INFO, &syncMsg);
}

ResultType LC_ServerPlayer::CollectionActivation(int32_t collectActivateID)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return RE_FAIL;
		return pkOwnerPlayer->CollectionActivation(collectActivateID);
	}
	CF_CollectionActivation::DataEntry* pkActivationData = SafeGetCSVFileDataEntryPtr<CF_CollectionActivation>(collectActivateID);
	if(NULL == pkActivationData)
		return RE_FAIL;

	ResultType res = CheckCollectionActivation(collectActivateID);
	if(RE_SUCCESS == res)
	{
		m_collectionActivationIDMap.insert(std::make_pair(collectActivateID, pkActivationData->CollectionID));
		SyncCollectionInfo();

		bool tag = m_collectionAchievementIDSet.insert(pkActivationData->CollectionID).second;
		if(tag)
		{
			int collectionCount = GetActivateCollectionCount();
			AchievementEvent collectionEvent;
			collectionEvent.SetNum(collectionCount);
			UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ACTIVATE_COLLECTION, collectionEvent);
		}
	}
	return res;
}

ResultType LC_ServerPlayer::CollectionReward(int32_t collectRewardID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return RE_FAIL;
	if(!IsMainController())
	{	
		return pkOwnerPlayer->CollectionReward(collectRewardID);
	}

	if(GetPackAsset()->IsPackFull(PACK_TYPE_BASIC))
	{
		return RE_ITEM_CANT_PUT_PACKAGE;
	}

	CF_CollectionReward::DataEntry* pkRewardData = SafeGetCSVFileDataEntryPtr<CF_CollectionReward>(collectRewardID);
	if(NULL == pkRewardData)
	{
		return RE_FAIL;
	}
	//收藏进度--埋点日志
	vector<int> nParam;
	nParam.clear();
	nParam.push_back(collectRewardID);
	int32_t nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, COLLECTION_OPERATE, OPERATE_LOGTYPE2);
	ResultType res = CheckCollectionReward(collectRewardID);
	if(RE_SUCCESS == res)
	{
		StringType mailTitle;
		StringType mailDesc;
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkRewardData->RewardList, pkOwnerPlayer, SYS_FUNC_TP_GET_BUDDY_GROWTH_REWARD, 0, mailTitle, mailDesc, false,false,false,nLogCode,nParam);
		if(RE_SUCCESS == res)
		{
			m_collectionRewardSet.insert(collectRewardID);
			UT_ServerHelper::_GameNoticeFmort noticeFmort;
			noticeFmort.SetMsgID(38);
			noticeFmort.AddPlayerInfo(pkOwnerPlayer->GetInstanceUniqueID(), pkOwnerPlayer->GetOwnerCharName());
			noticeFmort.AddCollectionRewardName(collectRewardID);
			UT_ServerHelper::BrocastNoticeMsg(noticeFmort);
		}
	}
	return res;
}

int32_t LC_ServerPlayer::GetActivateCollectionCount()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return 0;
		return pkOwnerPlayer->GetActivateCollectionCount();
	}
	return m_collectionAchievementIDSet.size();
}

ResultType LC_ServerPlayer::CheckCollectionActivation(int32_t collectActivateID)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return RE_FAIL;
		return pkOwnerPlayer->CheckCollectionActivation(collectActivateID);
	}

	//是否已经激活	
	if(m_collectionActivationIDMap.end() !=  m_collectionActivationIDMap.find(collectActivateID))
	{
		return RE_COLLECTION_HAS_ACTIVATED;
	}

	CF_CollectionActivation::DataEntry* pkActivationData = SafeGetCSVFileDataEntryPtr<CF_CollectionActivation>(collectActivateID);
	if(NULL == pkActivationData)
	{
		return RE_FAIL;
	}

	LC_PackAsset* pkEquipAsset = GetPackAsset();
	if(NULL == pkEquipAsset)
	{
		return RE_FAIL;
	}

	//是否满足激活条件
	switch(pkActivationData->Type)
	{
	case COLLECTION_TYPE_EQUIP:
		{
			int equipID = pkActivationData->ActivationID;

			//指挥官装备
			std::map<int32_t,PS_ControllerEquipSlotItemInfo> controllerEquipSlotItemInfo;
			GetCommandEquipPack().GetControllerEquipSlotlnfo(controllerEquipSlotItemInfo);
			for(std::map<int32_t,PS_ControllerEquipSlotItemInfo>::iterator it=controllerEquipSlotItemInfo.begin(); it!=controllerEquipSlotItemInfo.end(); ++it)
			{
				if(it->second.m_nEquipItem == equipID)
				{
					return RE_SUCCESS;
				}
			}

			//buddy装备
			for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
			{
				BuddyInstance* pkBuddy = it->second;
				if(NULL != pkBuddy)
				{
					std::map<int32_t,PS_EquipItemInfo_BuddyCS> infoData;
					pkBuddy->GetEquipPack().GetEquipInfo(infoData);
					for(std::map<int32_t,PS_EquipItemInfo_BuddyCS>::iterator it=infoData.begin(); it!=infoData.end(); ++it)
					{
						if(it->second.m_nEquipItemID == equipID)
						{
							return RE_SUCCESS;
						}
					}
				}
			}

			//进阶线装备
			int arr[] = {LC_SUB_TP_VEHICLE, LC_SUB_TP_DEVA_EYE, LC_SUB_TP_MUHUN};
			for(int i=0; i<sizeof(arr)/sizeof(arr[0]); ++i)
			{
				int subType = arr[i];
				std::map<int32_t,PS_SubEquipSlotItemInfo> data;
				GetSubEquipItemInfo(subType, data);
				for(std::map<int32_t,PS_SubEquipSlotItemInfo>::iterator it=data.begin(); it!=data.end(); ++it)
				{
					if(it->second.m_EquipItem == equipID)
					{
						return RE_SUCCESS;
					}
				}
			}

			//基础背包
			ItemSearchResult PlayerBasicItem;
			pkEquipAsset->SearchItem(PACK_TYPE_BASIC, equipID, PlayerBasicItem);
			if(!PlayerBasicItem.bind_items.empty() || !PlayerBasicItem.items.empty())
			{
				return RE_SUCCESS;
			}

			//仓库
			ItemSearchResult PlayerWarehouseItem;
			pkEquipAsset->SearchItem(PACK_TYPE_WAREHOUSE, equipID, PlayerWarehouseItem);
			for(int i=0; i<PlayerWarehouseItem.items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerWarehouseItem.items[i].entry;
				if(NULL != pkItem)
				{
					return RE_SUCCESS;
				}
			}
			for(int i=0; i<PlayerWarehouseItem.bind_items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerWarehouseItem.bind_items[i].entry;
				if(NULL != pkItem)
				{
					return RE_SUCCESS;
				}
			}
		}
		break;
	case COLLECTION_TYPE_RUNE:
		{
			int equipID = pkActivationData->ActivationID;
			int equipStarLevel = pkActivationData->ActivationStarLevel;

			//宝具
			for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
			{
				BuddyInstance* pkBuddy = it->second;
				if(NULL != pkBuddy)
				{
					mem::map<int32_t, int32_t> itemID2StarLevelMap;
					pkBuddy->GetRunePack().GetAllBuddyRuneItemStarLevelData(itemID2StarLevelMap);
					mem::map<int32_t, int32_t>::iterator findIt = itemID2StarLevelMap.find(equipID);
					if(findIt!=itemID2StarLevelMap.end() && findIt->second >= equipStarLevel)
					{
						return RE_SUCCESS;
					}
				}
			}

			//基础背包
			ItemSearchResult PlayerBasicItem;
			pkEquipAsset->SearchItem(PACK_TYPE_BASIC, equipID, PlayerBasicItem);
			for(int i=0; i<PlayerBasicItem.items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerBasicItem.items[i].entry;
				if(pkItem!=NULL && pkItem->GetBackPackValueByType(LCSPET_EQUIP_STAR)>=equipStarLevel)
				{
					return RE_SUCCESS;
				}
			}
			for(int i=0; i<PlayerBasicItem.bind_items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerBasicItem.bind_items[i].entry;
				if(pkItem!=NULL && pkItem->GetBackPackValueByType(LCSPET_EQUIP_STAR)>=equipStarLevel)
				{
					return RE_SUCCESS;
				}
			}

			//仓库
			ItemSearchResult PlayerWarehouseItem;
			pkEquipAsset->SearchItem(PACK_TYPE_WAREHOUSE, equipID, PlayerWarehouseItem);
			for(int i=0; i<PlayerWarehouseItem.items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerWarehouseItem.items[i].entry;
				if(pkItem!=NULL && pkItem->GetBackPackValueByType(LCSPET_EQUIP_STAR)>=equipStarLevel)
				{
					return RE_SUCCESS;
				}
			}
			for(int i=0; i<PlayerWarehouseItem.bind_items.size(); ++i)
			{
				LC_BackPackEntry* pkItem = PlayerWarehouseItem.bind_items[i].entry;
				if(pkItem!=NULL && pkItem->GetBackPackValueByType(LCSPET_EQUIP_STAR)>=equipStarLevel)
				{
					return RE_SUCCESS;
				}
			}
		}
		break;
	case COLLECTION_TYPE_BUDDY:
		{
			int buddyID = pkActivationData->ActivationID;
			int buddyStarLevel = pkActivationData->ActivationStarLevel;

			mem::map<int32_t, BuddyInstance*>::iterator it =  m_ppUsableBuddyInstance.find(buddyID);
			if(it != m_ppUsableBuddyInstance.end())
			{
				BuddyInstance* pBuddyData = it->second;
				if (pBuddyData != NULL && pBuddyData->GetStarLevel() >= buddyStarLevel)
				{
					return RE_SUCCESS;
				}
			}
		}
		break;
	case COLLECTION_TYPE_VEHICLE:
	case COLLECTION_TYPE_DEVA_EYE:
	case COLLECTION_TYPE_MUHUN:
		{
			int SubTransformID = pkActivationData->ActivationID;
			LC_SubUpgradeData* pkSub = GetSubordinateAsset().GetSubData(pkActivationData->Type);
			if(NULL!=pkSub && pkSub->m_kTansfroms.end()!=pkSub->m_kTansfroms.find(SubTransformID))
			{
				return RE_SUCCESS;
			}
		}
		break;
	case COLLECTION_TYPE_PET:
		{
			int16_t petID = pkActivationData->ActivationID;
			int petStarLevel = pkActivationData->ActivationStarLevel;

			int nResult = false;
			const mem::map<int16_t, PetInstance*> &petMap = GetPetRawData(nResult);
			if(nResult)
			{
				for(mem::map<int16_t, PetInstance*>::const_iterator iter= petMap.begin(); iter!=petMap.end(); ++iter)
				{
					PetInstance* pkPetData = iter->second;
					if(NULL!=pkPetData && pkPetData->GetTemplateId()==petID && pkPetData->GetStarLevel()>=petStarLevel)
					{
						return RE_SUCCESS;
					}
				}			
			}
		}
		break;
	}
	return RE_FAIL;
}

ResultType LC_ServerPlayer::CheckCollectionReward(int32_t collectRewardID)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return RE_FAIL;
		return pkOwnerPlayer->CheckCollectionReward(collectRewardID);
	}

	CF_CollectionReward::DataEntry* pkRewardData = SafeGetCSVFileDataEntryPtr<CF_CollectionReward>(collectRewardID);
	if(NULL == pkRewardData)
	{
		return RE_FAIL;
	}

	bool needActiveAllID = pkRewardData->Condition;

	//是否已经领取
	if(m_collectionRewardSet.end() != m_collectionRewardSet.find(collectRewardID))
	{
		return RE_COLLECTION_REWARD_HAS_RECEIVE;
	}

	//进阶线
	Utility::UT_SIMDataList& CollectionList = pkRewardData->CollectionID;
	if(pkRewardData->Type==COLLECTION_TYPE_VEHICLE || pkRewardData->Type==COLLECTION_TYPE_DEVA_EYE || pkRewardData->Type==COLLECTION_TYPE_MUHUN)
	{
		int count = 0;
		for(Utility::UT_SIMDataList::iterator it1=CollectionList.begin(); it1!=CollectionList.end(); ++it1)
		{
			int collectionID = it1->IID();
			for(CollectionIDMap::iterator it2=m_collectionActivationIDMap.begin(); it2!=m_collectionActivationIDMap.end(); ++it2)
			{
				if(it2->second == collectionID)
				{	
					CF_CollectionActivation::DataEntry* pkActivationData = SafeGetCSVFileDataEntryPtr<CF_CollectionActivation>(it2->first);
					if(NULL != pkRewardData && pkActivationData->Type==pkRewardData->Type)
					{
						LC_SubUpgradeData* pkSub = GetSubordinateAsset().GetSubData(pkActivationData->Type);
						if(NULL != pkSub && pkSub->m_kTansfroms.end() !=pkSub->m_kTansfroms.find(pkActivationData->ActivationID))
						{
							count += 1;
							if(count >= pkRewardData->CollectionStarLevel)
							{
								return RE_SUCCESS;
							}						
						}
					}
				}
			}
		}
	}
	else
	{
		int starLevelResult = 0;		
		int count = 0;
		for(Utility::UT_SIMDataList::iterator it1=CollectionList.begin(); it1!=CollectionList.end(); ++it1)
		{			
			int ActivationID = it1->IID();
			int MaxCurrentStarLevel = 0;
			int flag = false;
			for(CollectionIDMap::iterator it2=m_collectionActivationIDMap.begin(); it2!=m_collectionActivationIDMap.end(); ++it2)
			{
				if(it2->second == ActivationID)
				{
					CF_CollectionActivation::DataEntry* pkActivationData = SafeGetCSVFileDataEntryPtr<CF_CollectionActivation>(it2->first);
					if(NULL != pkRewardData && pkActivationData->Type==pkRewardData->Type && pkActivationData->ActivationStarLevel>=MaxCurrentStarLevel)
					{
						flag = true;
						MaxCurrentStarLevel = pkActivationData->ActivationStarLevel;
					}
				}
			}
			starLevelResult += MaxCurrentStarLevel;

			if(flag)
			{
				++count;
			}			

			//如果不需要所有的收藏id都激活，则只判断总星级是否足够
			if(!needActiveAllID &&(starLevelResult >= pkRewardData->CollectionStarLevel))
			{
				return RE_SUCCESS;
			}
		}

		//如果需要收藏id激活，要判断激活的总数量和需要的数量是否相等
		if(needActiveAllID && count>=CollectionList.size())
		{
			return RE_SUCCESS;
		}
	}
	return RE_FAIL;
}





bool LC_ServerPlayer::UpdateSingleStateCDTime( float fDeltaTime, ShareStateCDTime& data )
{
	bool bResult = true;
	for ( int i = 0; i < data.size(); i++ )
	{
		data[i] -= fDeltaTime;
		if ( data[i] > 0.00f )
			bResult = false;
	}
	return bResult;
}

void LC_ServerPlayer::UpdateStateCDTime(float fCurrentTime, float fDeltaTime)
{
	for(ShareStateCDTimeMap::iterator it=m_nShareCDTimeRecord.begin(); it!=m_nShareCDTimeRecord.end();)
	{
		//it->second -= fDeltaTime;
		bool bRemove = UpdateSingleStateCDTime(fDeltaTime, it->second);

		//if(it->second <= 0.001f)
		if ( bRemove )
		{
			it = m_nShareCDTimeRecord.erase(it);
		}
		else
		{
			++it;
		}
	}
}

float LC_ServerPlayer::GetStateVaildTime(int32_t stateID, Skill::SkillEventTypeEx eEventType)
{
	if ( eEventType >= SETE_COUNT)
		return 0.00f;
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return 0.00f;
		return pkOwnerPlayer->GetStateVaildTime(stateID, eEventType);
	}

	ShareStateCDTimeMap::iterator it = m_nShareCDTimeRecord.find(stateID);
	if(it != m_nShareCDTimeRecord.end())
	{
		return it->second[eEventType];
	}

	return 0;
}

void LC_ServerPlayer::SetStateExtendDataOnController(int lStateTypeID, int iParameterIndex , int64_t iValue)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return;
		return pkOwnerPlayer->SetStateExtendDataOnController(lStateTypeID, iParameterIndex, iValue);
	}

	return m_kControllerSkillStateMap->SetStateExtendData(lStateTypeID, iParameterIndex, iValue);
}

int64_t LC_ServerPlayer::GetStateExtendDataOnController(int lStateTypeID, int iParameterIndex)
{	
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return -1;
		return pkOwnerPlayer->GetStateExtendDataOnController(lStateTypeID, iParameterIndex);
	}

	return m_kSkillStateMap->GetStateExtendData(lStateTypeID, iParameterIndex);
}

void LC_ServerPlayer::SetStateMutableParameterOnController(int lStateTypeID, int iParameterIndex, double fValue)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return;
		return pkOwnerPlayer->SetStateMutableParameterOnController(lStateTypeID, iParameterIndex, fValue);
	}

	return m_kControllerSkillStateMap->SetStateMutableParameter(lStateTypeID, iParameterIndex, fValue);;
}

double LC_ServerPlayer::GetStateMutableParameterOnController(int lStateTypeID, int iParameterIndex)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
			return 0.00f;
		return pkOwnerPlayer->GetStateMutableParameterOnController(lStateTypeID, iParameterIndex);
	}

	return m_kControllerSkillStateMap->GetStateMutableParameter(lStateTypeID, iParameterIndex);
}

void LC_ServerPlayer::SetStateTime(int32_t stateID, float time, Skill::SkillEventTypeEx eEventType)
{
	if ( eEventType >= SETE_COUNT)
		return;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetStateTime(stateID, time, eEventType);
	}

	ShareStateCDTimeMap::iterator it = m_nShareCDTimeRecord.find(stateID);
	if(it != m_nShareCDTimeRecord.end())
	{
		it->second[eEventType] = time;
	}
	else
	{
		ShareStateCDTime data;
		for ( int i = 0; i < SETE_COUNT; i++ )
		{
			data.push_back(0.00f);
		}
		data[eEventType] = time;
		m_nShareCDTimeRecord.insert(std::make_pair(stateID, data));
	}
}

uint64_t LC_ServerPlayer::GetInviteTime(unique_id_type charID)
{
	InviteRecordsMap::iterator it = m_inviteRecordsMap.find(charID);
	return it==m_inviteRecordsMap.end() ? 0 : it->second;
}

void LC_ServerPlayer::SetInviteTime(unique_id_type charID, uint64_t currentTime)
{
	m_inviteRecordsMap[charID] = currentTime;
}

void LC_ServerPlayer::OnVIPReport(uint32_t optype, uint32_t viptype, uint32_t buytime, uint32_t viplv)
{
	oss_360_log_vip(optype, viptype, buytime, viplv, this);
}





void LC_ServerPlayer::UpdateHolyDeedRecord(int itemID, int itemCount)
{
	if(itemCount <= 0)
	{
		return;
	}
	
	CF_HolyDeed::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_HolyDeed>(itemID);
	if(NULL == pkData)
	{
		return;
	}

	mem::map<int32_t, int32_t>::iterator it=m_nHolyDeedRecords.find(itemID);
	if(it != m_nHolyDeedRecords.end())
	{
		it->second += itemCount;
	}
	else
	{
		NotifyAddNewHolyDeed(itemID);
		m_nHolyDeedRecords.insert(std::make_pair(itemID, itemCount));
	}

	SyncHolyDeedRecord();
}

void LC_ServerPlayer::NotifyAddNewHolyDeed(int itemID)
{
	MG_NotifyAddNewHolyDeed msg;
	msg.m_nHolyDeedID = itemID;
	SendMsgToClient(MGPT_NOTIFY_ADDNEW_HOLYDEED, &msg);
}

void LC_ServerPlayer::SyncHolyDeedRecord()
{
	MG_SyncHolyDeed syncMsg;
	for(mem::map<int32_t, int32_t>::iterator it=m_nHolyDeedRecords.begin(); it!=m_nHolyDeedRecords.end(); ++it)
	{
		syncMsg.m_nHolyDeedRecord.insert(std::make_pair(it->first, it->second));
	}
	SendMsgToClient(MGPT_SYNC_HOLYDEED, &syncMsg);
}

void LC_ServerPlayer::SetDecompositionSetting(MG_REQ_DecompositionSetting& msg)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetDecompositionSetting(msg);
	}

	//每次设置配置之前，把自动分解去掉
	SetAutoDecomposition(false);
	
	m_bDecompositionController = msg.m_bDecompositionController;
	m_nControllerItemlevel = msg.m_nControllerItemlevel;
	m_nControllerItemGrade = msg.m_nControllerItemGrade;	
	m_bDecompositionVehicle = msg.m_bDecompositionVehicle;
	m_nVehicleItemLevel = msg.m_nVehicleItemLevel;
	m_nVehicleItemGrade = msg.m_nVehicleItemGrade;
	m_bDecompositionDevaeye = msg.m_bDecompositionDevaeye;
	m_nDevaeyeItemLevel = msg.m_nDevaeyeItemLevel;
	m_nDevaeyeItemGrade = msg.m_nDevaeyeItemGrade;
	m_bDecompositionWing = msg.m_bDecompositionWing;
	m_nWingItemLevel = msg.m_nWingItemLevel;
	m_nWingItemGrade = msg.m_nWingItemGrade;
}

void LC_ServerPlayer::SyncDecompositionSetting()
{
	MG_RLT_DecompositionSetting respMsg;
	respMsg.m_nAutoDecomposition = m_bAutoDecomposition;
	respMsg.m_bDecompositionController = m_bDecompositionController;
	respMsg.m_nControllerItemlevel = m_nControllerItemlevel;
	respMsg.m_nControllerItemGrade = m_nControllerItemGrade;
	respMsg.m_bDecompositionVehicle = m_bDecompositionVehicle;
	respMsg.m_nVehicleItemLevel = m_nVehicleItemLevel;
	respMsg.m_nVehicleItemGrade = m_nVehicleItemGrade;
	respMsg.m_bDecompositionDevaeye = m_bDecompositionDevaeye;
	respMsg.m_nDevaeyeItemLevel = m_nDevaeyeItemLevel;
	respMsg.m_nDevaeyeItemGrade = m_nDevaeyeItemGrade;
	respMsg.m_bDecompositionWing = m_bDecompositionWing;
	respMsg.m_nWingItemLevel = m_nWingItemLevel;
	respMsg.m_nWingItemGrade = m_nWingItemGrade;
	SendMsgToClient(MGPT_RLT_DECOMPOSITION_SETTING, &respMsg);
}

bool LC_ServerPlayer::SetAutoDecomposition(bool tag)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SetAutoDecomposition(tag);
	}

	//开启自动分解的时候，判断自动分解特权是否开启
	if(true == tag)
	{
		uint32_t res = LC_Helper::GetVipPrivilegeTimesByType(VIP_PC_DECOMPOSITION, pkOwnerPlayer);
		if(res <= 0)
		{
			return false;
		}
	}

	if(m_bAutoDecomposition != tag)
	{
		m_bAutoDecomposition = tag;
	}

	CheckDecompositionItem();
	return m_bAutoDecomposition;
}

bool LC_ServerPlayer::GetAutoDecomposition()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAutoDecomposition();
	}

	return m_bAutoDecomposition;
}

void LC_ServerPlayer::CheckDecompositionItem()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckDecompositionItem();
	}

	bool tag = GetAutoDecomposition();
	if(!tag)
	{
		return;
	}

	//遍历背包
	LC_PackAsset* pkAsset = GetPackAsset();
	if(NULL == pkAsset)
	{
		return;
	}

	bool flag = false;
	std::vector<DecompositItemInfo> itemVec;
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		flag = false;
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{
			CF_ItemList::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_ItemList>(pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID));
			if(NULL!=pkData && pkData->_lDecompositionFuncID!=0)
			{
				if(IsCommanderEquip(pkData->_lCategory2) && m_bDecompositionController)
				{
					if(pkData->_lLevel<=m_nControllerItemlevel && pkData->_lGrade<=m_nControllerItemGrade)
					{
						flag = true;
					}
				}
				else if(IsVehicleEquip(pkData->_lCategory2) && m_bDecompositionVehicle)
				{
					if(pkData->_lLevel<=m_nVehicleItemLevel && pkData->_lGrade<=m_nVehicleItemGrade)
					{
						flag = true;
					}
				}
				else if(IsDevaeyeEquip(pkData->_lCategory2) && m_bDecompositionDevaeye)
				{
					if(pkData->_lLevel<=m_nDevaeyeItemLevel && pkData->_lGrade<=m_nDevaeyeItemGrade)
					{
						flag = true;
					}
				}
				else if(IsWingEquip(pkData->_lCategory2) && m_bDecompositionWing)
				{
					if(pkData->_lLevel<=m_nWingItemLevel && pkData->_lGrade<=m_nWingItemGrade)
					{
						flag = true;
					}
				}

				if(flag)
				{
					DecompositItemInfo item;
					item.m_iPackageEntryIndex = i;
					item.m_iPackType = PACK_TYPE_BASIC;
					item.m_lItemID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
					itemVec.push_back(item);
				}
			}
		}
	}

	if(!itemVec.empty())
	{
		MG_RLT_DecompositItemInPackage msg;
		DecompositItem(itemVec, msg.m_DecompositItems);
	}
}

ResultType LC_ServerPlayer::GetFirstChargeReward(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetFirstChargeReward(id);
	}

	LC_VIPFDepositEntry* pkEntry = LC_VIPCmnManager::GetSingletonPtr()->GetVIPFDepositDataEntry(id);		
	if(NULL == pkEntry)
	{
		return RE_FAIL;
	}

	//是否可以领取
	ResultType res = CheckGetFirstChargeReward(id);
	if(RE_SUCCESS != res)
	{
		return res;
	}
	//首冲
	vector<int> nParams;
	nParams.clear();
	
	int32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	int32_t detalDay = LC_Helper::GetDeltaDay(m_nFirstChargeTime, currentTime);
	nParams.push_back(detalDay);

	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY2_OPERATE, OPERATE_LOGTYPE1);
	if (pkEntry->GetItemsCount() > 0)
	{
		StringType title;
		StringType desc;
		res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkEntry->GetItemList(), this, SYS_FUNC_TP_VIP_FDEPOSIT, id, title, desc, false, false,false,nLogCode,nParams);
		if (RE_SUCCESS != res)
		{
			return res;
		}
	}

	AddExpWithGamePlay(pkEntry->GetExp(), SYS_FUNC_TP_VIP_FDEPOSIT, id);
	AddCash(pkEntry->GetCash(), CT_UNBIND_CASH, SYS_FUNC_TP_VIP_FDEPOSIT, id, 0, true,NULL ,nLogCode);
	AddSkillLevelupPoints(pkEntry->GetSP(), SYS_FUNC_TP_VIP_FDEPOSIT, id);
	GameLogic::LC_RumorManager* pkRumorManager = GameLogic::LC_RumorManager::GetSingletonPtr();
	if(pkRumorManager)
	{
		GameLogic::LC_Rumor* pkRumor = pkRumorManager->GetRumorByType(GameLogic::FirstDeposit);
		const GameLogic::LC_RumorDataEntry* pkRumorEntry = NULL;
		if (pkRumor && (pkRumorEntry = pkRumor->GetRumerEntry(id)))
		{
			if (pkEntry->GetItemsCount() > 0)
			{
				int noticeID = pkRumor->GetRumorID(pkRumorEntry->kKey);
				UT_ServerHelper::_GameNoticeFmort noticeFmort;
				noticeFmort.SetChannelType(pkRumor->GetChatChannel());
				noticeFmort.SetMsgID(noticeID);
				noticeFmort.AddPlayerInfo(GetInstance(), GetOwnerCharName());
				noticeFmort.AddItemName(pkEntry->GetItemIDByIndex(0));
				UT_ServerHelper::BrocastNoticeMsg(noticeFmort);
			}
		}
	}
	
	//更新领取记录
	UpdateFirstChargeRewardState(id);

	return RE_SUCCESS;
}

void LC_ServerPlayer::UpdateFirstChargeTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateFirstChargeTime();
	}

	if(0 == m_nFirstChargeTime)
	{
		uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		m_nFirstChargeTime = currentTime;
		CF_VIPFDeposit::DataEntryMapExternIterator kIt = CF_VIPFDeposit::GetSingletonPtr()->GetIterator();
		for(; kIt.HasMoreElements(); kIt.MoveNext())
		{
			CF_VIPFDeposit::DataEntry* pkData = kIt.PeekNextValuePtr();
			m_nFirstChargeRewardState.insert(std::make_pair(pkData->_iLevel, false));
		}

		SyncFirstChargeInfo();
	}
}

void LC_ServerPlayer::SyncFirstChargeInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncFirstChargeInfo();
	}

	MG_SyncFirstChargeInfo msg;
	msg.m_nFirstChargeTime = m_nFirstChargeTime;
	msg.m_nFirstChargeRewardState.insert(m_nFirstChargeRewardState.begin(), m_nFirstChargeRewardState.end());
	SendMsgToClient(MGPT_SYNCFIRSTCHARGEINFO, &msg);
}

ResultType LC_ServerPlayer::CheckGetFirstChargeReward(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckGetFirstChargeReward(id);
	}

	if(0 == m_nFirstChargeTime)
	{
		return RE_FIRSTCHARGE_ERROR_1;
	}

	CF_VIPFDeposit::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_VIPFDeposit>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	//防止策划在玩家首充后改表，增加了id
	mem::map<int, bool>::iterator findIt = m_nFirstChargeRewardState.find(id);
	if(findIt == m_nFirstChargeRewardState.end())
	{
		m_nFirstChargeRewardState.insert(std::make_pair(id, false));
	}
	else if(true == findIt->second)
	{
		//已经领过了
		return RE_FIRSTCHARGE_ERROR_2;
	}

	int32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	int32_t detalDay = LC_Helper::GetDeltaDay(m_nFirstChargeTime, currentTime);
	if(id > detalDay+1)
	{
		return RE_FIRSTCHARGE_ERROR_3;
	}

	return RE_SUCCESS;
}

void LC_ServerPlayer::UpdateFirstChargeRewardState(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->UpdateFirstChargeRewardState(id);
	}

	mem::map<int, bool>::iterator findIt = m_nFirstChargeRewardState.find(id);
	if(findIt == m_nFirstChargeRewardState.end())
	{
		m_nFirstChargeRewardState.insert(std::make_pair(id, true));
	}
	else
	{
		findIt->second = true;
	}

	SyncFirstChargeInfo();
}

ResultType LC_ServerPlayer::GetVIPExtraReward(std::vector<PS_ItemRecord>& itemInfo)
{
	itemInfo.clear();

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetVIPExtraReward(itemInfo);
	}

	LC_VIPCmnManager* pkMgr = LC_VIPCmnManager::GetSingletonPtr();
	if(pkMgr == NULL)
	{
		return RE_FAIL;
	}

	LC_VIPProfitDataEntry* pkDataEntry = pkMgr->GetVIPProfitDataEntry(VIP_PROFIT_VIP_VIP_EXTRA_REWARD_TIMES);
	if(NULL == pkDataEntry)							
	{
		return RE_FAIL;
	}
	
	int totalTimes = pkDataEntry->GetValue(pkOwnerPlayer->GetVIPLevel(), false);
	int usedTimes = GetUsedVIPExtraRewardTimes();
	if(usedTimes<0 || usedTimes >= totalTimes)
	{
		//次数已经用完了
		return RE_VIPEXTRA_REWARD_ERROR_1;
	}

	if(usedTimes >= GetGlobalSetting.VIPExtraRewardConsumeCashNum.size())
	{
		return RE_VIPEXTRA_REWARD_ERROR_2;
	}

	//钱是否够
	CashType type = (CashType)GetGlobalSetting.VIPExtraRewardConsumeCashType;
	MoneyType num = GetGlobalSetting.VIPExtraRewardConsumeCashNum[usedTimes];
	bool tag = IsCashEnough(num, type);
	if(false == tag)
	{
		return RE_VIPEXTRA_REWARD_ERROR_3;
	}

	ResultType res = m_NewVIPReward.GetVIPExtraReward(itemInfo);
	if(RE_SUCCESS != res)
	{
		return res;
	}
	//vip快速领奖--埋点日志
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(pkOwnerPlayer->GetVIPLevel());
	nParams.push_back(usedTimes+1);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, VIP_OPERATE, OPERATE_LOGTYPE3);
	//扣钱
	ReduceCash(num, type, SYS_FUNC_TP_VIP_EXTRA_REWARD, usedTimes,nLogCode,nParams);

	AddUsedVIPExtraRewardTimes(1);

	LC_GameEventManager* pkGameEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkGameEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_VIPEXTARE_REWARD);
			pkGameEvent->SetEventParam(EP_VIP_EXTAREREWARD_PLAYER_ID, GetID());
			pkGameEvent->SetEventParam(EP_VIP_EXTAREREWARD_MAPID, GetMapResID());
			pkGameEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	return RE_SUCCESS;
}

int LC_ServerPlayer::GetUsedVIPExtraRewardTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return -1;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetUsedVIPExtraRewardTimes();
	}

	return m_nUsedVIPExtraRewardTimes;
}

void LC_ServerPlayer::AddUsedVIPExtraRewardTimes(int times)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->AddUsedVIPExtraRewardTimes(times);
	}

	if(times <= 0)
	{
		return;
	}

	m_nUsedVIPExtraRewardTimes += 1;

	SyncVIPExtraRewardUsedTimes();

	AchievementEvent kEvent;
	kEvent.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_VIP_EXTRA_REWARD, kEvent);
}

void LC_ServerPlayer::ResetUsedVIPExtraRewardTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->ResetUsedVIPExtraRewardTimes();
	}

	m_nUsedVIPExtraRewardTimes = 0;
	SyncVIPExtraRewardUsedTimes();
}

void LC_ServerPlayer::SyncVIPExtraRewardUsedTimes()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncVIPExtraRewardUsedTimes();
	}

	MG_SyncVIPExtraRewardUsedTimes msg;
	msg.m_nUsedTimes = GetUsedVIPExtraRewardTimes();
	SendMsgToClient(MGPT_SYNCVIPEXTRAREWARDUSEDTIMES, &msg);
}

void LC_ServerPlayer::CheckAnswerActivityTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CheckAnswerActivityTime();
	}

	bool tag = UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Answer);
	if(tag)
	{
		uint32_t current = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		const mem::vector<uint32_t>& checkTime = UT_ServerHelper::GetCheckTime();
		for(int i=0; i<checkTime.size(); ++i)
		{
			uint32_t time = checkTime[i];
			if(time<=current && current<time+2)
			{
				CheckAnswerAward();
			}
		}
	}

	int32_t playerEndTime = GetAnswerActivityEndTime();
	int32_t serverEndTime = UT_ServerHelper::GetAnswerActivityEndTime();
	if(serverEndTime!=0 && serverEndTime!=playerEndTime)
	{
		CheckAnswerAward();
		RestartAnswerActivity(serverEndTime);
		SyncTestDatabase();
	}
}

int32_t LC_ServerPlayer::GetAnswerActivityEndTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAnswerActivityEndTime();
	}

	return m_nAnswerActivityEndTime;
}

void LC_ServerPlayer::RestartAnswerActivity(int32_t time)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RestartAnswerActivity(time);
	}

	m_nAnswerActivityEndTime = time;
	m_nAnswerAccPoint = ANSWER_NOT_JOIN;
	m_nAnswerGuildAccPoint = 0;
	m_nAnswerRecord.clear();
	m_nAnswerRewardRecord.clear();

	SyncAnswerInfo();
}

void LC_ServerPlayer::SyncTestDatabase(bool checkVaild)
{
	if(checkVaild && false==UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Answer))
	{
		return;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncTestDatabase();
	}

	MG_SyncTestDatabase syncMsg;
	UT_ServerHelper::GetTestDatabase(syncMsg.m_topicID);
	pkOwnerPlayer->SendMsgToClient(MGPT_SYNCTESTDATABASE, &syncMsg);
}

ResultType LC_ServerPlayer::GetAnswerRankInfo(int32_t minIndex, int maxIndex, MG_RLT_AnswerRankInfo& msg)
{
	ResultType res = RE_FAIL;
	if(minIndex > maxIndex)
	{
		return res;
	}

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetAnswerRankInfo(minIndex, maxIndex, msg);
	}
	uint64_t mySelfID = GetInstance();
	mem::vector<uint64_t> allResults;
	msg.m_nMyselfInfo.m_nRankIndex = SPECIES_RANK_NONE;
	if(msg.m_nRankType == 1)
	{
		UT_ServerHelper::RedisRank_ReadSimpleRange(UT_REDIS_KEY_ANSWER_GUILD_POINT, allResults);
		mySelfID = GetGuildID();
		if(mySelfID)
		{
			msg.m_nMyselfInfo.m_nCharName = GetGuildName().c_str();
			msg.m_nMyselfInfo.m_nAnswerAccPoint = UT_ServerHelper::GetGuildAnswerPointByGuildId(mySelfID);
		}
		
	}
	else
	{
		UT_ServerHelper::RedisRank_ReadSimpleRange(UT_REDIS_KEY_ANSWER_ACCOUNT_POINT, allResults);
		msg.m_nMyselfInfo.m_nCharName = GetOwnerCharName().c_str();
		//msg.m_nMyselfInfo.m_nAnswerAccPoint = m_nAnswerAccPoint;
		msg.m_nMyselfInfo.m_nAnswerAccPoint = UT_ServerHelper::GetUserAnswerPointByCharId(mySelfID);
	}

	if(allResults.size() <= 0)
	{
		msg.m_nTotalCount = 0;
		return RE_SUCCESS;
	}
	msg.m_nTotalCount = allResults.size();
	bool tag = false;
	for(int i=0; i<allResults.size(); ++i)
	{
		if(allResults[i] == mySelfID)
		{
			mem::vector<uint64_t> key;
			key.push_back(mySelfID);

			std::string data;
			if(msg.m_nRankType == 1)
			{
				UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ANSWER_GUILD_INFO, key, data, false);
			}
			else
			{
				UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ANSWER_PLAYER_INFO, key, data, false);
			}
			AnswerInfo info;
			std::string errorMsg;
			if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
			{
				break;
			}

			tag = true;
			msg.m_nMyselfInfo.m_nRankIndex = i;
			break;
		}
	}

	maxIndex = maxIndex > allResults.size()-1 ? allResults.size()-1 : maxIndex;
	for(int i=minIndex; i<=maxIndex; ++i)
	{
		mem::vector<uint64_t> key;
		key.push_back(allResults[i]);

		std::string data;
		if(msg.m_nRankType == 1)
		{
			UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ANSWER_GUILD_INFO, key, data, false);
		}
		else
		{
			UT_ServerHelper::RedisGetData_String(UT_REDIS_KEY_ANSWER_PLAYER_INFO, key, data, false);
		}

		AnswerInfo info;
		std::string errorMsg;
		if(!boost::ajson::load_from_buff(info, data.c_str(), errorMsg))
		{
			continue;
		}

		PS_AnswerInfo playerInfo;
		playerInfo.m_nRankIndex = i;
		playerInfo.m_nCharName = info.charName;
		playerInfo.m_nAnswerAccPoint = info.accountPoint;
		msg.m_nPlayerInfo.push_back(playerInfo);
	}
	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::FillGuildFightRankMyInfo(PS_RANK_STRUCT &outInfo,int32_t myIndex,int nType)
{
	LC_ServerGuildManager* pkGuildManager = LC_ServerGuildManager::GetSingletonPtr();
	LC_ServerGuildInfo* pkGuildInfo = pkGuildManager->GetGuildInfoByID(GetGuildID());
	outInfo.m_nRankIndex	=	myIndex;
	outInfo.m_nGuildName	=	GetGuildName().c_str();
	outInfo.m_nPlayerName	=	GetOwnerCharName().c_str();
	outInfo.m_nTitleId		=	GetCommanderTitle();
	outInfo.m_nGuild		=	GetGuildID();
	outInfo.m_nPoint		=	 0;
	outInfo.m_uGuildMasterId =  0;
	if(pkGuildInfo)
		outInfo.m_uGuildMasterId = pkGuildInfo->GetMasterID();
	if(GuildFightRankType::GFRT_PERSONAL == nType )
		outInfo.m_nPoint		=	GetPersonalGuildTotalScore();
	else if(GuildFightRankType::GFRT_GUILD == nType )
	{
		if(pkGuildInfo)
			outInfo.m_nPoint		=	pkGuildInfo->GetBestGuildTotalAccountPoint();
	}
	//GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "FillGuildFightRankMyInfo  nType:%d, playername:%s, guildname:%s , rank:%d, point:%d ,ntitle:%d\n",nType,outInfo.m_nPlayerName.c_str(),outInfo.m_nGuildName.c_str(), outInfo.m_nRankIndex,outInfo.m_nPoint,outInfo.m_nTitleId);		
	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::GetGuildFightRankInfo(MG_REQ_GuildFightRankInfo &reqMsg, MG_RLT_GuildFightRankInfo& msg)
{
	int32_t minIndex = reqMsg.m_nMin;
	int maxIndex = reqMsg.m_nMax;
	int nType = reqMsg.m_nType1;
	int nStoryId = reqMsg.m_nStroyId;
	ResultType res = RE_FAIL;
	if(minIndex > maxIndex)
		return res;
	if(GuildFightRankType::GFRT_GUILD != nType && GuildFightRankType::GFRT_PERSONAL != nType)
		return res;
	
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return res;
	if(!IsMainController())
		return pkOwnerPlayer->GetGuildFightRankInfo(reqMsg, msg);

	unique_id_type myID = GetInstance();
	uint64_t mySelfID = myID;
	if(GuildFightRankType::GFRT_GUILD == nType )	
		mySelfID	=	GetGuildID();

	int32_t myIndex = SPECIES_RANK_NONE;
	msg.m_nType1 = nType;
	msg.m_nStroyId = nStoryId;
	msg.m_nTotalCount = 0;
	msg.m_nResult = RE_SUCCESS;
	for(int i = 0; i < reqMsg.m_nStageInfo.size(); ++i)
	{
		int32_t nTempId = reqMsg.m_nStageInfo[i];
		msg.m_nMyHistoryInfo[nTempId] = SPECIES_RANK_NONE;	
	}
	mem::vector<uint64_t> allIds;
	UT_ServerHelper:: GetAllIdVectorFromRedisRankPonitNameByTypeAndStoryId(allIds, nType,nStoryId);
	msg.m_nTotalCount = allIds.size();

	const unique_id_impl& playerInstance = GetInstance();
	GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "GetGuildFightRankInfo nType: %d, nStoryId:%d c_cid:%d, c_citizenship:%d, c_uid:%d, size:%d",
		nType,nStoryId, playerInstance.detail(), playerInstance.catagory(), GetUserID(), msg.m_nTotalCount);
			
	StringType redisPlayerInfoStr ="";
	UT_ServerHelper:: GetRedisRankPlayerInfoNameByType(redisPlayerInfoStr,nType,nStoryId);
	bool findFlag = false;
	if(mySelfID != 0)
	{
		for(int i=0; i<allIds.size(); ++i)
		{
			if(allIds[i] != mySelfID)
				continue;
			findFlag = UT_ServerHelper::Pack_Single_info(redisPlayerInfoStr,i,allIds[i],msg.m_nMyselfInfo);
			myIndex = i;
			break;
		}
	}
	if(!findFlag)
		FillGuildFightRankMyInfo(msg.m_nMyselfInfo,myIndex,nType);
	//组装 排行榜信息
	if(allIds.size() > 0)
	{
		maxIndex = maxIndex > allIds.size()-1 ? allIds.size()-1 : maxIndex;
		for(int i=minIndex; i<=maxIndex; ++i)
		{
			PS_RANK_STRUCT Info;
			UT_ServerHelper::Pack_Single_info(redisPlayerInfoStr,i,allIds[i],Info);
			msg.m_nPlayerInfo.push_back(Info);
		}
	}
	//maxIndex = maxIndex > allIds.size()-1 ? allIds.size()-1 : maxIndex;
	msg.m_nMyHistoryInfo[nStoryId] = myIndex;
	for(int i = 0; i < reqMsg.m_nStageInfo.size(); ++i)
	{
		int32_t nTempId = reqMsg.m_nStageInfo[i];
		if(nTempId == nStoryId)
			continue;
		mem::vector<uint64_t> allIdsTemp;
		UT_ServerHelper:: GetAllIdVectorFromRedisRankPonitNameByTypeAndStoryId(allIdsTemp, nType,nTempId);
		if(allIdsTemp.size() <= 0)
			continue;
		for (int32_t j = 0; j < allIdsTemp.size(); ++j)
		{
			if(mySelfID != allIdsTemp[j])
				continue;
			msg.m_nMyHistoryInfo[nTempId] = j;
			break;
		}
	}
	return RE_SUCCESS;
}

bool LC_ServerPlayer::CommitAnswer(int topicIndex, int choice)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->CommitAnswer(topicIndex, choice);
	}

	const unique_id_impl& instance = GetInstance();
	if(GetMapLogicType() != MT_GUILD_PARTYFUBEN)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "[CheckAnswerChoice] not MT_GUILD_PARTYFUBEN!c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAnswerRecord size:%d, id:%d", 
			instance.detail(), instance.catagory(), GetUserID(), m_nAnswerRecord.size(), topicIndex);
		return RE_ANSWER_INVAILD;
	}
	
	bool tag = CheckCommitVaild(topicIndex);
	if(!tag)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "[CheckAnswerChoice] RE_ANSWER_INVAILD!c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAnswerRecord size:%d, id:%d", 
			instance.detail(), instance.catagory(), GetUserID(), m_nAnswerRecord.size(), topicIndex);
		return RE_ANSWER_INVAILD;
	}

	tag = CheckAnswerChoice(topicIndex, choice);

	return tag;
}

bool LC_ServerPlayer::CheckCommitVaild(int topicIndex)
{
	//check活动是否开启
	bool tag = UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Answer);
	if(!tag)
	{
		return false;
	}

	//检测当前题目是否是合法题目
	uint32_t currentTimestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	uint32_t minTime = 0;
	uint32_t maxTime = 0;
	UT_ServerHelper::GetTopicVaildTime(topicIndex, minTime, maxTime);

	//延迟2秒是合法的
	if(minTime<=currentTimestamp && currentTimestamp<=maxTime+2)
	{
		return true;
	}

	return false;
}

bool LC_ServerPlayer::CheckAnswerChoice(int topicIndex, int choice)
{
	if(ANSWER_NOT_JOIN == m_nAnswerAccPoint)
	{
		m_nAnswerAccPoint = ANSWER_JOINED;
		m_nAnswerGuildAccPoint = 0;
		m_nAnswerRecord.clear();
		m_nAnswerRewardRecord.clear();
	}
	const unique_id_impl& instance = GetInstance();
	mem::map<int32_t, bool>::iterator it = m_nAnswerRecord.find(topicIndex);
	if(it != m_nAnswerRecord.end())
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "[CheckAnswerChoice] Error!c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAnswerRecord size:%d, id:%d, answerid:%d", 
		instance.detail(), instance.catagory(), GetUserID(), m_nAnswerRecord.size(), topicIndex, it->second);
		return it->second;
	}

	int topicID = UT_ServerHelper::GetTopicIDFromTopicIndex(topicIndex);
	CF_TestDatabase::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_TestDatabase>(topicID);
	if(NULL == pkData)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "[CheckAnswerChoice] false!c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAnswerRecord size:%d, id:%d, topicID:%d", 
			instance.detail(), instance.catagory(), GetUserID(), m_nAnswerRecord.size(), topicIndex, topicID);
		return false;
	}

	AchievementEvent kEvent;
	kEvent.SetNum(1);
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_ANSWER_TIMES, kEvent);
	
	bool tag = pkData->_rightAnswer==choice ? true : false;

	m_nAnswerRecord.insert(std::make_pair(topicIndex, tag));

	if(tag)
	{
		m_nAnswerAccPoint += pkData->_award;
		m_nAnswerGuildAccPoint += pkData->_award;
		
		m_bUpdataRedis = true;
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "[CheckAnswerChoice] Success!c_cid:%d, c_citizenship:%d, c_uid:%d, m_nAnswerRecord m_nAnswerAccPoint:%d,m_nAnswerGuildAccPoint:%d, id:%d", 
			instance.detail(), instance.catagory(), GetUserID(), m_nAnswerAccPoint, m_nAnswerGuildAccPoint, topicIndex);
	}

	return tag;
}

void LC_ServerPlayer::CheckAnswerAward()
{
	bool sync = false;
	if(m_bUpdataRedis)
	{
		//更新redis中的积分
		uint32_t currentTime  = GET_CURRENT_TIMESTAMP_IN_SECONDS();
		uint32_t inputTime = LC_Helper::TimeStampReverse(currentTime);
		uint64_t value = LC_Helper::EncodeScore(m_nAnswerAccPoint, inputTime);
		UT_ServerHelper::RedisRank_WriteElement(UT_REDIS_KEY_ANSWER_ACCOUNT_POINT, GetInstance(), value);

		AnswerInfo info;
		info.charName = GetOwnerCharName().c_str();
		info.accountPoint = m_nAnswerAccPoint;
		std::stringstream ss;
		boost::ajson::save_to_buff(info, ss);
		std::string data = ss.str().c_str();

		mem::vector<uint64_t> key;
		key.push_back(GetInstance());

		UT_ServerHelper::RedisSetData_String(UT_REDIS_KEY_ANSWER_PLAYER_INFO, key, data, false, true);
		int nAddGuildValue = m_nAnswerGuildAccPoint;
		m_nAnswerGuildAccPoint = 0;
		UT_ServerHelper::AddGuildAnswerPoint(nAddGuildValue, GetGuildID(), GetGuildName());
		
		m_bUpdataRedis = false;

		sync = true;
	}

	//发奖
	CF_TestAccPointRewards::DataEntryMapExternIterator kIter = CF_TestAccPointRewards::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_TestAccPointRewards::DataEntry* pkEntry = kIter.PeekNextValuePtr();
		if(m_nAnswerAccPoint >= pkEntry->_accountPoint)
		{
			mem::vector<int32_t>::iterator findIt = find(m_nAnswerRewardRecord.begin(), m_nAnswerRewardRecord.end(), pkEntry->_id);
			if(findIt == m_nAnswerRewardRecord.end())
			{
				//重返考场--埋点
				int nLogCode = LC_Helper::SerializeOperateLogCode(FUBEN_LOGTYPE, FUBEN7_OPERATE, OPERATE_LOGTYPE1);
				//发奖
				ResultType res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkEntry->_rewards, this, SYS_FUNC_TP_ANSWER_ACCPOINT_REWAER, pkEntry->_id, "69;", "70;", true,false,false,nLogCode);
				if(RE_SUCCESS == res)
				{
					sync = true;
					m_nAnswerRewardRecord.push_back(pkEntry->_id);
				}
			}
		}
	}

	if(sync)
	{
		SyncAnswerInfo();
	}
}

void LC_ServerPlayer::SyncAnswerInfo(bool checkVaild)
{
	if(checkVaild && false==UT_ServerHelper::CheckStoryIsActive(GameStoryIDType_Answer))
	{
		return;
	}

	MG_SyncAnswerInfo syncMsg;
	syncMsg.m_nAnswerAccPoint = m_nAnswerAccPoint;
	for(int i=0; i<m_nAnswerRewardRecord.size(); ++i)
	{
		syncMsg.m_nAnswerRewardID.push_back(m_nAnswerRewardRecord[i]);
	}

	SendMsgToClient(MGPT_SYNCANSWERINFO, &syncMsg);
}

bool LC_ServerPlayer::SaveAnswerData(::char_data_define::PBAnswerData* pkData)
{
	if(NULL == pkData)
	{
		return false;
	}

	pkData->set_updatetoredis(m_bUpdataRedis);
	pkData->set_answeractivityendtime(m_nAnswerActivityEndTime);
	pkData->set_answeraccpoint(m_nAnswerAccPoint);
	pkData->set_answerguildaccpoint(m_nAnswerGuildAccPoint);
	for(mem::map<int32_t, bool>::iterator it=m_nAnswerRecord.begin(); it!=m_nAnswerRecord.end(); ++it)
	{
		::char_data_define::char_AnswerRecord* data = pkData->add_answerrecord();
		if(NULL != data)
		{
			data->set_topicindex( it->first);
			data->set_right(it->second);
		}		
	}

	for(int i=0; i<m_nAnswerRewardRecord.size(); ++i)
	{
		pkData->add_answerrewardrecord(m_nAnswerRewardRecord[i]);
	}

	return true;
}

bool LC_ServerPlayer::LoadAnswerData(const ::char_data_define::PBAnswerData& data)
{
	m_bUpdataRedis = data.updatetoredis();
	m_nAnswerActivityEndTime = data.answeractivityendtime();
	m_nAnswerAccPoint = data.answeraccpoint();
	m_nAnswerGuildAccPoint = data.answerguildaccpoint();
	for(int i=0; i<data.answerrecord_size(); ++i)
	{
		m_nAnswerRecord.insert(std::make_pair(data.answerrecord(i).topicindex(), data.answerrecord(i).right()));
	}

	int size = data.answerrewardrecord_size();
	m_nAnswerRewardRecord.reserve(size);
	for(int i=0; i<size; ++i)
	{
		m_nAnswerRewardRecord.push_back(data.answerrewardrecord(i));
	}

	return true;
}

void LC_ServerPlayer::GetNearbyPlayer(MG_RLT_GetNearbyPlayer& msg)
{
	int playerLogicMapID = GetMapLogicID();

	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	
	LC_ServerMapLogic_Place* pkPlace = pkWorldManager->GetMapLogic(playerLogicMapID);
	if (NULL == pkPlace)
	{
		return;
	}

	uint64_t mySelfID = GetInstance();

	mem::set<uint64_t> ownerPlayerInstancIDs;

	GameLogic::LC_ActorPtrList kAllActorPtr;
	pkPlace->GetAllPlayer(kAllActorPtr);
	for(LC_ActorPtrList::iterator it=kAllActorPtr.begin(); it!=kAllActorPtr.end(); ++it)
	{
		LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)*it;
		LC_ServerPlayer* pkOwnerPlayer = pkPlayer->GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			continue;
		}

		uint64_t otherInstanceID = pkOwnerPlayer->GetInstance();
		if(mySelfID!=otherInstanceID && otherInstanceID>PLAYER_CLONE_ID_MIN)
		{
			ownerPlayerInstancIDs.insert(otherInstanceID);
		}
	}

	LC_ServerPlayerManager* pkServerPlayerManager = SERVER_GET_PLAYER_MANAGER();
	for(mem::set<uint64_t>::iterator it=ownerPlayerInstancIDs.begin(); it!=ownerPlayerInstancIDs.end(); ++it)
	{
		uint64_t charID = *it;
		LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)(pkServerPlayerManager->FindPlayer(charID));
		if (NULL != pkPlayer)
		{
			PS_NearbyPlayerInfo info;
			info.m_nCharID = charID;
			info.m_nCharName = pkPlayer->GetOwnerCharName().c_str();
			info.m_nGuildID = pkPlayer->GetGuildID();
			info.m_nGuildName = pkPlayer->GetGuildName().c_str();
			info.m_nControllerLevel = pkPlayer->GetControllerLevel();
			info.m_nGroupID = pkPlayer->GetPlayerGroupID();
			info.m_nAvtivityBuddyCombatScore = pkPlayer->GetActivateBuddyCombatScore();
			info.m_nGroupCount = 0;
			LC_PlayerGroupBase* pkGroup = pkPlayer->GetPlayerGroup();
			if(NULL != pkGroup)
			{
				info.m_nGroupCount = pkGroup->GetMemberCount(false);
			}
			info.m_nMaxGroupCount = MAX_PLAYER_GROUP_MEMBER_LIST_SIZE;

			msg.m_nNearbyPlayer.push_back(info);
		}
	}
}

void LC_ServerPlayer::SyncBuddyRuneSlotState(bool broadcase)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->SyncBuddyRuneSlotState(broadcase);
	}

	MG_SyncBuddyRuneSlotState msg;
	msg.m_lPlayerID = GetID();
	msg.m_nBuddyRuneSlotState = GetBuddyRuneEquipState();
	if(broadcase)
	{
		BroadCastToArea(MGPT_SYNCBUDDYRUNESLOTSTATE, &msg);
	}
	else
	{
		SendMsgToClient(MGPT_SYNCBUDDYRUNESLOTSTATE, &msg);
	}
	
}

void LC_ServerPlayer::BroadcastBuddyStarLevel(object_id_type nPlayerId, int32_t nBuddyId, int32_t nLevel)
{
	MG_RefreshBuddyStarLevel data;
	data.m_lPlayerID = nPlayerId;
	data.m_lBuddyId = nBuddyId;
	data.m_nStarLevel = nLevel;
	BroadCastToArea(MGPT_REFRESH_PLAYER_STAR_LEVEL, &data);
}

void LC_ServerPlayer::BroadcastBuddyRuneStarLevel(object_id_type nPlayerId, int32_t nBuddyId, int16_t nPos, int32_t nItemId, int16_t nLevel)
{
	MG_RefreshBuddyRuneLevel data;
	data.m_lPlayerID = nPlayerId;
	data.m_lBuddyId = nBuddyId;
	data.m_lRuneItemId = nItemId;
	data.m_nPosIndex = nPos;
	data.m_nRuneLevel = nLevel;
	BroadCastToArea(MGPT_REFRESH_PLAYER_RUNE_LEVEL, &data);
}

void LC_ServerPlayer::BroadcastBuddyEquipSlotStarLevel(object_id_type nPlayerId, int32_t nBuddyId, int32_t equipSlotIndex, int32_t equipSlotStarLevel)
{
	MG_RefreshBuddyEquipSlotStarLevel data;
	data.m_lPlayerID = nPlayerId;
	data.m_lBuddyId = nBuddyId;
	data.m_nEquipSlotIndex = equipSlotIndex;
	data.m_nEquipSlotStarLevel = equipSlotStarLevel;
	BroadCastToArea(MGPT_REFRESH_BUDDY_EQUIPSLOT_STARLEVEL, &data);
}

void LC_ServerPlayer::BroadcastBuddyEquipSlotLevelCount(object_id_type nPlayerId, int32_t nBuddyId, int32_t equipSlotLevelCount)
{
	MG_RefreshBuddyEquipSlotLevelCount data;
	data.m_lPlayerID = nPlayerId;
	data.m_lBuddyId = nBuddyId;
	data.m_nEquipSlotLevelCount = equipSlotLevelCount;
	BroadCastToArea(MGPT_REFRESH_BUDDY_EQUIPSLOTLEVELCOUNT, &data);
}

void LC_ServerPlayer::BroadcastBuddyEquipItem(object_id_type nPlayerId, int32_t nBuddyId, int32_t equipSlotIndex, int32_t equipItem)
{
	MG_RefreshBuddyEquipItem data;
	data.m_lPlayerID = nPlayerId;
	data.m_lBuddyId = nBuddyId;
	data.m_nEquipSlotIndex = equipSlotIndex;
	data.m_nEquipItem = equipItem;
	BroadCastToArea(MGPT_REFRESHBUDDYEQUIPITEM, &data);
}

void LC_ServerPlayer::BroadcastBuddyCurrentTransformID(object_id_type nPlayerId, int32_t nBuddyId, int32_t nBuddyCurrentTransformID)
{
	MG_RefreshBuddyTransformID data;
	data.m_lPlayerID = nPlayerId;	
	data.m_lBuddyId = nBuddyId;
	data.m_nBuddyCurrentTransformID = nBuddyCurrentTransformID;
	BroadCastToArea(MGPT_REFRESHBUDDYTRANSFORMID, &data);
}

void LC_ServerPlayer::BroadcastBuddyEquipSlotState(bool broadCast)
{ 
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return;

	if(!IsMainController())
	{
		return pkOwnerPlayer->BroadcastBuddyEquipSlotState(broadCast);
	}

	MG_RefreshBuddyEquipSlotState data;
	data.m_lPlayerID = GetID();
	data.m_nEquipSlotState = GetBuddyEquipSlotStarState();
	if(broadCast)
	{
		BroadCastToArea(MGPT_BUDDY_EQUIP_SLOT_STATE, &data);
	}
	else
	{
		SendMsgToClient(MGPT_BUDDY_EQUIP_SLOT_STATE, &data);
	}
}

void LC_ServerPlayer::FillRuneLevelInfoPB(::google::protobuf::RepeatedField< ::google::protobuf::int32 > & item_info, ::google::protobuf::RepeatedField< ::google::protobuf::int32 > & level_info )
{
	std::map<int32_t, PS_RuneItemInfo_BuddyCS> mapInfo;
	if(NULL != m_pAssignedBuddyInstance)
		m_pAssignedBuddyInstance->GetBuddyRuneInfo(mapInfo);
	// here should be instead by MACRO
	for ( int i = 0; i < 4; i++ )
	{
		std::map<int, PS_RuneItemInfo_BuddyCS>::iterator it = mapInfo.find(i);
		if (it == mapInfo.end())
		{
			item_info.Add(-1);
			level_info.Add(-1);
		}
		else
		{
			PS_RuneItemInfo_BuddyCS& data = it->second;
			item_info.Add(data.m_nRuneItemID);
			level_info.Add(data.m_nRuneStarLevel);
		}
	}
	return;
}

void LC_ServerPlayer::RecomputerRuneTotalLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}
	
	if(!IsMainController())
	{
		return pkOwnerPlayer->RecomputerRuneTotalLevel();
	}

	LC_PackAsset* pkAsset = GetPackAsset();
	if(NULL == pkAsset)
	{
		return;
	}

	int32_t newLevel = 0;
	//基础背包
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				newLevel += pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_CURRENT_REINFORCE_LEVEL);
			}
		}
	}

	//仓库里的装备
	int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
	for (int32_t i = 0;i < iWarehousePackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				newLevel += pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_CURRENT_REINFORCE_LEVEL);
			}
		}
	}

	//buddy宝具槽位
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin();  it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			newLevel += pkBuddy->GetBuddyRuneTotalLevel();
		}
	}

	int32_t oldLevel = GetRuneTotalLevel();
	if(newLevel > oldLevel)
	{
		m_RuneData.SetTotalLevel(newLevel);
		SyncControllerPropertyToClient();
	}
	
	if(newLevel != oldLevel)
	{
		UpdateRankUserValueByRankType(Rank_Type_Rune);
	}
}

void LC_ServerPlayer::RecomputerRuneTotalStarLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->RecomputerRuneTotalStarLevel();
	}

	LC_PackAsset* pkAsset = GetPackAsset();
	if(NULL == pkAsset)
	{
		return;
	}

	int newStarLevel = 0;
	//基础背包
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				newStarLevel += pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_STAR);
			}
		}
	}

	//仓库里的装备
	int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
	for (int32_t i = 0;i < iWarehousePackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				newStarLevel += pkItemEntry->GetBackPackValueByType(LCSPET_EQUIP_STAR);
			}
		}
	}

	//buddy宝具槽位
	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin();  it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL != pkBuddy)
		{
			newStarLevel += pkBuddy->GetBuddyRuneTotalStarLevel();
		}
	}

	int oldStarLevel = GetRuneTotalStarLevel();
	if(newStarLevel > oldStarLevel)
	{
		m_RuneData.SetTotalStarLevel(newStarLevel);
		SyncControllerPropertyToClient();
	}

	if(newStarLevel != oldStarLevel)
	{
		UpdateRankUserValueByRankType(Rank_Type_Rune);
	}
}

int32_t LC_ServerPlayer::GetRuneTotalLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRuneTotalLevel();
	}

	return m_RuneData.GetTotalLevel();
}

int32_t LC_ServerPlayer::GetRuneTotalStarLevel()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if(!IsMainController())
	{
		return pkOwnerPlayer->GetRuneTotalStarLevel();
	}

	return m_RuneData.GetTotalStarLevel();
}

bool LC_ServerPlayer::DecompositionRune(int32_t lItemID, int32_t slotIndex, std::vector<PS_AddRuneInfo>& msg)
{
	bool tag = false;
	LC_PackAsset* pkPlayerBasicAsset = GetPackAsset();
	if(NULL == pkPlayerBasicAsset)
	{
		return false;
	}
	
	const LC_BackPackEntry* pkItemEntry = NULL;
	if(!tag)
	{
		//基础槽
		LC_BasicPack& pkBasicSlot = pkPlayerBasicAsset->GetBasicPack();
		for(int i = 0; i < pkBasicSlot.GetCapacity(); i++)
		{
			pkItemEntry = &(pkBasicSlot.m_aData[i]);
			if(pkItemEntry->GetBackPackValueByType(LPSFET_VALID) && pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID)==lItemID && slotIndex!=i)
			{
				tag = true;
				break;
			}
		}
	}

	if(!tag)
	{
		//宝具槽
		pkItemEntry = GetRuneDataFromBuddyRune(lItemID);
		if(NULL != pkItemEntry)
		{
			tag = true;
		}
	}

	if(!tag)
	{
		//仓库里的装备
		LC_WarehousePack& pkWarehouseSlot = pkPlayerBasicAsset->GetWarehousePack();
		for(int i = 0; i < pkWarehouseSlot.GetCapacity(); i++)
		{
			pkItemEntry = &(pkWarehouseSlot.m_aData[i]);
			if(pkItemEntry->GetBackPackValueByType(LPSFET_VALID) && pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID)==lItemID)
			{
				tag = true;
				break;
			}
		}
	}

	PS_AddRuneInfo info;
	info.m_nResult = RE_SUCCESS;
	info.m_nRuneID = lItemID;
	info.m_bFirstAdd = true;

	if(tag)
	{
		std::vector<int32_t> equipSlot;
		equipSlot.push_back(slotIndex);
		//现在背包里有，分解
		info.m_bFirstAdd = false;
		info.m_nResult = DecompositionEquip(equipSlot, info.m_nDecompositionResult, false, true);
	}
	msg.push_back(info);

	return tag;
}

void LC_ServerPlayer::UpdateSubB(int type, bool force, int param)
{
	if(IsRobot())
	{
		return;
	}

	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL != pkOwnerPlayer)
		{
			return pkOwnerPlayer->UpdateSubB(type, force, param);
		}
		else
		{
			return;
		}
	}

	const unique_id_impl& playerInstance = GetInstance();
	const CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs* entryPtrs = CActSubordinateRewardManager::GetSingletonPtr()->GetActSubordinateRewardEntrysByType(type);
	if(NULL == entryPtrs)
	{
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "UpdateSubB_3 type is null! type:%d, c_id:%d, c_citizenship:%d, c_uid:%d", type, playerInstance.detail(), playerInstance.catagory(), GetUserID());
		return;
	}

	//更新开服争霸榜数据
	for(CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs::const_iterator it = entryPtrs->begin(); it!=entryPtrs->end(); ++it)
	{
		CF_ACTSubordinateRewardB::DataEntry* pkEntry = *it;
		if(NULL == pkEntry)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "UpdateSubB_3 pkEntry is null! c_id:%d, c_citizenship:%d, c_uid:%d, type:%d", playerInstance.detail(), playerInstance.catagory(), GetUserID(), type);
			continue;
		}

		if(false == force)
		{
			bool flag = UT_ServerHelper::CheckActivityVaild(pkEntry->_iFinishSchedule);
			if(false == flag)
			{
				continue;
			}
		}

		bool tag = UT_ServerHelper::CheckActivityVaild(pkEntry->_iSchedule);
		if(!tag)
		{
			continue;
		}

		uint32_t value = 0;
		uint32_t result = 0;
		tag = UT_ServerHelper::GetSubBData(this, type, pkEntry->_Params, param, value, result);
		if(!tag)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "UpdateSubB_5 GetSubBData error! c_id:%d, c_citizenship:%d, c_uid:%d, id:%d, type:%d, param:%d",
				playerInstance.detail(), playerInstance.catagory(), GetUserID(), pkEntry->_iID, type, param);
			continue;
		}

		UpdateSubBValue(pkEntry->_GroupID, result);

		UT_ServerHelper::DoUpdateRankInfoToRedis(this, type, pkEntry->_GroupID, value);
	}
}

void LC_ServerPlayer::ApplyCommanderTitleSystem()
{
	int titleID = GetCommanderTitle();
	if(titleID == 0)
		titleID = 1;
	UpdateCommanderTitle(titleID);
}

ResultType LC_ServerPlayer::UpgradeCommanderTitle()
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return res;
	if (!IsMainController())
		return pkOwnerPlayer->UpgradeCommanderTitle();
	int currentTitleID = GetCommanderTitle();
	int newTitleID = currentTitleID+1;
	CF_CommanderTitle::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_CommanderTitle>(currentTitleID);
	if(NULL == pkData)
		return RE_FAIL;
	//检查升级条件
	res = CheckUpgradeCommanderTitle();
	if(RE_SUCCESS != res)
		return res;
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(newTitleID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, TITLES_OPERATE ,OPERATE_LOGTYPE2);
	//领奖
	StringType mailTitle;
	StringType mailDesc;
	res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_sReward, this, SYS_FUNC_TP_COMMANDER_TITLE_REWARD, currentTitleID, mailTitle, mailDesc, false,false,false,nLogCode, nParams);
	if(RE_SUCCESS != res)
		return res;
	//更新guildMember的指挥官头衔id
	UpdateGuildMemberInfo(false, true);
	//客户端要求，升级成功后，属性和战力数据要在MG_RLT_UpgradeCommanderTitle前发送
	SyncCommanderAttributeToClient(SPAT_CommanderAllAttr,*(GetCommanderAttrMgr().GetCommanderAllAttributeMap()), false, GetControllerCombatScore(), SPART_CommanderTitle_1);
	//更新等级 派发任务
	UpdateCommanderTitle(newTitleID);
	SaveCharPB(false);
	UT_ServerHelper::UpdatePlayerInfoGuildName(GetInstance(),GetOwnerCharName().c_str(),GetGuildName().c_str(),GetInstance(),GetGuildID(),newTitleID);
	return RE_SUCCESS;
}

int LC_ServerPlayer::GetCommanderTitle()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		LC_ActorBase::GetCommanderTitle();
	if (!IsMainController())
		return pkOwnerPlayer->GetCommanderTitle();
	return m_nCommanderTitle;
}

ResultType LC_ServerPlayer::UpdateCommanderTitle(int newTitle)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
		return res;
	if (!IsMainController())
		return pkOwnerPlayer->UpdateCommanderTitle(newTitle);
	if(newTitle != m_nCommanderTitle)
	{
		SetCommanderTitle(newTitle);
		OnTitleChanged(m_nCommanderTitle);
		UpdateRankInfoToRedis(Sub_Reward_Type_CommanderTitle);

		if(m_nCommanderTitle >= GetGlobalSetting.CommanderTitleID)
		{
			CF_CommanderTitle::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_CommanderTitle>(m_nCommanderTitle);
			if(NULL != pkData)
			{
				UT_ServerHelper::_GameNoticeFmort noticeFmort;
				noticeFmort.SetMsgID(20);
				noticeFmort.AddString(GetOwnerCharName());//玩家名
				noticeFmort.AddCommanderTitleName(m_nCommanderTitle);//神职等级
				UT_ServerHelper::BrocastNoticeMsg(noticeFmort, GetCitizenship());
			}
		}
		SetBroadCastFlag(LC_PlayerBase::E_DirtyFlag_ControllerProperty);
	}
	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::CheckUpgradeCommanderTitle()
{
	int currentTitleID = GetCommanderTitle();
	CF_CommanderTitle::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_CommanderTitle>(currentTitleID);
	if(NULL == pkData)
		return RE_FAIL;

	bool finish = true;
	//检测任务是否已经完成
	const Utility::UT_SIMDataList& taskConditions = pkData->_sTaskID;
	if(!taskConditions.empty())
	{
		for(Utility::UT_SIMDataList::const_iterator it=taskConditions.begin(); it!=taskConditions.end(); ++it)
		{
			int taskID = it->IID();
			if(!IsInFinishedTaskMap(taskID))
			{
				finish = false;
				break;
			}
		}
	}

	if(!finish)
	{
		return RE_COMMANDER_CONDITION_NOT_ENOUGH;
	}

	//检测历练是否已经完成
	const Utility::UT_SIMDataList& achievementConditions = pkData->_sAchievementID;
	for(Utility::UT_SIMDataList::const_iterator it=achievementConditions.begin(); it!=achievementConditions.end(); ++it)
	{
		int achievementID = it->IID();
		if(!IsInFinishAchievementMap(achievementID))
		{
			finish = false;
			break;
		}
	}

	if(!finish)
	{
		return RE_COMMANDER_CONDITION_NOT_ENOUGH;
	}

	return RE_SUCCESS;
}

bool LC_ServerPlayer::SetCommanderTitle(int32_t titleID)
{
	if(m_nCommanderTitle >= titleID || titleID<1)
	{
		return false;
	}
	m_nCommanderTitle = titleID;
	UpdatePlayerBaseDataToGroup();
	return true;
}

ResultType LC_ServerPlayer::GetServerFirstKillBossReward(int npcID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetServerFirstKillBossReward(npcID);
	}

	CF_BossFirstKill::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BossFirstKill>(npcID);
	if(NULL == pkData)
	{
		return res;
	}

	res = CheckCanGetServerFirstKillBossReward(npcID);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//boss是否被首杀了
	bool tag = UT_ServerHelper::CheckBossBeKilled(npcID);
	if(!tag)
	{
		return RE_FAIL;
	}
	//BOSS全服首杀
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(npcID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY7_OPERATE, OPERATE_LOGTYPE1);
	//领奖
	StringType mailTitle;
	StringType mailDesc;
	res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_kServerReward, this, SYS_FUNC_TP_SERVERKILLBOSSREWARD, npcID, mailTitle, mailDesc, false, false,false,nLogCode,nParams);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//更新领奖记录
	res = UpdataServerFirstKillBossReward(npcID);

	if(RE_SUCCESS == res)
	{
		UT_ServerHelper::UpdateServerFirstKillBossRewardPlayerInfo(this, npcID, TPSTR2STDSTR(GetOwnerCharName()), GetLevel(), GetCommanderTitle(), GetProfilePictureID(), GetCurrentCommanderTitleFrameID());
	}
	return res;
}

ResultType LC_ServerPlayer::CheckCanGetServerFirstKillBossReward(int npcID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckCanGetServerFirstKillBossReward(npcID);
	}

	mem::set<int32_t>::iterator findIt = m_nFirstKillBossRewardRecord.find(npcID);
	return findIt==m_nFirstKillBossRewardRecord.end() ? RE_SUCCESS : RE_FAIL;
}

ResultType LC_ServerPlayer::UpdataServerFirstKillBossReward(int npcID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->UpdataServerFirstKillBossReward(npcID);
	}

	res = m_nFirstKillBossRewardRecord.insert(npcID).second ? RE_SUCCESS : RE_FAIL;
	if(RE_SUCCESS == res)
	{
		SyncServerFirstKillBossReward();
	}
	return res;
}

void LC_ServerPlayer::SyncServerFirstKillBossReward()
{
	MG_SyncServerFirstKillBossReward syncMsg;
	for(mem::set<int32_t>::iterator it=m_nFirstKillBossRewardRecord.begin(); it!=m_nFirstKillBossRewardRecord.end(); ++it)
	{
		syncMsg.m_nFirstKillBossRewardRecord.push_back(*it);
	}

	if(!syncMsg.m_nFirstKillBossRewardRecord.empty())
	{
		SendMsgToClient(MGPT_SYNCSERVERFIRSTKILLBOSSREWARD, &syncMsg);
	}
}

ResultType LC_ServerPlayer::GetKillBossReward(int npcID)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetKillBossReward(npcID);
	}

	CF_BossFirstKill::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_BossFirstKill>(npcID);
	if(NULL == pkData)
	{
		return res; 
	}

	//能否领奖
	res = CheckCanGetKillBossReward(npcID);
	if(RE_SUCCESS != res)
	{
		return res;
	}	
	//BOSS个人首杀
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(npcID);
	int nLogCode = LC_Helper::SerializeOperateLogCode(ACTIVITY_LOGTYPE, ACTIVITY7_OPERATE, OPERATE_LOGTYPE2);

	//领奖
	StringType mailTitle;
	StringType mailDesc;
	res = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_kReward, this, SYS_FUNC_TP_KILLBOSSREWARD, npcID, mailTitle, mailDesc, false,false,false,nLogCode,nParams);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//更新领奖记录
	res = UpdateKillBossRecord(npcID);

	return res;
}

ResultType LC_ServerPlayer::CheckCanGetKillBossReward(int npcID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckCanGetKillBossReward(npcID);
	}

	mem::map<int32_t, bool>::iterator findIt = m_nKillBossRecord.find(npcID);
	if(findIt == m_nKillBossRecord.end())
	{
		return RE_FAIL;
	}
	
	return findIt->second ? RE_FAIL : RE_SUCCESS;	
}


void LC_ServerPlayer::AddKillBossRecord(int npcID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->AddKillBossRecord(npcID);
	}

	mem::map<int32_t, bool>::iterator findIt = m_nKillBossRecord.find(npcID);
	if(findIt == m_nKillBossRecord.end())
	{
		m_nKillBossRecord.insert(std::make_pair(npcID, false));
		SyncKillBossReward();
	}
}

ResultType LC_ServerPlayer::UpdateKillBossRecord(int npcID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->UpdateKillBossRecord(npcID);
	}

	mem::map<int32_t, bool>::iterator findIt = m_nKillBossRecord.find(npcID);
	if(findIt == m_nKillBossRecord.end())
	{
		return RE_FAIL;
	}

	findIt->second = true;
	SyncKillBossReward();

	return RE_SUCCESS;
}

void LC_ServerPlayer::SyncKillBossReward()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->SyncKillBossReward();
	}

	MG_SyncKillBossReward syncMsg;
	for(mem::map<int32_t, bool>::iterator it=m_nKillBossRecord.begin(); it!=m_nKillBossRecord.end(); ++it)
	{
		syncMsg.m_nBossRewardInfos.insert(std::make_pair(it->first, it->second));
	}

	if(!syncMsg.m_nBossRewardInfos.empty())
	{
		SendMsgToClient(MGPT_SYNCKILLBOSSREWARD, &syncMsg);
	}
}

void LC_ServerPlayer::SyncServeFirstKillBossInfo()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->SyncServeFirstKillBossInfo();
	}

	CF_BossFirstKill::DataEntryMapExternIterator it = CF_BossFirstKill::GetSingletonPtr()->GetIterator();
	for(; it.HasMoreElements(); it.MoveNext())
	{
		const CF_BossFirstKill::DataEntry* pkData = it.PeekNextValuePtr();
		int npcID = pkData->_CharTypeID;

		BossFirstKillPlayerInfo info;
		bool tag = UT_ServerHelper::GetServeFirstKillBossInfo(npcID, info);
		if(tag)
		{
			SyncBossFirstKillInfo(npcID, info);
		}
	}	
}

bool LC_ServerPlayer::CheckSevenDayTime1Vaild()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckSevenDayTime1Vaild();
	}

	uint32_t registerTime = GetRegTime();
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if(currentTime < registerTime)
	{
		return false;
	}

	return currentTime<m_nSevenDayEndTime1 ? true : false;
}

bool LC_ServerPlayer::CheckSevenDayTime2Vaild()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckSevenDayTime1Vaild();
	}

	uint32_t registerTime = GetRegTime();
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if(currentTime < registerTime)
	{
		return false;
	}

	return currentTime<m_nSevenDayEndTime2 ? true : false;
}

void LC_ServerPlayer::SyncSevenDayTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->SyncSevenDayTime();
	}

	MG_SyncSevenDayFinishTime msg;
	msg.m_nSevenDayEndTime1 = m_nSevenDayEndTime1;
	msg.m_nSevenDayEndTime2 = m_nSevenDayEndTime2;
	SendMsgToClient(MGPT_SYNCSEVENDAYFINISHTIME, &msg);
}

uint32_t LC_ServerPlayer::GetSevenDayEndTime1()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetSevenDayEndTime1();
	}

	return m_nSevenDayEndTime1;
}

uint32_t LC_ServerPlayer::GetSevenDayEndTime2()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetSevenDayEndTime2();
	}

	return m_nSevenDayEndTime2;
}

void LC_ServerPlayer::SyncFirstDayLoginRewardTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->SyncFirstDayLoginRewardTime();
	}

	MG_SyncFirstDayLoginRewardTime msg;
	msg.m_nFirstDayLoginRewardTime = m_nFirstDayLoginRewardTime;
	SendMsgToClient(MGPT_SYNCFIRSTDAYLOGINREWARDTIME, &msg);
}

uint32_t LC_ServerPlayer::GetFirstDayLoginRewardTime()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return 0;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetFirstDayLoginRewardTime();
	}

	return m_nFirstDayLoginRewardTime;
}

ResultType LC_ServerPlayer::GetSpecialTrainingReward(int id)
{
	ResultType res = RE_FAIL;
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return res;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->GetSpecialTrainingReward(id);
	}

	CF_SpecialTraining::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SpecialTraining>(id);
	if(NULL == pkData)
	{
		return res;
	}

	bool tag = CheckSTRewardRecord(id);
	if(!tag)
	{
		return RE_ALREADY_GET_REWARD;
	}

	res = CheckSTRewardCondition(id);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//特训优化，服务器主动领奖
	res = AddSTTaskReward(id);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	//检测是否可以领奖
	res = LC_Helper::CanAddItemEx(this, pkData->_reward, CIET_NONE);
	if(RE_SUCCESS != res)
	{
		return res;
	}

	res = UpdateSTRewardRecord(id, pkData->_reward);
	return res;
}

void LC_ServerPlayer::SyncSTRewardRecord()
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->SyncSTRewardRecord();
	}

	MG_SyncSpecialTrainingReward msg;
	for(mem::set<int32_t>::iterator it=m_nSTRewardRecord.begin(); it!=m_nSTRewardRecord.end(); ++it)
	{
		msg.m_nSpecialTrainingIDs.push_back(*it);
	}

	SendMsgToClient(MGPT_SYNCSPECIALTRAININGREWARD, &msg);
}

bool LC_ServerPlayer::CheckSTRewardRecord(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return false;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckSTRewardRecord(id);
	}

	return m_nSTRewardRecord.find(id)==m_nSTRewardRecord.end() ? true : false;
}

ResultType LC_ServerPlayer::CheckSTRewardCondition(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->CheckSTRewardCondition(id);
	}

	CF_SpecialTraining::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SpecialTraining>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	bool finish = true;
	//检测任务是否已经完成/可以完成
	const Utility::UT_SIMDataList& taskConditions = pkData->_taskID;
	if(!taskConditions.empty())
	{
		for(Utility::UT_SIMDataList::const_iterator it=taskConditions.begin(); it!=taskConditions.end(); ++it)
		{
			int taskID = it->IID();
			if(!IsInFinishedTaskMap(taskID) &&!CanFinish(taskID))
			{
				finish = false;
				break;
			}
		}
	}

	if(!finish)
	{
		return RE_SPECIALTRAINING_CONDITION_NOT_ENOUGH;
	}

	//检测历练是否已经完成/可以完成
	const Utility::UT_SIMDataList& achievementConditions = pkData->_achievementID;
	for(Utility::UT_SIMDataList::const_iterator it=achievementConditions.begin(); it!=achievementConditions.end(); ++it)
	{
		int achievementID = it->IID();
		ResultType res = CheckAchievementCanFinish(achievementID);
		if(RE_ACHIEVEMENT_REWARD_HAS_RECEIVED!=res && RE_SUCCESS!=res)
		{
			finish = false;
			break;
		}
	}

	if(!finish)
	{
		return RE_SPECIALTRAINING_CONDITION_NOT_ENOUGH;
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::AddSTTaskReward(int id)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->AddSTTaskReward(id);
	}

	CF_SpecialTraining::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SpecialTraining>(id);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	//历练领奖
	//特训--埋点日志
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, SPECIALTRAIN_OPERATE, OPERATE_LOGTYPE2);
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(id);
	const Utility::UT_SIMDataList& achievementConditions = pkData->_achievementID;
	for(Utility::UT_SIMDataList::const_iterator it=achievementConditions.begin(); it!=achievementConditions.end(); ++it)
	{
		int achievementID = it->IID();
		if(!IsInFinishAchievementMap(achievementID))
		{
			ResultType res = AddAchievementReward(achievementID);
			if(RE_SUCCESS != res)
			{
				return res;
			}			
		}
	}

	//任务领奖
	const Utility::UT_SIMDataList& taskConditions = pkData->_taskID;
	if(!taskConditions.empty())
	{
		for(Utility::UT_SIMDataList::const_iterator it=taskConditions.begin(); it!=taskConditions.end(); ++it)
		{
			int taskID = it->IID();
			if(!IsInFinishedTaskMap(taskID))
			{
				ResultType res = FinishTaskOP(taskID);
				if(RE_TASK_FINISH_SUCCESS != res)
				{
					return res;
				}
			}
		}
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::UpdateSTRewardRecord(int id, const Utility::UT_SIMDataList& reward)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}

	if (!IsMainController())
	{
		return pkOwnerPlayer->UpdateSTRewardRecord(id, reward);
	}

	mem::set<int32_t>::iterator findIt = m_nSTRewardRecord.find(id);
	if(findIt != m_nSTRewardRecord.end())
	{
		return RE_FAIL;
	}

	m_nSTRewardRecord.insert(id);
	SyncSTRewardRecord();

	GetOpenAbilityAsset().OnSpecialTraining(id);

	SyncOpenAbilityInfo();
	SetDirtyFlag(DIRTY_FLAG_OPEN_ABILITY_INFO, false);
	//特训--埋点日志
	int nLogCode = LC_Helper::SerializeOperateLogCode(SYSTEM_LOGTYPE, SPECIALTRAIN_OPERATE, OPERATE_LOGTYPE2);
	vector<int> nParams;
	nParams.clear();
	nParams.push_back(id);
	//领奖
	StringType mailTitle;
	StringType mailDesc;
	return UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, reward, this, SYS_FUNC_TP_SPECIALTRAINING_REWARD, id, mailTitle, mailDesc, false,false,false,nLogCode, nParams);
}

void LC_ServerPlayer::SyncSubBData()
{
	MG_RLT_GetSubBValue rltMsg;
	rltMsg.m_nResult = RE_SUCCESS;
	const mem::map<int, CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs>& SubBGroupDataMap = CActSubordinateRewardManager::GetSingletonPtr()->GetActSubordinateRewardEntrysGroupDataMap();
	for(mem::map<int, CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs>::const_iterator it=SubBGroupDataMap.begin(); it!=SubBGroupDataMap.end(); ++it)
	{
		const CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs& dateEntryPtr = it->second;
		if( dateEntryPtr.begin() == dateEntryPtr.end())
		{
			continue;
		}

		const CF_ACTSubordinateRewardB::DataEntry* pkEntry = *(dateEntryPtr.begin());
		if(NULL == pkEntry)
		{
			continue;
		}

		int groupID = it->first;
		bool tag1 = UT_ServerHelper::CheckActivityVaild(pkEntry->_iSchedule);
		bool tag2 = UT_ServerHelper::CheckActivityVaild(pkEntry->_iFinishSchedule);
		if(!tag1 && tag2)
		{
			//上榜时间已结束，展示时间未结束
			PS_SubBValue data;
			data.m_nGroupID = groupID;
			data.m_nValue = GetSubBSendValue(groupID);
			rltMsg.m_nSubBValue.push_back(data);
		}
	}

	if(!rltMsg.m_nSubBValue.empty())
	{
		SendMsgToClient(MGPT_RLT_GETSUBBVALUE, &rltMsg);
	}	
}

void LC_ServerPlayer::GetSubBDataByType(const std::vector<int32_t>& typeVec)
{
	MG_RLT_GetSubBValue rltMsg;
	rltMsg.m_nResult = RE_FAIL;
	if(typeVec.size() > Sub_TotalType)
	{
		SendMsgToClient(MGPT_RLT_GETSUBBVALUE, &rltMsg);
		return;
	}

	const unique_id_impl& instance = GetInstance();
	rltMsg.m_nResult = RE_SUCCESS;
	for(int i=0; i<typeVec.size(); ++i)
	{
		int32_t type = typeVec[i];
		const CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs* entryPtrs = CActSubordinateRewardManager::GetSingletonPtr()->GetActSubordinateRewardEntrysByType(type);
		if(NULL == entryPtrs)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetSubBDataByType_1 not find type! type:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
				type, instance.detail(), instance.catagory(), GetUserID());
			continue;
		}

		CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs::const_iterator it = entryPtrs->begin();
		if(it == entryPtrs->end())
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetSubBDataByType_2 isEmpty! type:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
				type, instance.detail(), instance.catagory(), GetUserID());
			continue;
		}

		CF_ACTSubordinateRewardB::DataEntry* pkEntry = *it;
		if(NULL == pkEntry)
		{
			GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetSubBDataByType_3 isEmpty! type:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
				type, instance.detail(), instance.catagory(), GetUserID());
			continue;
		}

		int groupID = pkEntry->_GroupID;
		bool vaild = UT_ServerHelper::CheckActivityVaild(pkEntry->_iSchedule);

		PS_SubBValue data;
		data.m_nGroupID = groupID;
		data.m_nValue = vaild ? GetSubBValue(groupID) : GetSubBSendValue(groupID);
		rltMsg.m_nSubBValue.push_back(data);
	}

	SendMsgToClient(MGPT_RLT_GETSUBBVALUE, &rltMsg);
}

void LC_ServerPlayer::GetRuneItem(mem::set<int32_t>& runeItemID)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return;
	}

	LC_PackAsset* pkAsset = pkOwnerPlayer->GetPackAsset();
	if(NULL == pkAsset)
	{
		return;
	}
	
	//基础背包
	int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
	for (int32_t i = 0;i < iBasicPackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				runeItemID.insert(lItemTypeID);
			}
		}
	}

	//宝具背包
	mem::map<int32_t, int32_t> buddyRuneItemStarLevelInfo;
	GetAllBuddyRuneItemStarLevelData(buddyRuneItemStarLevelInfo);
	for(mem::map<int32_t, int32_t>::iterator it=buddyRuneItemStarLevelInfo.begin(); it!=buddyRuneItemStarLevelInfo.end(); ++it)
	{
		runeItemID.insert(it->first);
	}

	//仓库里的装备
	int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
	for (int32_t i = 0;i < iWarehousePackSize; ++i)
	{
		LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
		if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
		{	
			int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
			if(LC_Helper::CheckIsRune(lItemTypeID))
			{
				runeItemID.insert(lItemTypeID);
			}
		}
	}
}

void LC_ServerPlayer::UpdateSubBInfo(bool force)
{
	UpdateRankInfoToRedis(Sub_Reward_Type_Vehicle, force);
	UpdateRankInfoToRedis(Sub_Reward_Type_Wing, force);
	UpdateRankInfoToRedis(Sub_Reward_Type_Devaeye, force);

	UpdateRankInfoToRedis(Sub_Reward_Type_AllRuneItemCombatScore, force);
	UpdateRankInfoToRedis(Sub_Reward_Type_CommanderLevel, force);
	UpdateRankInfoToRedis(Sub_Reward_Type_CommanderTitle, force);

	UpdateRankInfoToRedis(Sub_Reward_Type_ControllerEquipCombatScore, force);

	for(mem::map<int32_t, BuddyInstance*>::iterator it=m_ppUsableBuddyInstance.begin(); it!=m_ppUsableBuddyInstance.end(); ++it)
	{
		BuddyInstance* pkBuddy = it->second;
		if(NULL == pkBuddy)
		{
			continue;
		}

		int buddyID = pkBuddy->GetTemplateID();
		UpdateRankInfoToRedis(Sub_Reward_Type_BuddyStarLevel, force, buddyID);
		UpdateRankInfoToRedis(Sub_Reward_Type_BuddyEquipSlotCombatScore, force, buddyID);
	}

	mem::set<int32_t> runeItemID;
	GetRuneItem(runeItemID);
	for(mem::set<int32_t>::iterator it=runeItemID.begin(); it!=runeItemID.end(); ++it)
	{
		int32_t runeId = *it;
		UpdateRankInfoToRedis(Sub_Reward_Type_RuneItemCombatScore, force, runeId);
	}
}

uint64_t LC_ServerPlayer::GetCombatEquipSlotCombatScoreByBuddys(const Utility::UT_SIMDataList& params, int param)
{
	bool tag = false;
	uint64_t result = 0;
	for(Utility::UT_SIMDataList::const_iterator it=params.begin(); it!=params.end(); ++it)
	{
		int buddyID = it->IID();
		BuddyInstance* pkBuddy = GetBuddyInstanceByID(buddyID);
		if(NULL == pkBuddy)
		{
			continue;
		}

		uint64_t value = pkBuddy->GetBuddyEquipCombatScore();
		result += value;

		if(param==buddyID && value!=0)
		{
			tag = true;
		}
	}

	if(!tag && param!=-1)
	{
		result = 0;
	}

	return result;
}

int LC_ServerPlayer::GetStarLevelByBuddys(const Utility::UT_SIMDataList& params, int param)
{
	bool tag = false;
	int result = 0;
	for(Utility::UT_SIMDataList::const_iterator it=params.begin(); it!=params.end(); ++it)
	{
		int buddyID = it->IID();
		BuddyInstance* pkBuddy = GetBuddyInstanceByID(buddyID);
		if(NULL == pkBuddy)
		{
			continue;
		}

		int value = pkBuddy->GetStarLevel();
		result += value;

		if(param==buddyID && value!=0)
		{
			tag = true;
		}
	}

	if(!tag && param!=-1)
	{
		result = 0;
	}

	return result;
}

uint64_t LC_ServerPlayer::GetRuneItemCombatScoreByItemID(const Utility::UT_SIMDataList& params, int param)
{
	bool tag = false;
	uint64_t result = 0;

	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return result;
	}

	LC_PackAsset* pkAsset = pkOwnerPlayer->GetPackAsset();
	if(NULL == pkAsset)
	{
		return result;
	}

	for(Utility::UT_SIMDataList::const_iterator it=params.begin(); it!=params.end(); ++it)
	{
		int itemID = it->IID();

		//基础背包
		int32_t iBasicPackSize = pkAsset->GetPackSize(PACK_TYPE_BASIC);
		for (int32_t i = 0;i < iBasicPackSize; ++i)
		{
			LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_BASIC, i);
			if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
			{	
				int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
				if(lItemTypeID == itemID)
				{
					uint64_t value = LC_Helper::GetRuneEquipScore(pkItemEntry);
					result += value;
					if(param==itemID && value!=0)
					{
						tag = true;
					}
					break;
				}
			}
		}

		//宝具背包
		const LC_BackPackEntry* pkItem = GetRuneDataFromBuddyRune(itemID);
		if(NULL != pkItem)
		{
			uint64_t value = LC_Helper::GetRuneEquipScore(pkItem);
			result += value;
			if(param==itemID && value!=0)
			{
				tag = true;
			}
		}

		//仓库里的装备
		int32_t iWarehousePackSize = pkAsset->GetPackSize(PACK_TYPE_WAREHOUSE);
		for (int32_t i = 0; i<iWarehousePackSize; ++i)
		{
			LC_BackPackEntry* pkItemEntry = pkAsset->GetBackPackEntry(PACK_TYPE_WAREHOUSE, i);
			if(pkItemEntry && pkItemEntry->GetBackPackValueByType(LPSFET_VALID))
			{
				int lItemTypeID = pkItemEntry->GetBackPackValueByType(LPSFET_TYPE_ID);
				if(lItemTypeID == itemID)
				{
					uint64_t value = LC_Helper::GetRuneEquipScore(pkItemEntry);
					result += value;
					if(param==itemID && value!=0)
					{
						tag = true;
					}
					break;
				}
			}
		}
	}

	if(!tag && param!=-1)
	{
		result = 0;
	}

	return result;
}

void LC_ServerPlayer::CheckUpdateSubBInfo()
{
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	const mem::map<int, uint32_t> & subBFinishTime = UT_ServerHelper::GetSubBEndTimeRef();

	mem::vector<int> finishGroupID;
	for(mem::map<int, uint32_t>::const_iterator it=subBFinishTime.begin(); it!=subBFinishTime.end(); ++it)
	{
		int groupID = it->first;
		if(currentTime>=it->second && false==IsInRankGroup(groupID))
		{
			finishGroupID.push_back(groupID);
		}
	}

	for(int i=0; i<finishGroupID.size(); ++i)
	{
		int groupID = finishGroupID[i];
		uint64_t value = GetSubBValue(groupID);
		UpdateSendSubBValue(groupID, value);
		UpdateRankGroup(groupID);
	}
}

bool LC_ServerPlayer::IsInRankGroup(int groupID)
{
	return m_nRankGroupID.find(groupID) != m_nRankGroupID.end();
}

void LC_ServerPlayer::UpdateRankGroup(int groupID)
{
	m_nRankGroupID.insert(groupID);
}

uint64_t LC_ServerPlayer::GetSubBValue(int groupID)
{
	mem::map<int, uint64_t>::iterator findIt = m_nSubBInfo.find(groupID);
	if(findIt == m_nSubBInfo.end())
	{
		return 0;
	}

	return findIt->second;
}

void LC_ServerPlayer::UpdateSubBValue(int groupID, uint64_t value)
{
	mem::map<int, uint64_t>::iterator findIt = m_nSubBInfo.find(groupID);
	if(findIt != m_nSubBInfo.end() && findIt->second>=value)
	{
		return;
	}

	m_nSubBInfo[groupID] = value;
}

uint64_t LC_ServerPlayer::GetSubBSendValue(int groupID)
{
	mem::map<int, uint64_t>::iterator findIt = m_nSendSubInfo.find(groupID);
	if(findIt == m_nSendSubInfo.end())
	{
		return 0;
	}

	return findIt->second;
}

void LC_ServerPlayer::UpdateSendSubBValue(int groupID, uint64_t value)
{
	m_nSendSubInfo[groupID] = value;
}

int8_t LC_ServerPlayer::GetMoveActionMode()
{
	return m_nMoveActionMode;
}

void LC_ServerPlayer::SetMoveActionMode( int8_t nInput )
{
	if ( nInput == m_nMoveActionMode )
		return;
	m_nMoveActionMode = nInput;
	m_dataChangeFlag.GetBroadCastFlag().SetLocation();
}

ResultType LC_ServerPlayer::GetActivityRankInfo(int type, int param, int minIndex, int maxIndex, MG_RLT_GetRankSubBInfo& msg)
{
	if(minIndex > maxIndex)
	{
		return RE_ERROR_PARAM;
	}

	CF_RankCondition::DataEntry* pkData = UT_ServerHelper::GetRankConditionPtrByType(type);
	if(NULL == pkData)
	{
		return RE_FAIL;
	}

	ResultType res = RE_FAIL;
	switch(type)
	{
	case Sub_Reward_Type_Vehicle:
	case Sub_Reward_Type_Wing:
	case Sub_Reward_Type_Devaeye:
	case Sub_Reward_Type_BuddyEquipSlotCombatScore:
	case Sub_Reward_Type_BuddyStarLevel:
	case Sub_Reward_Type_RuneItemCombatScore:
	case Sub_Reward_Type_AllRuneItemCombatScore:
	case Sub_Reward_Type_CommanderLevel:
	case Sub_Reward_Type_CommanderTitle:
	case Sub_Reward_Type_ControllerEquipCombatScore:
		{
			res = CheckSubBParam(type, param);
		}
		break;
	case Charge_Type_3:
		{
			res = CheckChargeParam(HolidayActivityType_8, param);
		}
		break;
	default:
		break;
	}

	if(RE_SUCCESS != res)
	{
		return res;
	}

	std::string valueSpace;
	UT_ServerHelper::GetRankValueNameSpace(type, param, valueSpace);
	const char* szNameSpace1 = valueSpace.c_str();

	std::string playerInfoSpace;
	UT_ServerHelper::GetRankPlayerInfoNameSpace(type, param, playerInfoSpace);
	const char* szNameSpace2 = playerInfoSpace.c_str();

	return UT_ServerHelper::GetSubBRankInfo(this, UT_ServerHelper::CheckActivityVaild(pkData->_iScheduleID), type, szNameSpace1, szNameSpace2, minIndex, maxIndex, msg);
}

void LC_ServerPlayer::UpdateRankInfoToRedis(int type, bool force, int param, int value)
{
	if(!IsMainController())
	{
		return;
	}

	CF_RankCondition::DataEntry* pkData = UT_ServerHelper::GetRankConditionPtrByType(type);
	if(NULL == pkData)
	{
		return;
	}

	switch(type)
	{
	case Sub_Reward_Type_Vehicle:
	case Sub_Reward_Type_Wing:
	case Sub_Reward_Type_Devaeye:
	case Sub_Reward_Type_BuddyEquipSlotCombatScore:
	case Sub_Reward_Type_BuddyStarLevel:
	case Sub_Reward_Type_RuneItemCombatScore:
	case Sub_Reward_Type_AllRuneItemCombatScore:
	case Sub_Reward_Type_CommanderLevel:
	case Sub_Reward_Type_CommanderTitle:
	case Sub_Reward_Type_ControllerEquipCombatScore:
		{
			UpdateSubB(type, force, param);
		}
		break;
	case Charge_Type_3:
		{
			UpdateCharge(type, param, value);
		}
		break;
	default:
		break;
	}
}

void LC_ServerPlayer::UpdateCharge(int type, int id, int value)
{
	UT_ServerHelper::DoUpdateRankInfoToRedis(this, type, id, value);
}

ResultType LC_ServerPlayer::CheckSubBParam(int type, int param)
{
	ResultType res = RE_ERROR_PARAM;
	const unique_id_impl& instance = GetInstance();
	const CActSubordinateRewardManager::ACTSubordinateRewardEntryPtrs* entryPtrs = CActSubordinateRewardManager::GetSingletonPtr()->GetActSubordinateRewardEntrysByGroupID(param);
	if(NULL == entryPtrs)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetRankSubBInfo_1 not find group! group:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			param, instance.detail(), instance.catagory(), GetUserID());
		return res;
	}

	const CF_ACTSubordinateRewardB::DataEntry* pkEntry = *entryPtrs->begin();
	if(NULL == pkEntry)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetRankSubBInfo_1 entry is full! group:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			param, instance.detail(), instance.catagory(), GetUserID());
		return res;
	}

	if(pkEntry->_iType != type)
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetRankSubBInfo_1 type error! group:%d, paramType:%d, type:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			param, type, pkEntry->_iType, instance.detail(), instance.catagory(), GetUserID());
		return res;
	}

	if(!UT_ServerHelper::CheckActivityVaild(pkEntry->_iFinishSchedule))
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "GetRankSubBInfo_3 finishSchedule not vaild! scheduleID:%d, c_cid:%d, c_citizenship:%d, c_uid:%d",
			pkEntry->_iFinishSchedule, instance.detail(), instance.catagory(), GetUserID());
		return RE_ACTIVITY_NOT_VALID;
	}

	return RE_SUCCESS;
}

ResultType LC_ServerPlayer::CheckChargeParam(int holidayType, int param)
{
	int finishScheduleID = -1;
	CF_HolidayActivitySecondary::DataEntryMapExternIterator kIt = CF_HolidayActivitySecondary::GetSingletonPtr()->GetIterator();
	for(; kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_HolidayActivitySecondary::DataEntry* pkEntry = kIt.PeekNextValuePtr();
		if(pkEntry->_iType == holidayType)
		{
			mem::vector<int> idVec;
			LC_Helper::SpliteStringInt(pkEntry->_sActivity, idVec);
			for(uint32_t i=0; i<idVec.size(); ++i)
			{
				if(idVec[i] == param)
				{
					finishScheduleID = pkEntry->_iScheduleShow;
					break;
				}
			}
		}
	}

	if(-1 == finishScheduleID)
	{
		return RE_ERROR_PARAM;
	}

	return UT_ServerHelper::CheckActivityVaild(finishScheduleID) ? RE_SUCCESS : RE_ACTIVITY_NOT_VALID;
}

int LC_ServerPlayer::TestBornQuest()
{
	static int raid_id = GetFirstRaidID();
	if (raid_id > 0)
	{
		if (NULL == this->m_kraidAssert.FindRaid(raid_id))
		{
			return raid_id;
		}
	}
	return -1;
}

int32_t LC_ServerPlayer::GetMapRaodmap()
{
	return m_MapRaodmap;
}

void LC_ServerPlayer::SetMapRaodmap(int32_t map_res_id)
{
	m_MapRaodmap = map_res_id;
	GetRaidAsset()->SetRaidStep(map_res_id);
}

int LC_ServerPlayer::OnHatredListAdd(object_id_type id, int64_t hatred, float time)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return 0;
	m_pOwnerPlayer->AddHatredToAllBuddy(id, hatred, time, m_iID);
	return 1;
}

int LC_ServerPlayer::OnHatredListRemove(object_id_type id)
{
	LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	if (m_pOwnerPlayer == NULL)
		return false;
	m_pOwnerPlayer->RemoveHatredToAllBuddy(id, m_iID);
	return true;
}

void LC_ServerPlayer::AddHatredToAllBuddy(object_id_type id, int64_t hatred, float time, object_id_type nExcludeId)
{
	for ( int i = 0;i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		if (nExcludeId && pResultPlayer->GetID() == nExcludeId)
			continue;
		pResultPlayer->GetHatredList()->AddHatredOnly(id, hatred, time);
	}
}

void LC_ServerPlayer::RemoveHatredToAllBuddy(object_id_type id, object_id_type nExcludeId)
{
	//  删除 buddy 仇恨列表
	
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		if (nExcludeId && pResultPlayer->GetID() == nExcludeId)
			continue;
		pResultPlayer->GetHatredList()->RemoveHatredOnly(id);
	}
}

void LC_ServerPlayer::SetFlyCountDownTime(float fTime)
{
	m_CloseFlyFlagTime = fTime;
	m_CloseFlyFlagBeginTime = GET_PROCESS_TIME;
}

void LC_ServerPlayer::UpdateFlyCountDown(float fCurrentTime, float fDeltaTime)
{
	if (m_CloseFlyFlagTime > 0)
	{
		float ct = GET_PROCESS_TIME;
		float elapsed = ct - m_CloseFlyFlagBeginTime;
		if (elapsed >= m_CloseFlyFlagTime)
		{
			m_CloseFlyFlagTime = 0;
			this->SetSkillFlag(SK_FLY, false);
			OnSkillFlyEnd();
		}
	}
}


void LC_ServerPlayer::OnSkillFlyEnd()
{
	//m_pOwnerPlayer->SetBuddyLocation( m_kCurrentLocation );
	//LC_ServerPlayer* m_pOwnerPlayer = GetOwnerPlayer();
	//if (m_pOwnerPlayer == NULL)
	//	return;
	//m_pOwnerPlayer->SetBuddyLocation( m_kTargetLocation );
}

void LC_ServerPlayer::SetJumpImmortalEndTime(int jumpStage, float fTime)
{
	//该机制不是很准确，player update 0.3s；
	float godTime = fTime;
	float ct = GET_PROCESS_TIME;

	if (jumpStage == ST_PLAYER_JUMP1)	//连续的一段跳、或者紧随二段跳之后的一段跳，需要判断落地时间是否可以重置
	{
		float elapsed = ct - m_LastJumpBeginTime;	//elapsed可能 < 0
		if (elapsed >= PLAYER_JUMP_END_NA_IMMORTAL_TIME)
		{
			m_LastJumpBeginTime = ct;
			m_LastJumpEndTime = ct + godTime;
		}
		//不能连续重置
	}
	else
	{
		//二、三段跳落地时间可以覆盖低阶跳落地时间，二、三段跳是不能连续重复的，只有一段跳可以
		m_LastJumpBeginTime = ct;
		m_LastJumpEndTime = ct + godTime;
	}
}

bool LC_ServerPlayer::IsJumpImmortal(void)
{
	if (this->GetSkillFlag(SK_FLY))
	{
		//DWORD ct = GET_INTEGER_TIME;
		//int elapsed = (int)((DWORD)(ct - m_LastJumpEndTime));	//elapsed可能 < 0
		//if (elapsed < 0 || elapsed >= PLAYER_JUMP_END_NA_IMMORTAL_TIME)
		//{
		//	return true;
		//}
		// 跳闪点数未用完，当前是跳闪状态
		//if (m_JumpDodgePoint > 0)
		//{
		//	m_JumpDodgePoint--;
		//	return true;
		//}
		// RGame 新需求
		return true;
	}
	return false;
}


uint32_t LC_ServerPlayer::GetLastOfflineTime()
{
	return m_iLastOfflineTime;
}

void LC_ServerPlayer::SetLastOfflineTime(uint32_t timestamp)
{ 
	m_iLastOfflineTime = timestamp;
}

LC_ActorFOVMapBase* LC_ServerPlayer::GetFOVMap()
{
	return LC_PlayerBase::GetFOVMap();
}

bool LC_ServerPlayer::GetAIControl(void)
{
	return LC_PlayerBase::GetAIControl();
}

void LC_ServerPlayer::SetAIControl(bool iscontrol)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
	{
		LC_PlayerBase::SetAIControl(iscontrol);
		return;
	}

	if (!IsMainController())
		return pOwner->SetAIControl(iscontrol);

	if (iscontrol == GetAIControl())
	{
		return;
	}
	LC_PlayerBase::SetAIControl(iscontrol);
	m_bStateMapInitFlag = false;
}

void LC_ServerPlayer::RefreshCurrentOPIndex( int32_t nIndex, bool bWithAI )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;
	if (!pOwner->GetAIControl())
	{
		_uninitStateMap();
		ClearState();
		GetHatredList()->Reset();
		return;
	}
	_initSMController( "" );
	//return;
	if (m_nIndexAsBuddy != nIndex)
	{
		return;
	}
	_initStateMap("", bWithAI);
	if ( !bWithAI )
	{
		_uninitStateMap();
		ClearState();
	}
}

void LC_ServerPlayer::GenSkillRandList()
{
	if (GetAIControl() == false)
		return;
	LC_SkillAssetData* data = GetSkillAsset()->GetSkillAssetData();
	LC_ShortcutBar* bardata = GetShortcutBar();
	LC_ActorSkillTrigger* sk =	GetSkillTrigger();
	SK_Factory* pkSkillFactory = SK_Factory::GetSingletonPtr();
	sk->Reset();
	GetActorSkillList()->Reset();
	const LC_SkillCategoryMap& kCatagoryMap = data->GetSkillCatagoryMap();

	LC_SkillCategoryMap::const_iterator cit = kCatagoryMap.find((skill_cat_type)SKILL_TYPE_SECT);

	AddNormalHandAttack(cit->second, pkSkillFactory, sk, GetCharType());
	checkSkillAssert(cit->second, pkSkillFactory, sk);
	if (bardata)
		checkShortcutBar(*bardata, pkSkillFactory, sk);
}

void LC_ServerPlayer::SyncPropellInfo(PropellInfoList& propellInfos)
{
	PropellInfoList::iterator it = propellInfos.begin();
	for (; it != propellInfos.end(); ++it)
	{
		if (it->m_uiID > m_uiPropellID)
		{
			m_uiPropellID = it->m_uiID;
		}
	}
}

ResultType LC_ServerPlayer::HandlePromoteReward(int32_t iType, int iLevel)
{
	ResultType rslt = RE_SUCCESS;
	LC_CharPromoteDataEntry* pkEntry = LC_PromoterManager::GetSingletonPtr()->GetCharPromoteDataEntry(iType, iLevel);
	do
	{
		if (NULL == pkEntry)
		{
			rslt = RE_FAIL;
			break;
		}
		attr_value_type iExp = pkEntry->GetExp(this);
		if (iExp)
		{
			AddExpWithGamePlay(iExp, SYS_FUNC_TP_PROMOTE, iType);
		}
		int iCash = pkEntry->GetCash(this);
		if (iCash)
		{
			AddCash(iCash, CT_UNBIND_CASH, SYS_FUNC_TP_PROMOTE, iType);
		}
		attr_value_type iSp = pkEntry->GetSP(this);
		if (iSp)
		{
			AddSkillLevelupPoints(iSp, SYS_FUNC_TP_PROMOTE, iType);
		}
		if (!pkEntry->_kPromoteItems.empty())
		{
			UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkEntry->_kPromoteItems, this, SYS_FUNC_TP_PROMOTE, iType, pkEntry->_sMailTitle, pkEntry->_sMailDesc);
		}
	}while (0);
	return rslt;
}

LC_ActorAttributeMap* LC_ServerPlayer::GetAttributeMap()
{
	//LC_ActorAttributeMap* pResult = &m_kAttributeMap;
	//return pResult;
	LC_ActorAttributeMap* pResult = NULL;
	if (m_pAssignedBuddyInstance == NULL)
		return LC_PlayerBase::GetAttributeMap();

	pResult = m_pAssignedBuddyInstance->GetNewFinalAttributeMap();
	return pResult;
}


LC_ActorAttributeMap* LC_ServerPlayer::GetNewFinalAttributeMap()
{
	if (NULL == m_pAssignedBuddyInstance)
		return NULL;
	return m_pAssignedBuddyInstance->GetNewFinalAttributeMap();
}

LC_ActorAttributeMap* LC_ServerPlayer::GetFinalAttributeMap()
{
	LC_ActorAttributeMap* pResult = NULL;
	if (m_pAssignedBuddyInstance == NULL)
		return LC_PlayerBase::GetAttributeMap();

	pResult = m_pAssignedBuddyInstance->GetFinalAttributeMap();
	return pResult;
}

void LC_ServerPlayer::GetPlayerDetailInfo(uint64_t targetPlayerID, uint32_t systemType)
{
	MG_RESP_GetPlayerInfo rltMsg;
	rltMsg.m_SystemType = systemType;
	rltMsg.m_CharID = targetPlayerID;
	static LC_ServerPlayerManager* pkPlayManager = SERVER_GET_PLAYER_MANAGER();
	LC_ServerPlayer* pkDestPlayer = (LC_ServerPlayer*)pkPlayManager->FindPlayer(targetPlayerID);
	if(NULL != pkDestPlayer)
	{
		pkDestPlayer->FillPlayerDetailInfo(rltMsg.m_nUserInfo);
		SendMsgToClient(MGPT_RESP_PLAYER_DETAIL, &rltMsg);
	}
	else
	{
		MG_GG_Req_PlayerPBDetail msg;
		msg.m_SystemType = systemType;
		msg.m_CharID = targetPlayerID;
		SendMsgToGameDB(MGPT_GL_REQ_PLAYER_DETAIL, &msg, GetInstance(), GetInstance());
	}
}

void LC_ServerPlayer::FillPlayerDetailInfo(PS_User_Info& userData)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return;
		return pOwner->FillPlayerDetailInfo(userData);
	}

	userData.m_CharID = GetInstance();
	userData.m_sCharName = TPSTR2STDSTR(GetOwnerCharName());
	userData.m_nLevel = GetLevel();
	userData.m_sGuildName = TPSTR2STDSTR(GetGuildName());
	userData.m_nBornType = GetProfilePictureID();
	userData.m_nControllerCombatScore = GetControllerCombatScore();
	userData.m_nCommanderTitleID = GetCommanderTitle();
	userData.m_nCommanderTitleFrameID = GetCurrentCommanderTitleFrameID();
	FillAttrMap(userData.m_nControllerAttrMap, GetCommanderAttrMgr().GetCommanderAllAttributeMap());
	FillAttrMap(userData.m_nControllerCoreAttrMap, GetShowCoreAttrMap());
	GetCommandEquipPack().GetControllerEquipSlotlnfo(userData.m_nControllerEquipSlotItemInfo);
	GetActivateBuddyIDs(userData.m_nActivateBuddyID); 

	//激活的buddy的战斗力
	mem::vector<BuddyInstance*> vecAllBuddys;
	GetAllBuddyInstnace(vecAllBuddys);
	for(int i=0; i<vecAllBuddys.size(); ++i)
	{
		BuddyInstance* pkBuddy = vecAllBuddys[i];
		if(NULL != pkBuddy)
		{
			uint64_t buddyCombatScore = pkBuddy->GetBuddyAttrMgr().GetBuddyCombatScoreByType(BCST_FinalBuddy);
			userData.m_nBuddyCombatScore.insert(std::make_pair(pkBuddy->GetTemplateID(), buddyCombatScore));
		}		
	}

	 //buddy装备和宝具数据
	FillPlayerRuneAndEquipInfoMap(userData.m_BuddyInfo);

	//进阶线皮肤数据
	const LC_SubUpgradeDataMap& subMap = GetSubordinateAsset().GetSubDataMap();
	for (LC_SubUpgradeDataMap::const_iterator it = subMap.begin(); it != subMap.end(); ++it)
	{
		LC_SubUpgradeData::TransformMap trans = it->second.GetTransformMap();

		PS_User_Sub_Info subInfo;
		subInfo.m_nSubType = it->first;
		for(LC_SubUpgradeData::TransformMap::iterator kIt=trans.begin(); kIt!=trans.end(); ++kIt)
		{
			subInfo.m_nSubTransform.push_back(kIt->first);
		}
		userData.m_nSubInfo.push_back(subInfo);
	}

	//出战的petID
	userData.m_nActivatePetID = GetEnabledPetInstanceResId();

	//宠物数据
	int nResult = false;
	const mem::map<int16_t, PetInstance*>& pkPetMap = GetPetRawData(nResult);
	for(mem::map<int16_t, PetInstance*>::const_iterator it=pkPetMap.begin(); it!=pkPetMap.end(); ++it)
	{
		PetInstance* pkPet = it->second;
		if(NULL != pkPet)
		{
			PS_User_Pet_Info petInfo;
			petInfo.m_nPetID =pkPet->GetTemplateId();
			petInfo.m_nPetStarLevel = pkPet->GetStarLevel();
			userData.m_nPetInfo.push_back(petInfo);
		}
	}
}


void LC_ServerPlayer::FillPlayerRuneAndEquipInfoMap(std::map<int, PS_Buddy_Info_BuddyCS>& info)
{
	info.clear();
	mem::vector<BuddyInstance*> vecAllBuddys;
	GetAllBuddyInstnace(vecAllBuddys);
	for (int i = 0; i < vecAllBuddys.size(); i++)
	{
		BuddyInstance* pkBuddy = vecAllBuddys[i];
		if (pkBuddy != NULL)
		{
			PS_Buddy_Info_BuddyCS data;
			pkBuddy->FillBuddyCSInfo(data);

			info.insert(std::make_pair(pkBuddy->GetTemplateID(), data));
		}
	}
}

void	LC_ServerPlayer::FillPlayerRuneAndEquipInfoVector(std::vector<PS_Buddy_Info_BuddyCS>& data)
{
	mem::vector<BuddyInstance*> vecAllBuddys;
	GetAllBuddyInstnace(vecAllBuddys);

	data.clear();
	data.reserve(vecAllBuddys.size());

	for (int i = 0; i < vecAllBuddys.size(); i++)
	{
		BuddyInstance* pkBuddy = vecAllBuddys[i];
		if (pkBuddy != NULL)
		{
			PS_Buddy_Info_BuddyCS info;
			pkBuddy->FillBuddyCSInfo(info);
			data.push_back(info);
		}
	}
}

// 某张地图 防守/进攻 所有队伍信息
void LC_ServerPlayer::FillSingleShowInfoByMapId(SingleShowInfo & info,int mapId,uint32_t schemeType )
{
	LC_RankManager* rank_manager=SERVER_GET_RANK_MANAGER();
	rank_manager->FillRankPlayerBaseData(this, info.ControllerBase);

	mem::vector<uint32_t> teamIdVec;
	GetBuddySchemeMgr().GetMapSchemeGroupData(this, mapId, schemeType, teamIdVec);
	if(teamIdVec.empty())
	{
		return;
	}
	for(int i=0; i<teamIdVec.size(); ++i)
	{
		PS_SchemeBuddyData data;
		FillPS_SchemeBuddyDataByMapId(data, mapId, schemeType, teamIdVec[i]);
		info.m_nAllTeamData.m_vSchemeData.push_back(data);
	}
}

// 某张地图 防守/进攻 单个队伍信息
void LC_ServerPlayer::FillPS_SchemeBuddyDataByMapId(PS_SchemeBuddyData & info,int mapId,uint32_t schemeType,int teamId)
{
	info.m_nSchemeGroupID = teamId;
	mem::vector<int> buddyVec;
	GetBuddySchemeMgr().GetBuddySchemeData(this, mapId, teamId, schemeType, buddyVec);
	for(int i=0; i<buddyVec.size(); ++i)
	{
		PS_Buddy_Info_BuddyCS buddyData;
		BuddyInstance* pkBuddy = GetBuddyInstanceByID(buddyVec[i]);
		if(NULL != pkBuddy)
		{
			pkBuddy->FillBuddyCSInfo(buddyData);
			info.m_nBuddyData.push_back(buddyData);
		}
	}
}




void LC_ServerPlayer::GetOtherOfflineInfo(OfflinePlayerFromDBType eType, uint64_t uCharId)
{
	//先查询下是否在线， 不在线，再去数据库拿数据
	LC_ServerPlayerManager* pkServerPlayerManager = SERVER_GET_PLAYER_MANAGER();
	LC_ServerPlayer* pkTargetPlayer = (LC_ServerPlayer*)(pkServerPlayerManager->FindPlayer(uCharId));
	if(pkTargetPlayer)
	{
		User_Pk_Show_Info targetInfo ;
		pkTargetPlayer->FillUserInfo(targetInfo);
		NotifyPkInfo(targetInfo);
		return;
	}
	else
	{
		//
		std::vector<uint64_t> vecId;
		vecId.push_back(uCharId);
		UT_ServerHelper::ReqPlayerOfflineToDb(eType,vecId,0,0,0, m_dwUserID, GetInstance());
	}
}

void LC_ServerPlayer::FillUserInfo(User_Pk_Show_Info &UserInfo)
{
	UserInfo.m_CharID = GetInstance();
	UserInfo.m_sCharName  = GetOwnerCharName().c_str();
	UserInfo.m_nLevel  = GetLevel();
	UserInfo.m_nCommanderTitleID  = GetCommanderTitle();
	UserInfo.m_nCommanderTitleFrameID  = GetCurrentCommanderTitleFrameID();
	UserInfo.m_nPictureID  = GetProfilePictureID();
	//UserInfo.m_kUserAllCombatScoreMap.insert(m_kCombatScoreMap.begin(), m_kCombatScoreMap.end());

}
void LC_ServerPlayer::NotifyPkInfo(User_Pk_Show_Info &m_nUserInfo)
{
		//
	MG_RLT_PlayerPkInfo notifyMsg;
	notifyMsg.m_nOtherInfo.m_CharID  = m_nUserInfo.m_CharID;
	notifyMsg.m_nOtherInfo.m_sCharName  = m_nUserInfo.m_sCharName;
	notifyMsg.m_nOtherInfo.m_nLevel  = m_nUserInfo.m_nLevel;
	notifyMsg.m_nOtherInfo.m_nCommanderTitleID  = m_nUserInfo.m_nCommanderTitleID;
	notifyMsg.m_nOtherInfo.m_nCommanderTitleFrameID  = m_nUserInfo.m_nCommanderTitleFrameID;
	notifyMsg.m_nOtherInfo.m_nPictureID  = m_nUserInfo.m_nPictureID;
	notifyMsg.m_nOtherInfo.m_kUserAllCombatScoreMap.insert(m_nUserInfo.m_kUserAllCombatScoreMap.begin(), m_nUserInfo.m_kUserAllCombatScoreMap.end());

	//
	FillUserInfo(notifyMsg.m_nMyInfo);
	SendMsgToClient(MGPT_RLT_PLAYER_PK_INFO, &notifyMsg);
}



bool LC_ServerPlayer::GetLotteryStat()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return 0;

	if (!IsMainController())
	{
		return pOwner->GetLotteryStat();
	}

	return m_bLotteryStat;
}

void LC_ServerPlayer::SetLotteryStat( bool bFlag )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return;

	if (!IsMainController())
	{
		return pOwner->SetLotteryStat(bFlag);
	}

	m_bLotteryStat = bFlag;
}

void LC_ServerPlayer::RecoverBuddyListData()
{
	for ( int i = 0; i < m_ppActivateBuddyTemplateId.size(); i++ )
	{
		if ( m_ppActivateBuddyTemplateId[i] == INVALID_ACTOR_ID )
			continue;
		mem::map<int32_t, SingleBuddyData>::iterator it = m_ppUsableBuddyData.find(m_ppActivateBuddyTemplateId[i]);
		if (it != m_ppUsableBuddyData.end())
		{
			if ( it->second.bUnlock == false)
				it->second.bUnlock = true;
		}
		else
		{
			SingleBuddyData data;
			data.bUnlock = true;
			data.nLevel = 1;//
			data.nBuddyTemplateId = m_ppActivateBuddyTemplateId[i];
			m_ppUsableBuddyData.insert( std::make_pair( data.nBuddyTemplateId, data ) );
			
		}
	}
}

void LC_ServerPlayer::PostIncLotteryCounter()
{

}

bool LC_ServerPlayer::CheckInitGame()
{
	return m_bInitGame;
}
void LC_ServerPlayer::SetInitGame(bool bState)
{
	m_bInitGame = bState;
}

void LC_ServerPlayer::SetAllInitGame(bool bState)
{
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		pResultPlayer->SetInitGame(bState);
	}
}

uint32_t LC_ServerPlayer::GetLotteryTotalCount()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner)
		return 0;
	if (!IsMainController())
		return pOwner->GetLotteryTotalCount();
	return m_Lottery.GetLotteryTotalNum(this);
}

void LC_ServerPlayer::AddAttributePlus(int32_t iAttributeType, int32_t iVal, int32_t iPercent)
{
	
}

void	LC_ServerPlayer::_updateMuhunAvatar(int iMuhunLevel)
{
	//老的有没有丢失
	if (m_iMuhunNPCID > 0)
	{
		LC_LogicObject* pkNPC = this->GetMap()->FindObject(m_iMuhunNPCID);
		if (pkNPC == NULL)
		{
			this->_clearMuhunAvatar();
		}
	}
	if (m_lastMuhunLevel == iMuhunLevel)
	{
		return;
	}
	//删除老的
	if (m_iMuhunNPCID > 0)
	{
		this->_clearMuhunAvatar();
	}
	//换上新的
	if (iMuhunLevel > 0)
	{
		int iCharType = LC_Helper::GetMuhunCharTypeID(iMuhunLevel);
		LC_SpawnManagerBase* pkSpawnManager = SERVER_GET_SPAWN_MANAGER();
		object_id_type iNPCID = pkSpawnManager->CreateNPCInWorld(this->GetMap(), this->GetCurrentLocation(), iCharType, 0);
		LC_ServerNPCManager* pkNPCManager = SERVER_GET_NPC_MANAGER();
		LC_NPCBase* pkNPC = pkNPCManager->FindNPC(iNPCID);
		if (NULL == pkNPC)
		{
			return;
		}
		pkNPC->SetSummonOwnerID(this->GetID());
		pkNPC->SetFollowedTargetID(this->GetID());
		//不能设置SetFactionID，孙尚说
		m_iMuhunNPCID = iNPCID;
	}
	m_lastMuhunLevel = iMuhunLevel;	//有可能因为创建npc失败而未设置，导致_updateMuhunAvatar不停调用，不停尝试创建
}

void	LC_ServerPlayer::_clearMuhunAvatar(void)
{
	LC_ServerNPCManager* pkNPCManager = SERVER_GET_NPC_MANAGER();
	LC_NPCBase* pkNPC = pkNPCManager->FindNPC(m_iMuhunNPCID);
	if (pkNPC != NULL)
	{
		pkNPC->SetDead(true);
	}
	m_lastMuhunLevel = 0;
	m_iMuhunNPCID = 0;
}

bool LC_ServerPlayer::GetSevenDayTrailFlag()
{
	return m_nSevenDayTrailFlag;
}

void LC_ServerPlayer::SetSevenDayTrailFlagInvalid()
{
	m_nSevenDayTrailFlag = false;
}

void LC_ServerPlayer::CheckSevenDayTrialFinished()
{
	uint32_t endTime = GetSevenDayEndTime2();
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	bool SevenDayTrialFlag = GetSevenDayTrailFlag();
	if(endTime!=0 && currentTime>=endTime && SevenDayTrialFlag)
	{
		//活动已经结束，将玩家的试炼勋章清零
		//ResetCash(CT_TRIAL);

		//活动结束，将玩家未领取的奖励发给玩家
		SendSevenDayReward();
		SetSevenDayTrailFlagInvalid();
	}
}

void LC_ServerPlayer::SendSevenDayReward()
{
	Utility::UT_SIMDataList Itemlist;
	GetAchievementAsset().SendSevenDayReward(Itemlist);
	UT_ServerHelper::SendMailToPlayer(GetInstance(), "71", "72", Itemlist);
}

void LC_ServerPlayer::CheckInvestmentsFinished()
{
	uint32_t currentTime = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	CF_InvestmentPlan::DataEntryMapExternIterator kIter = CF_InvestmentPlan::GetSingletonPtr()->GetIterator();
	for(; kIter.HasMoreElements(); kIter.MoveNext())
	{
		CF_InvestmentPlan::DataEntry* pkData = kIter.PeekNextValuePtr();
		int type = pkData->_iType;
		int scheduleID = pkData->_iSchedule;

		int endTime = UT_ServerHelper::GetInvestmentEndTime(scheduleID);

		LC_CommonStatEntry* pkCmnStatEntry = GetCommonStatAsset().GetCommonStatEntry(type);
		if(pkCmnStatEntry!=NULL && pkCmnStatEntry->IsEnabled())
		{
			if(endTime!=0 && currentTime>=endTime)
			{
				//活动已经结束，给玩家发奖
				SendInvestmentReward(pkData);
				pkCmnStatEntry->SetEnabled(false);
			}
		}
	}
}

void LC_ServerPlayer::SendInvestmentReward(CSVFile::CF_InvestmentPlan::DataEntry* pkData)
{
	Utility::UT_SIMDataList Itemlist;
	GetAchievementAsset().SendInvestmentReward(pkData, Itemlist);
	UT_ServerHelper::SendMailToPlayer(GetInstance(), "170;", "171;", Itemlist);
}

void on_get_gm_info(object_id_type playerid, int32_t err, const std::string& gm_info)
{
	if (RE_SUCCESS != err)
	{
		GfxWriteFmtLog(LOG_WARNING_FILELINE, LOG_SWITCH_WARNING, "[%u]get gm info failed!", playerid);
		return;
	}

	LC_ServerPlayer* pkPlayer = (LC_ServerPlayer*)(SERVER_GET_PLAYER_MANAGER())->FindPlayer(playerid);
	if (NULL == pkPlayer)
	{
		GfxWriteFmtLog(LOG_WARNING_FILELINE, LOG_SWITCH_WARNING, "[%u]get gm info player lost!", playerid);
		return;
	}

	redis_define::gm_char_info kgmchar;
	if (!kgmchar.ParseFromString(gm_info))
	{
		GfxWriteFmtLog(LOG_WARNING_FILELINE, LOG_SWITCH_WARNING, "[%u]get gm info parse failed!", playerid);
		return;
	}
	pkPlayer->SetGMInfo("", kgmchar.priority());
}

void LC_ServerPlayer::PullGMInfo(void)
{
	//获取GM信息
	ResultType rslt = RE_SUCCESS;
	Utility::Redis_Channel& channel = GetGameServerApp()->GetRedisChannel();
	boost::function<void (int32_t, const std::string&)> _cb = boost::bind(on_get_gm_info, GetID(), _1, _2);
	std::string sKey = GetGameServerApp()->GetRedisServerPredix() + UT_REDIS_KEY_GM_CHARS;
	std::string sCharID = boost::lexical_cast<std::string>(GetInstance());
	ASYNC_REDIS_REQUEST(rslt, channel, &redispp::Connection::hget, _cb, sKey, sCharID);
}

uint16_t LC_ServerPlayer::GetPlayerPlatformType()
{
	return GetPlayerPlatformInfoAsset().GetPlatformType(); 
}

uint16_t LC_ServerPlayer::GetPlayerLoginPlatformPage()
{
	return GetPlayerPlatformInfoAsset().GetLoginPlatformPage(); 
}

bool LC_ServerPlayer::SetPlatformVipInfo(const std::string& info)
{
	if (info.empty())
	{
		return true;
	}
	std::string error_string;
	platform_vip_info pf_info;
	if (!boost::ajson::load_from_buff(pf_info, info.c_str(), error_string))
	{
		const unique_id_impl& instance = GetInstance();
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "bad player platform info c_cid:%d, c_citizenship:%d, c_uid:%d, err:%s",
			instance.detail(), instance.catagory(), GetUserID(), error_string.c_str());
		return false;
	}
	m_platformvipinfo = pf_info;
	UpdateDirtyFlag(DIRTY_FLAG_PROPERTY);
	m_dataChangeFlag.GetBroadCastFlag().SetProperty();

	return true;
}

void LC_ServerPlayer::SetPlatformVipInfoTest(platform_vip_info& info)
{
	m_platformvipinfo = info;
	UpdateDirtyFlag(DIRTY_FLAG_PROPERTY);
	m_dataChangeFlag.GetBroadCastFlag().SetProperty();
}

bool LC_ServerPlayer::OpenFDeposit(bool bTest)
{
	uint32_t FDTime = 0;
	LC_VIPAsset& kVIPAsset = GetVIPAsset();
	uint32_t uiPreLvl = kVIPAsset.GetFDepositLevel();
	uint32_t uiFDLvl = kVIPAsset.OnOneRealtedFDeposit(FDTime);

	kVIPAsset.SetTodayChargeFlag(true);

	if (uiPreLvl==0 && uiFDLvl==1)
	{
		GetOpenAbilityAsset().OnFDeposit();
		UpdateFirstChargeTime();
		//首充会激活的功能(神选魔盒)
		NotifyFD();
	}
	
	return true;
}

void LC_ServerPlayer::NotifyFD()
{
	CheckRefreshFDDayCron();
}

void LC_ServerPlayer::FillAttrMap(std::map<int32_t, int64_t>& attrMap, LC_ActorAttributeMap* map)
{
	if(NULL==map)
	{
		return;
	}
	map->RecomputeAll();

	for(int i = 0 ; i < ATT_MAX_COUNT ; ++i)
	{
		attr_value_type value = map->GetAttribute(i);
		attrMap.insert(std::make_pair(i, value));
	}
}

void LC_ServerPlayer::ForceSaveSystemData()
{
	if(!IsMainController())
	{
		return;
	}

	if(false == GetAttackFlag())
	{
		return;
	}

	//强制写公会秘境/行会boss-异种降临数据
	ForceUpdateDamageData(false);

	//强制写异种侵袭/幻境试炼数据
	SetRankTransferFailed(GetMapResID());
}

void LC_ServerPlayer::AccumulateRunTime(float fCurrentTime)
{
	float deltaT = fCurrentTime - m_fRunStateTick;
	if (m_fRunStateAccumulator > 0)
		m_fRunStateAccumulator -= deltaT;
	m_fRunStateTick = fCurrentTime;
}

void LC_ServerPlayer::SetSyncPlayerMove(bool val)
{
	if (m_syncPlayerMove != val)
	{
		m_syncPlayerMove = val;
		m_RunSpeedUpDirty = true;
	}
}

void LC_ServerPlayer::_updateCrossServerCheck(uint32_t nTime)
{
	if(nTime > m_tCrossServerCheck && nTime - m_tCrossServerCheck >= 60 )
	{
		m_tCrossServerCheck = nTime;
		if(m_nCrossServerType == CrossRealmType_Alliance)
		{
			//更新上报状态
			SendMsgToSociety(MGPT_SS_FALLIANCE_ENTER_CROSS_SYNC, NULL, m_dwUserID, m_Instance, GetCitizenship());
		}
	}
}

void LC_ServerPlayer::_autoRecharge()
{
	CF_AutoRecharge* pkAutoRecharge = CF_AutoRecharge::GetSingletonPtr();
	
	CF_AutoRecharge::MultiEntry pkMultiEntry = pkAutoRecharge->GetMultiData(); 
	CF_AutoRecharge::MultiEntry::Map_sUserNameIt it =
		pkMultiEntry._sUserName.find(m_kUserName);
	if (it == pkMultiEntry._sUserName.end())
	{
		return;
	}
	if (it->second->_lServerID != GetCitizenship())
	{
		return;
	}

	LC_PackEntryFactory* pkPackEntryFactory = LC_PackEntryFactory::GetSingletonPtr();
	if (NULL == pkPackEntryFactory)
	{
		return;
	}

	LC_BackPackEntryList kEntryList;
	for (Utility::UT_SIMDataList::const_iterator cit = it->second->_kReturnGifts.begin();
		 cit != it->second->_kReturnGifts.end(); ++cit)
	{
		if (pkPackEntryFactory->CreateItemEntry(*cit, CIET_NONE, kEntryList))
		{
			GfxWriteFmtLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO,
						"mail item to", GetInstance(), cit->ToString().c_str());
		}
	}

	UT_ServerHelper::SendToMail(it->second->_sMailTitle, it->second->_sMailContent,
								GetInstance(), GetOwnerCharName(), 0, kEntryList, "3");
	m_userGiftReturn = 1;
}

void LC_ServerPlayer::SetLCLockedID(object_id_type sID)
{
	m_lastLcLockedID = sID;
}

int LC_ServerPlayer::OnBuddyDead( object_id_type nPlayerId, int32_t nBuddyId, bool bSyncOnly )
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return false;
		return pOwner->OnBuddyDead( nPlayerId,nBuddyId,bSyncOnly );
	}
	if (GetAliveBuddyCount() <= 0)
	{
		// should write a log.
		return false;
	}
	if (!bSyncOnly)
		SubAliveBuddyCount();

	SetBuddyAutoRespawnTimerById( nBuddyId );
	return true;
}

int LC_ServerPlayer::OnBuddyRelive( object_id_type nPlayerId )
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return false;
		return pOwner->OnBuddyRelive( nPlayerId );
	}
	AddAliveBuddyCount();
	return true;
}


void LC_ServerPlayer::OnOwnerDead(object_id_type nPlayerId, int32_t nCurRespawnTime, int32_t nSafeRespawnTime)
{
	if (!CheckOwnerDead())
		return;

	//指挥官死亡的时候，转盘抽奖失败
	GetRotaryTableAsset().SetRotaryTableCDStartTime(0);

	ResetBuddyAutoRespawnTimer();

	LC_GameEventManager* pkEventManager = LC_GameEventManager::GetSingletonPtr();
	{
		LC_GameEvent* pkGameEvent = pkEventManager->AllocGameEvent();
		if (NULL != pkGameEvent)
		{
			pkGameEvent->SetEventType(GLET_CONTROLLER_DEAD);
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_PLAYER_ID,	m_lAttackerID);
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_CHAR_TYPE_ID, GetCharType());
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_ID,			GetID());
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_MAP_ID,		GetMapLogicID());
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_POS_X,		GetCurrentLocation().x);
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_POS_Y,		GetCurrentLocation().y);
			pkGameEvent->SetEventParam(EP_KILL_PLAYER_POS_Z,		GetCurrentLocation().z);
			pkGameEvent->SetEventParam(EVENT_EXTEND_PARAM_5,		GetCharType());
			pkEventManager->InsertGameEvent(pkGameEvent);
		}
	}

	//在公会秘境地图中死亡的时候，要刷新伤害统计数据
	if(GetMapLogicType() == MT_GUILD_MAP)
	{
		ForceUpdateDamageData(true);
	}

	LC_ServerWorldManager* pkWorldManager = SERVER_GET_WORLD_MANAGER();
	LC_ServerMapLogic_Place* ptr = pkWorldManager->GetMapLogic(GetMapLogicID());
	if(NULL!=ptr  && ptr->GetAllRealPlayerSize()==1)
	{
		ptr->SetControllerState(true);
	}

	//复活界面
	CF_TranscriptionRule::DataEntry* pkRuleData = SafeGetCSVFileDataEntryPtr<CF_TranscriptionRule>(GetMapResID());
	if(NULL!=pkRuleData && !pkRuleData->_iIsAllDeadFailed)
	{
		MG_RLT_UserDead rltMsg;
		rltMsg.m_CurRespawnTime = nCurRespawnTime;
		rltMsg.m_SafeRespawnTime = nSafeRespawnTime;
		SendMsgToClient(MGPT_RLT_USER_DEAD, &rltMsg);
	}
}

void LC_ServerPlayer::SendChallengeResToClient(ResultType iResult,uint64_t beChallengeCharID,GameLogic::SOLO_DULE_TYPE iChallengeType)
{
	MG_FAILED_Challenge sendmsg;
	sendmsg.m_beChallengeCharID = beChallengeCharID;
	sendmsg.m_iResult = iResult;
	sendmsg.m_ChallengeType = iChallengeType;
	SendMsgToClient(MGPT_RLT_RANK_CHALLENGE, &sendmsg);
}

object_id_type LC_ServerPlayer::GetOwnerObjectID()
{
	return m_nOwnerPlayerId;
}

int LC_ServerPlayer::GetAliveBuddySize()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return 0;

	if (!IsMainController())
		return pOwner->GetAliveBuddySize();

	return m_nAliveBuddyCount;
}

bool LC_ServerPlayer::CheckOwnerDead()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return false;

	if (!IsMainController())
		return pOwner->CheckOwnerDead();
	if (GetAliveBuddyCount() == 0)
		return true;
	else
		return false;
}

int32_t LC_ServerPlayer::GetGameStoryEnterTimes(int storyID)
{
	LC_GameStoryAsset& kStoryAsset = GetGameStoryAsset();
	GameStoryEntry *pkStoryEntry = kStoryAsset.GetGameStoryEntry(storyID);
	if(NULL == pkStoryEntry)
	{
		return 0;
	}

	LC_StatType eStatType = LC_ST_TP_NA;
	pkStoryEntry->ResolveCheckType(eStatType);
	return pkStoryEntry->CountTotalMapEnteredTimes(eStatType);
}

int32_t LC_ServerPlayer::GetGameStoryFinishTimes(int storyID)
{
	LC_GameStoryAsset& kStoryAsset = GetGameStoryAsset();
	GameStoryEntry *pkStoryEntry = kStoryAsset.GetGameStoryEntry(storyID);
	if(NULL == pkStoryEntry)
	{
		return 0;
	}

	LC_StatType eStatType = LC_ST_TP_NA;
	pkStoryEntry->ResolveCheckType(eStatType);
	return pkStoryEntry->CountTotalMapFinishedTimes(eStatType);
}

LC_ResourceRecord& LC_ServerPlayer::GetOssResourceCache(int32_t iTypeID, int32_t iSrcType)
{
	int64_t iUniqueID = SpliceTwoInt32(iTypeID, iSrcType);
	LC_ResourceRecord& kRecord = m_kOssResourceCache[iUniqueID];
	kRecord.SetTypeID(iTypeID);
	kRecord.SetSrcType(iSrcType);
	return kRecord;
}

LC_SkillAsset* LC_ServerPlayer::GetSkillAsset()
{
	return m_pDynamicSkillAsset;
}

LC_SkillAsset* LC_ServerPlayer::GetControllerSkillAsset()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_PlayerBase::GetControllerSkillAsset();

	if (!IsMainController())
		return pOwner->GetControllerSkillAsset();

	return LC_PlayerBase::GetControllerSkillAsset();
}

LC_ItemCoolDownMapBase* LC_ServerPlayer::GetControllerItemCoolDownMap()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return LC_PlayerBase::GetControllerItemCoolDownMap();

	if (!IsMainController())
		return pOwner->GetControllerItemCoolDownMap();

	return LC_PlayerBase::GetControllerItemCoolDownMap();
}

void LC_ServerPlayer::AddOssResourceCache(int32_t iTypeID, int32_t iSrcType, uint64_t iCount)
{
	int64_t iUniqueID = SpliceTwoInt32(iTypeID, iSrcType);
	mem::map<int64_t, LC_ResourceRecord>::iterator it = m_kOssResourceCache.find(iUniqueID);
	if (it == m_kOssResourceCache.end())
	{
		LC_ResourceRecord record(iTypeID, iSrcType, iCount);
		m_kOssResourceCache[record.GetUniqueID()] = record;
	}
	else
	{
		it->second.AddCount(iCount);
	}
}

void LC_ServerPlayer::NotifyEndlessTowerGameEvent(LC_GameEvent* pkEvent)
{
	MG_Notify_ChallengeEndLessTowerState msg;
	msg.m_bSuccess = pkEvent->GetEventParam(ET_STATE);
	msg.m_iStoryID = pkEvent->GetEventParam(ET_STORY_ID);
	msg.m_iStat = pkEvent->GetEventParam(ET_STORY_STAT);

	SendMsgToClient(MGPT_NOTIFY_CHALLENGE_ENDLESSTOWERSTATE, &msg);
}

void LC_ServerPlayer::ResetOssResourceCache(int32_t iTypeID, int32_t iSrcType)
{
	int64_t iUniqueID = SpliceTwoInt32(iTypeID, iSrcType);
	mem::map<int64_t, LC_ResourceRecord>::iterator it = m_kOssResourceCache.find(iUniqueID);
	if (it == m_kOssResourceCache.end())
	{
		return;
	}
	it->second.ResetCount();
}

void LC_ServerPlayer::DoLimitReward(int activityType, int32_t iCatagory, int32_t iSchedule, int32_t iKey, GameLogic::LC_RewardItemsExtend& rkExtend, int count)
{
	const unique_id_impl& instance = GetInstance();
	static Activity::ACT_ScheduleDataManager* pkDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	Activity::ACT_ScheduleDataActivityBase* pkActivity = pkDataMgr->GetActivity(activityType);
	if(NULL != pkActivity)
	{
		pkActivity->DrawLimitReward(this, iCatagory, iSchedule, iKey, rkExtend, count);
	}
	else
	{
		GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "DoLimitReward activityType:%d, iCatagory:%d, iSchedule:%d, iKey:%d, count:%d, c_cid:%d, c_citizenship:%d, c_uid:%d", 
			activityType, iCatagory, iSchedule, iKey, count, instance.detail(), instance.catagory(), GetUserID());
	}
}

void LC_ServerPlayer::AddRechargeRecord(int64_t iVal)
{
	CF_RechargeReturnConfig* pkRechargeConfig = CF_RechargeReturnConfig::GetSingletonPtr();
	CF_RechargeReturnConfig::MultiEntry pkConfigMultiEntry = pkRechargeConfig->GetMultiData();
	CF_RechargeReturnConfig::MultiEntry::Map_iPlatformIDIt configIt =
		pkConfigMultiEntry._iPlatformID.find(GetPlayerPlatformType());
	if (configIt == pkConfigMultiEntry._iPlatformID.end())
	{
		configIt = pkConfigMultiEntry._iPlatformID.find(YYP_NA);
		if (configIt == pkConfigMultiEntry._iPlatformID.end())
		{
			return;
		}
	}
	if (configIt->second->_iOpen <= 0)
	{
		return;
	}
	uint32_t timestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if (timestamp < configIt->second->_iStartTime || timestamp > configIt->second->_iEndTime)
	{
		return;
	}
	m_kRechargeRecord.m_iRecharge += iVal;
	m_kRechargeRecord.m_iLastUpdateTime = timestamp;
}

void LC_ServerPlayer::SettleRechargeReturn(int32_t iPlatform)
{
	if (m_kRechargeRecord.m_iRecharge <= 0)
	{
		return;
	}
	CF_RechargeReturnConfig* pkRechargeConfig = CF_RechargeReturnConfig::GetSingletonPtr();

	CF_RechargeReturnConfig::MultiEntry pkConfigMultiEntry = pkRechargeConfig->GetMultiData();
	CF_RechargeReturnConfig::MultiEntry::Map_iPlatformIDIt configIt =
		pkConfigMultiEntry._iPlatformID.find(iPlatform);
	if (configIt == pkConfigMultiEntry._iPlatformID.end())
	{
		return;
	}
	if (configIt->second->_iOpen <= 0)
	{
		return;
	}
	if (m_kRechargeRecord.m_iLastUpdateTime < configIt->second->_iStartTime ||
		m_kRechargeRecord.m_iLastUpdateTime > configIt->second->_iEndTime)
	{
		return;
	}
	if (configIt->second->_kReturnRates.size() <= 0)
	{
		return;
	}
	int32_t iRate = 0;
	TypeNumList::iterator it = configIt->second->_kReturnRates.begin();
	for (; it != configIt->second->_kReturnRates.end(); ++it)
	{
		if (m_kRechargeRecord.m_iRecharge < it->getType())
		{
			break;
		}
		iRate = it->getNum();
	}
	if (iRate <= 0)
	{
		return;
	}
	double dRate = iRate * 0.0001f;
	int64_t iReturnYB = (int64_t)(m_kRechargeRecord.m_iRecharge * dRate);
	if (iReturnYB <= 0)
	{
		return;
	}

	char buf[256] = {0};
	time_t tt = (time_t)m_kRechargeRecord.m_iLastUpdateTime;
	struct tm t = *localtime(&tt);
	//sprintf(buf, configIt->second->_sMailContent.c_str(), t.tm_mon+1, t.tm_mday, m_kRechargeRecord.m_iRecharge, iReturnYB);
	StringType sMailTitle = configIt->second->_sMailTitle;
	//StringType sMailContent = buf;

	stringstream month;
	month << (t.tm_mon+1);
	
	stringstream day;
	day << (t.tm_mday);

	stringstream charge;
	charge << m_kRechargeRecord.m_iRecharge;

	stringstream yb;
	yb << iReturnYB;

	StringType sMailContent = configIt->second->_sMailContent + ";" + STDSTR2TPSTR(month.str()) + ";" + STDSTR2TPSTR(day.str()) + ";" + STDSTR2TPSTR(charge.str()) + ";" + STDSTR2TPSTR(yb.str())+ ";" ;

	LC_PackEntryFactory* pkPackEntryFactory = LC_PackEntryFactory::GetSingletonPtr();
	if (pkPackEntryFactory)
	{
		LC_BackPackEntryList kEntryList;
		pkPackEntryFactory->CreateItemEntry(SPEC_ITEM_TID_YUANBAO, (int32_t)iReturnYB, CIET_NONE, kEntryList, -1, 0, 0, true);
		UT_ServerHelper::SendToMail(sMailTitle, sMailContent, GetInstance(), GetOwnerCharName(), 0, kEntryList, "3");
	}

	return;
}

void LC_ServerPlayer::DailyRechargeReturnSettle()
{
	uint32_t timestamp = GET_CURRENT_TIMESTAMP_IN_SECONDS();
	if (LC_Helper::CheckIsSameDay(timestamp, m_kRechargeRecord.m_iLastUpdateTime))
	{
		return;
	}
	
	uint16_t platformType = GetPlayerPlatformType();
	SettleRechargeReturn(YYP_NA);
	if (platformType != YYP_NA)
	{
		SettleRechargeReturn(platformType);
	}

	m_kRechargeRecord.m_iLastUpdateTime = timestamp;
	m_kRechargeRecord.m_iRecharge = 0;
}

bool LC_ServerPlayer::CheckAllianceDirty()
{
	static LC_ServerAllianceManager* pkAllianceMgr = LC_ServerAllianceManager::GetSingletonPtr();
	if (NULL == pkAllianceMgr)
	{
		return false;
	}
	if (m_iLastSyncAllianceTime != pkAllianceMgr->GetDirtyTime())
	{
		return true;
	}
	return false;
}

void LC_ServerPlayer::SyncAllianceUnitInfo()
{
	LC_ServerAllianceManager* pkAllianceMgr = LC_ServerAllianceManager::GetSingletonPtr();
	if (NULL == pkAllianceMgr)
	{
		return;
	}
	MG_Resp_Alliance_Unit_Info respMsg;
	pkAllianceMgr->FillAllianceUnitInfo(respMsg);
	SendMsgToClient(MGPT_ALLIANCE_UNIT_INFO_RSP, &respMsg);
	m_iLastSyncAllianceTime = pkAllianceMgr->GetDirtyTime();
}

void LC_ServerPlayer::AddBoneSoul( int skillID )
{
	bool fd = true;
	for(LC_SkillIDVector::iterator ite = m_kBoneSoulSkill.begin(); ite != m_kBoneSoulSkill.end(); ite++)
	{
		if ( *ite == skillID )
		{
			fd = false;
			break;
		}
	}
	if ( fd )	
		m_kBoneSoulSkill.push_back(skillID);
}

int LC_ServerPlayer::GetBoneSoul( int iIndex )
{
	if ( iIndex >= 0 && iIndex < m_kBoneSoulSkill.size() )
	{
		return m_kBoneSoulSkill[iIndex];
	}
	return 0;
}

void LC_ServerPlayer::RemoveBoneSoul( int skillID )
{
	bool fd = false;
	LC_SkillIDVector::iterator ite = m_kBoneSoulSkill.begin(); 
	for( ; ite != m_kBoneSoulSkill.end(); ite++)
	{
		if ( *ite == skillID )
		{
			fd = true;
			break;
		}
	}
	if ( fd )	
		m_kBoneSoulSkill.erase(ite);
}

bool LC_SimPlayerFilter::operator()(GameLogic::LC_PlayerBase* pkPlayer)
{
	static GameServerManager* pkServerMgr = GetGameServerApp()->GetServerManager();
	return pkPlayer
		&& ((INVALID_ACTOR_ID==m_uiActorID) ? true : (IS_ACTOR_FG_SET(m_uiFlag) == (pkPlayer->GetID()==m_uiActorID)))
		&& ((INVALID_GROUP_ID==m_uiGroupID) ? true : (IS_GROUP_FG_SET(m_uiFlag) == (pkPlayer->GetPlayerGroupID()==m_uiGroupID)))
		&& ((INVALID_GUILD_ID==m_iGuildID) ? true : (IS_GUILD_FG_SET(m_uiFlag) == (pkPlayer->GetGuildID()==m_iGuildID)))
		&& ((INVALID_UNION_ID==m_iNationID) ? true : (IS_NATION_FG_SET(m_uiFlag) == pkServerMgr->IsSameServer(m_iNationID, pkPlayer->GetCitizenship())));
}

bool LC_ControllerOnlyPlayerFilter::operator()(GameLogic::LC_PlayerBase* pkPlayer)
{
	return pkPlayer->IsMainController();
}

void LC_ServerPlayer::SetSoloDulePlay( bool bFlag )
{
	m_bSoloDulePlay = bFlag;
	m_bRecoverFromSoloPlay = true;
	SetDenyMove(bFlag);
}

bool LC_ServerPlayer::GetSoloDulePlay()
{
	return m_bSoloDulePlay;
}

void LC_ServerPlayer::ResetSnapshotData()
{
	m_Snapshot.m_nCurrentBuddyIndex = -1;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		m_Snapshot.m_Buddy[i].m_nCurHP = -1;
		m_Snapshot.m_Buddy[i].m_bDead = false;
	}
}

void LC_ServerPlayer::SaveSnapshotData()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return;
	if (!IsMainController())
		return pOwner->SaveSnapshotData();
	// MainController logic here.
	m_Snapshot.m_nCurrentBuddyIndex = m_nCurrentBuddyIndex;
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = pOwner->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		m_Snapshot.m_Buddy[i].m_nCurHP = pResultPlayer->GetHP();
		m_Snapshot.m_Buddy[i].m_bDead = pResultPlayer->GetDead();
	}

	GetMovePath().Clear();
}

void LC_ServerPlayer::LoadSnapshotData()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return;
	if (m_Snapshot.m_nCurrentBuddyIndex < 0)
		return;
	if (!IsMainController())
		return pOwner->LoadSnapshotData();
	// MainController logic here.
	for (int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++)
	{
		LC_ServerPlayer* pResultPlayer = pOwner->GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		
		attr_value_type nHP = pResultPlayer->GetHP();
		bool bDead = pResultPlayer->GetDead();
		attr_value_type nHP_Snapshot = m_Snapshot.m_Buddy[i].m_nCurHP;
		bool bDead_Snapshot = m_Snapshot.m_Buddy[i].m_bDead;
		object_id_type playerid = pResultPlayer->GetID();
		if (bDead == true && bDead_Snapshot == false)
		{
			SetOwnerReliveFlag_Recover(true);
			bool bReliveResult = pResultPlayer->ReliveSelf(RELIVE_NOW, true);
			SetOwnerReliveFlag_Recover(false);
		}
		pResultPlayer->SetHP(m_Snapshot.m_Buddy[i].m_nCurHP);
		pResultPlayer->SetDead(m_Snapshot.m_Buddy[i].m_bDead);
	
	}
	SetCurrentBuddy(m_Snapshot.m_nCurrentBuddyIndex, true);
}

void LC_ServerPlayer::UpdateBuddyAutoRespawnTimer( float fCurrent, float fDelta )
{
	if (!IsMainController())
		return;
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		if ( m_fBuddyAutoRespawnTimer[i] <= 0.00f )
			continue;
		float fOrig = m_fBuddyAutoRespawnTimer[i];
		if ( m_fBuddyRespawnTickCount <= 0.00f  )
			m_fBuddyRespawnTickCount = fCurrent;
		else
		{
			if ( fCurrent - m_fBuddyRespawnTickCount > 0.001f )
			{
				fDelta = fCurrent - m_fBuddyRespawnTickCount;
				m_fBuddyRespawnTickCount = fCurrent;
			}
		}
		m_fBuddyAutoRespawnTimer[i] -= fDelta;
		float fNew = m_fBuddyAutoRespawnTimer[i];
		if ( m_fBuddyAutoRespawnTimer[i] <= 0.00f )
		{
			OnAutoRespawnBuddyByIndex(i);
		}
	}
	m_fBuddyRespawnTickCount = fCurrent;
}

int LC_ServerPlayer::OnAutoRespawnBuddyByIndex( int nIndex )
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return false;
		return pOwner->OnAutoRespawnBuddyByIndex( nIndex );
	}
	float fCurrent = GET_PROCESS_TIME;
	ReliveBuddy( nIndex, true );
	return true;
}

void LC_ServerPlayer::SetBuddyAutoRespawnTimerByIndex(int nIndex)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return ;
		return pOwner->SetBuddyAutoRespawnTimerByIndex( nIndex);
	}
	if ( nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM )
		return;

	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if (pkMapEntry && pkMapEntry->_iRespawnItemNum < 0)
	{
		return;
	}

	if ( m_fBuddyAutoRespawnTimer[nIndex] <= 0.00001f )
		m_fBuddyAutoRespawnTimer[nIndex] = GetGlobalSetting.fAutoRespawnTimer;

	MG_SC_SetBuddyRespawnTimer data;
	data.m_nIndex =  nIndex;
	data.m_fTimer = m_fBuddyAutoRespawnTimer[nIndex];
	SendMsgToClient(MGPT_SC_SET_BUDDY_RESPAWN_TIMER, &data);
}

void LC_ServerPlayer::SetBuddyAutoRespawnTimerById(int nId)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return ;
		return pOwner->SetBuddyAutoRespawnTimerById(nId);
	}
	CF_WorldMapList::DataEntry* pkMapEntry = SafeGetCSVFileDataEntryPtr<CF_WorldMapList>(GetMapResID());
	if (pkMapEntry && pkMapEntry->_iRespawnItemNum < 0)
	{
		return;
	}

	int nIndex = -1;
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		if ( m_ppActivateBuddyTemplateId[i] == nId )
		{
			nIndex = i;
			break;
		}
	}
	
	if (nIndex == -1)
		return;

	if ( m_fBuddyAutoRespawnTimer[nIndex] <= 0.00001f )
		m_fBuddyAutoRespawnTimer[nIndex] = GetGlobalSetting.fAutoRespawnTimer;
	float fCurrent = GET_PROCESS_TIME;
	MG_SC_SetBuddyRespawnTimer data;
	data.m_nIndex =  nIndex;
	data.m_fTimer = m_fBuddyAutoRespawnTimer[nIndex];
	SendMsgToClient(MGPT_SC_SET_BUDDY_RESPAWN_TIMER, &data);
}

void LC_ServerPlayer::ResetBuddyAutoRespawnTimer()
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return ;
		return pOwner->ResetBuddyAutoRespawnTimer();
	}
	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		m_fBuddyAutoRespawnTimer[i] = 0.00f;
	}
	MG_SC_ResetAllBuddyRespawnTimer data;
	SendMsgToClient(MGPT_SC_RESET_ALL_BUDDY_RESPAWN_TIMER, &data);
}

void LC_ServerPlayer::ResetBuddyAutoRespawnTimerByIndex(int nIndex)
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( pOwner == NULL )
			return ;
		return pOwner->ResetBuddyAutoRespawnTimerByIndex(nIndex);
	}
	if (nIndex < 0 || nIndex >= MAX_ACTIVE_BUDDY_NUM)
		return;

	float fCurrent = GET_PROCESS_TIME;
	m_fBuddyAutoRespawnTimer[nIndex] = 0.00f;
	MG_SC_ResetSingleBuddyRespawnTimer data;
	data.m_nIndex = nIndex;
	SendMsgToClient(MGPT_SC_RESET_SINGLE_BUDDY_RESPAWN_TIMER, &data);
}

void LC_ServerPlayer::RefreshLastPVPTime(object_id_type id)
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	IF_A_NA_PLAYER(pOwner) 
		return;
	if (!IsMainController())
		pOwner->RefreshLastPVPTime(id);

	for ( int i = 0; i < MAX_ACTIVE_BUDDY_NUM; i++ )
	{
		LC_ServerPlayer* pResultPlayer = GetActivateBuddyByIndex(i);
		IF_A_NA_PLAYER(pResultPlayer) 
			continue;
		if ( pResultPlayer->GetID() == id )
			return;
	}
	m_fLastPVPTime = GET_PROCESS_TIME;
}

bool LC_ServerPlayer::CheckTripMap_PVPTime()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if ( pOwner == NULL )
		return true;

	if (!IsMainController())
		return pOwner->CheckTripMap_PVPTime();

	float fCurrent = GET_PROCESS_TIME;
	if ( m_fLastPVPTime == 0.00f || fCurrent - m_fLastPVPTime > GetGlobalSetting.fAllowTripMapPVPTime )
		return true;
	return false;
}

bool LC_ServerPlayer::GetDailyFlag()
{
	return m_nDailyFlag;
}

void LC_ServerPlayer::SetDailyFlag(bool flag)
{
	m_nDailyFlag = flag;
}

static uint32_t  find_normal_attack_bullet_cd(uint32_t lSkillTypeID, int32_t iBulletFuncIdx)
{
	CF_BulletCd::DataEntryMapExternIterator kIt = CF_BulletCd::GetSingletonPtr()->GetIterator();
	for(; kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_BulletCd::DataEntry* pkData = kIt.PeekNextValuePtr();
		if (pkData->_nSkillID == lSkillTypeID && pkData->_nBulletFuncIdx == iBulletFuncIdx)
			return pkData->_nCoolDownTime;
	}
	return 0;
}

bool LC_ServerPlayer::ReqBulletShot(MG_REQ_Bullet_Shot & req)
{
	// 校验子弹合法性
	// 发射者
	if (this->GetID() != req.m_lRequesterID)
		return false;

	// 发射技能
	SK_SkillExecute* pkSkillExecute = SK_Factory::GetSingletonPtr()->RequestSkillExcute(req.m_lSkillTypeID);
	if (pkSkillExecute == NULL)
		return false;

	// 子弹索引
	if (req.m_iBulletFuncIdx < 0 || req.m_iBulletFuncIdx >= pkSkillExecute->GetProperty_BulletCount())
		return false;
	if (req.m_iBulletFuncIdx >= 10)
		return false;

	// 子弹散射数
	if (req.m_iScatteringCount <= 0 || req.m_iScatteringCount > MAX_SKILL_BULLET_SCATTERING_COUNT)
		return false;
	if (req.m_iScatteringCount != req.m_fCollidePosParamT.size())
		return false;
	if (req.m_iScatteringCount != req.m_iCollideSurfaceMaterial.size())
		return false;

	// 检查散射碰撞参数[0-1]
	for (unsigned int i = 0; i < req.m_fCollidePosParamT.size(); ++i)
	{
		 float fParamT = UT_MathBase::ClampFloat01(req.m_fCollidePosParamT[i]);
		 req.m_fCollidePosParamT[i] = fParamT;
	}

	// 校验当前技能状态
	// 2020.02.26 -- 李彦君 -- 暂时关闭这个判定，因为做新的开花弹 子弹爆炸的时候人物已经不在技能状态导致子弹无法被认定
	
	// 校验子弹散射数量是否符合当前技能，需配表
	// 校验子弹穿刺次数是否符合当前技能，需配表
	// 校验子弹索引是否符合当前技能，有没有重复发送，需记录字段
	// 校验子弹散射角是否符合当前技能，需配表
	// 校验子弹发射位置是否基本符合当前角色位置
	// 校验子弹发射CD
	Utility::GlobalSettings & gst = GetGlobalSetting;
	if (gst.bNormalAttackBulletCDVerify)
	{
		NormalAttackCD & acd = m_NormalAttackCD;
		if (acd.iSkillID == 0)	// 初始化数据
		{
			// 普攻技能id
			acd.iSkillID = LC_Helper::GetNormalAttackSkill(this) / 1000;
			// 普攻各子弹cd
			for (int i = 0; i < _countof(acd.kBulletFuncIdxCD); ++i)
				acd.kBulletFuncIdxCD[i] = find_normal_attack_bullet_cd(acd.iSkillID, i);
		}
		uint32_t nSkillIDCategory = req.m_lSkillTypeID / 1000;
		if (nSkillIDCategory == acd.iSkillID)
		{
			uint32_t   nCurTick  = GET_INTEGER_TIME32;
			uint32_t & n1stTick  = acd.kBulletFuncIdx1stShotTime[req.m_iBulletFuncIdx];
			uint32_t & nShotCount= acd.kBulletFuncIdxShotCount[req.m_iBulletFuncIdx];
			uint32_t   cBulletCD = acd.kBulletFuncIdxCD[req.m_iBulletFuncIdx];
			if (nCurTick - n1stTick > cBulletCD * 40)	// 重置计时和计数
			{
				n1stTick	= nCurTick;
				nShotCount	= 1;
				acd.nCurCheatCount		= 0;
				acd.nCurCheatProfitTime = 0;
			}
			else
			{
				// 计算平均cd
				uint32_t   nDiff = nCurTick - n1stTick + cBulletCD;	// 多加1个cBulletCD，40次，2.5%的误差容忍
				uint32_t   nAvgCD= nDiff / nShotCount;
				nShotCount++;
				if (nAvgCD * 100 < cBulletCD * gst.nNormalAttackBulletCDTolerance)	// 再加上 1-98% 的误差容忍
				{
					acd.nCurCheatCount++;
					acd.nCurCheatProfitTime += cBulletCD - nAvgCD;
					acd.nAccCheatCount++;
					acd.nAccCheatProfitTime += cBulletCD - nAvgCD;
					return false;
				}
			}
		}
	}

	// 准备调用
	//return true;
	SC_ServerSkillInterface* pkSkillInterface = SC_ServerScriptInterface::GetSingleton().GetSkillInterface();
	bool bRet = pkSkillInterface->ActiveBuddyReqBulletShot(this, req);
	return bRet;
}

int LC_ServerPlayer::GetBornCharType()
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return INVALID_ACTOR_ID;

	if (!IsMainController())
		return pOwner->GetBornCharType();

	return LC_PlayerBase::GetBornCharType();
}

void LC_ServerPlayer::SetBornCharType( int nCharType )
{
	LC_ServerPlayer* pOwner = GetOwnerPlayer();
	if (pOwner == NULL)
		return;

	if (!IsMainController())
		return pOwner->SetBornCharType( nCharType );

	return LC_PlayerBase::SetBornCharType( nCharType );
}
uint64_t LC_ServerPlayer::GetAllBuddyCoreScoreExceptInputID( int32_t nInputBuddyId )
{
	BuddyInstance* pInstance = GetBuddyInstanceByID(nInputBuddyId);
	if ( NULL == pInstance)
		return 0;
	return pInstance->GetBuddyAttrMgr().GetBuddyCombatScoreByType(BCST_BuddyGetCore);
}

void LC_ServerPlayer::SetEnterServerMode( int32_t nValue )
{
	m_nEnterServerMode = nValue;
}

int32_t LC_ServerPlayer::GetEnterServerMode()
{
	return m_nEnterServerMode;
}


void LC_ServerPlayer::Player_AcceptEntrustTask( int32_t _id, std::vector<int32_t>& _vec )
{
	m_EntrustTask.AcceptEntrustTask( this, _id, _vec );
}

void LC_ServerPlayer::Player_SpeedUpEntrustTask( int32_t _index )
{
	m_EntrustTask.SpeedUpEntrustTask( this, _index );
}

void LC_ServerPlayer::Player_GetAwardEntrustTask( std::vector<int32_t>& _vec )
{
	m_EntrustTask.GetAwardEntrustTask( this, _vec );
}

void LC_ServerPlayer::Player_UpdateEntrustTask()
{
	m_EntrustTask.UpdateEntrustTask( this );
}

void LC_ServerPlayer::LotteryDraw( int32_t _id, int _num )
{
	m_Lottery.LotteryDraw( this, _id, _num );
}

void LC_ServerPlayer::LotteryExtraReward( int32_t _id, int _param )
{
	m_Lottery.LotteryExtraReward( this, _id, _param );
}

void LC_ServerPlayer::ChargeProfitReward( int32_t _id, int _param )
{
	m_ChargeProfit.ChargeProfitReward( this,  _id, _param );
}

void LC_ServerPlayer::OnCharge( int32_t cashType, int _value )
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( !pOwner )
			return;
		return pOwner->OnCharge( cashType, _value );
	}

	m_ChargeProfit.ModifyValue( this, cashType, _value, Charge_Type_1 );
}

void LC_ServerPlayer::OnReduce( int32_t cashType, int _value )
{
	if (!IsMainController())
	{
		LC_ServerPlayer* pOwner = GetOwnerPlayer();
		if ( !pOwner )
			return;
		return pOwner->OnReduce( cashType, _value );
	}

	m_ChargeProfit.ModifyValue( this, cashType, _value, Charge_Type_2 );
	m_ChargeProfit.ModifyValue( this, cashType, _value, Charge_Type_3 );
}

void LC_ServerPlayer::ThemeAutoExchage( int _id )
{
	CF_BuddyThemeSecondary::DataEntry* pEntry = SafeGetCSVFileDataEntryPtr<CF_BuddyThemeSecondary>( _id );
	if( !pEntry )
	{
		return;
	}

	if( pEntry->_iType != 6 || UT_ServerHelper::CheckActivityVaild( pEntry->_iScheduleShow ) )
	{
		return; 
	}
	
	if( pEntry->_sParam1.size() != pEntry->_kReward.size() )
	{
		return;
	}

	//兑换奖励
	mem::map<int,int> delMap;	//要删除的道具
	Utility::UT_SIMDataList rewardItem;	//奖励的道具
	for( int i = 0; i < pEntry->_sParam1.size(); ++i )
	{
		int delId = pEntry->_sParam1[i];
		int num = GetPackAsset()->GetItemCountInPack(PACK_TYPE_BASIC, delId );
		if( num != 0 )
		{
			delMap[delId] = num;
			Utility::UT_SIMDataInfo info;
			int id = pEntry->_kReward[i].GetItemId();
			int count = pEntry->_kReward[i].GetItemNum() * num;
			info.SetItemInfo( id, count, 1);
			rewardItem.push_back( info );
		}
	}

	//删除道具
	mem::map<int,int>::iterator it = delMap.begin();
	while( it != delMap.end() )
	{
		DeleteItem( it->first, it->second );
		++it;
	}

	//发送邮件
	if( !rewardItem.empty() )
	{
		UT_ServerHelper::SendToMail("77;", "78;", GetInstance(), GetOwnerCharName(), 0, rewardItem );
	}
}

void LC_ServerPlayer::ThemeFlagChange()
{
	MG_SC_ThemeFlagChange_Ret sendMsg;
	CF_BuddyThemeMain::DataEntryMapExternIterator kIter = CF_BuddyThemeMain::GetSingletonPtr()->GetIterator();
	while( kIter.HasMoreElements() )
	{
		CF_BuddyThemeMain::DataEntry* p = kIter.PeekNextValuePtr();
		if( p && UT_ServerHelper::CheckActivityVaild( p->_iSchedule ) )
		{
			int id = p->_lID;
			mem::map<int,int>::iterator it = m_ThemeStatusMap.find( id );
			if( it != m_ThemeStatusMap.end() )
			{
				if( it->second < 1 )
				{
					m_ThemeStatusMap[id] = 1;
					sendMsg.m_Vec.push_back( id );
				}
			}
			else
			{
				m_ThemeStatusMap[id] = 1;
				sendMsg.m_Vec.push_back( id );
			}
		}
		kIter.MoveNext();
	}

	SendMsgToClient( MGPT_SC_ThemeFlagChange_Ret, &sendMsg );
}

void LC_ServerPlayer::SyncCommandEquip()
{
	MG_SC_SynCommandEquip_Ret sendMsg;
	sendMsg.m_EquipVec.resize( EquipPack_Count );	//使用LC_Define.h中的EquipPack定义

	m_CommandEquipPack.EquipSlotToEquipBase( sendMsg.m_EquipVec[CommandPack-1] );
	m_nCommanderSubEquipPack_Vehicle.EquipSlotToEquipBase(sendMsg.m_EquipVec[MountPack-1]);
	m_nCommanderSubEquipPack_DevaEye.EquipSlotToEquipBase(sendMsg.m_EquipVec[PetPack-1]);
	m_nCommanderSubEquipPack_Muhun.EquipSlotToEquipBase(sendMsg.m_EquipVec[WingPack-1]);
	SendMsgToClient( MGPT_SC_SynCommandEquip_Ret, &sendMsg );
}

void LC_ServerPlayer::EquipCommandEquip( int _index )
{
	m_CommandEquipPack.EquipCommandEquip( this, _index );
}

void LC_ServerPlayer::IntensifyCommandEquip( int _index )
{
	m_CommandEquipPack.IntensifyCommandEquip( this, _index );
}

void LC_ServerPlayer::RefineCommandEquip( int _index )
{
	m_CommandEquipPack.RefineCommandEquip( this, _index );
}

void LC_ServerPlayer::SoulCommandEquip( int _index )
{
	m_CommandEquipPack.SoulCommandEquip( this, _index );
}

void LC_ServerPlayer::ModifyOffsetLocationByIndex(int _nIndex, Utility::UT_Vec3Int& pos, int nFace)
{
	if(_nIndex >= MAX_ACTIVE_BUDDY_NUM )
		return;
	int nValueX = 0;
	int nValueY = 0;
	if(nFace == 0)
	{
		int nOffsetX[MAX_ACTIVE_BUDDY_NUM] = { 0, 1, 0 };
		int nOffsetY[MAX_ACTIVE_BUDDY_NUM] = { 0, 0, -1 };
		nValueX = GetGlobalSetting.nInitPosOffset * nOffsetX[_nIndex] ;
		nValueY = GetGlobalSetting.nInitPosOffset * nOffsetY[_nIndex];

	}
	else if(nFace == 1)
	{
		int nOffsetX[MAX_ACTIVE_BUDDY_NUM] = { 0, -1, 0 };
		int nOffsetY[MAX_ACTIVE_BUDDY_NUM] = { 0, 0, 1 };
		nValueX = GetGlobalSetting.nInitPosOffset * nOffsetX[_nIndex] ;
		nValueY = GetGlobalSetting.nInitPosOffset * nOffsetY[_nIndex];

	}
	
	pos.x += nValueX ;
	pos.y += nValueY;
}

int LC_ServerPlayer::GetSkyArenaGrade(int nGrade, int nScore, int nGradeBits)
{
	CF_SkyArenaRank::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SkyArenaRank>(nGrade);
	if(pkData == NULL)
	{
		return RE_SKYARENA_NO_GRADE_AWARD;
	}
	//if(m_SkyArenaData.nGetGradeAward & (1 << nGrade) )
	//{
	//	return RE_SKYARENA_ALREADY_GET_GRADE_AWARD;
	//}
	if(nScore < pkData->_iScoreNeed)
	{
		return RE_SKYARENA_GRADE_SCORE_LIMIT;
	}
	int uiRslt = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_LevelRewards, this, SYS_FUNC_TP_ARENA_SECTION, pkData->_iID, "", "");
	if (RE_SUCCESS != uiRslt)
	{
		return RE_SKYARENA_GET_GRADE_AWARD;
	}
	m_SkyArenaData.nGetGradeAward = nGradeBits;
	return success;
}

int32_t LC_ServerPlayer::GetSkyArenaChallengeTimes()
{
	return m_SkyArenaData.nDailyChallengTimes;
}
void LC_ServerPlayer::AddSkyArenaChallengeTimes(int nTimes)
{
	m_SkyArenaData.nDailyChallengTimes += nTimes;
}

int32_t LC_ServerPlayer::GetSkyArenaRefreshTimes()
{
	return m_SkyArenaData.nDailyRefreshTimes;
}

void LC_ServerPlayer::SetSkyArenaTopScore(int nTopScore)
{
	m_SkyArenaData.nTopScore += nTopScore;
}

int32_t LC_ServerPlayer::GetSkyArenaTopScore()
{
	return m_SkyArenaData.nTopScore;
}

void LC_ServerPlayer::AddSkyArenaRefreshTimes(int nTimes)
{
	m_SkyArenaData.nDailyRefreshTimes += nTimes;
}

bool LC_ServerPlayer::GetSkyArenaGradeAwardState(int nGrade)
{
	return m_SkyArenaData.nGetGradeAward & (1 << nGrade);
}

void LC_ServerPlayer::SetSkyArenaGradeAwardState(int nGradeBit)
{
	m_SkyArenaData.nGetGradeAward = nGradeBit;
}

void LC_ServerPlayer::AddSkyArenaHonorValue(int nValue)
{
	m_SkyArenaData.nGetHonorValue += nValue;
	NotifySkyArenaGetHonor();
}

int32_t LC_ServerPlayer::GetSkyArenaHonorValue()
{
	return m_SkyArenaData.nGetHonorValue;
}

void LC_ServerPlayer::SetSkyArenaScoreValue(int nValue)
{
	m_SkyArenaData.nNowScore = nValue;
	if(m_SkyArenaData.nNowScore > m_SkyArenaData.nMaxScore)
	{
		SetSkyArenaMaxScoreValue(m_SkyArenaData.nNowScore);
	}
}

int32_t LC_ServerPlayer::GetSkyArenaScoreValue()
{
	return m_SkyArenaData.nNowScore;
}

void LC_ServerPlayer::SetSkyArenaMaxScoreValue(int nValue)
{
	m_SkyArenaData.nMaxScore = nValue;

	AchievementEvent kEvent;
	kEvent.SetNum(GetSkyArenaMaxStage());
	UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SKY_STAGE, kEvent);
}

int32_t LC_ServerPlayer::GetSkyArenaMaxScoreValue()
{
	return m_SkyArenaData.nMaxScore;
}

void LC_ServerPlayer::NotifyRankOpenTime()
{
	MG_NOTIFY_SkyArenaTimeData resp;
	LC_RankManager* rank_Manager = SERVER_GET_RANK_MANAGER();
	rank_Manager->GetRankOpenTime(resp.m_timeData);
	if(resp.m_timeData.nSeasonId != m_SkyArenaData.nSeasonId)
	{
		m_SkyArenaData.Clear(resp.m_timeData.nSeasonId );
	}
	SendMsgToClient(MGPT_SC_NOTIFY_ArenaTimeData,&resp);
	
	MG_NOTIFY_SummitArenaTimeData summitresp;
	rank_Manager->GetSummitArenaOpenTime(summitresp.m_timeData);
	SendMsgToClient(MGPT_NOTIFY_SUMMIT_ARENA_TIME,&summitresp);
}


void LC_ServerPlayer::CheckSkyRankNewSeanson()
{
	MG_NOTIFY_SkyArenaTimeData resp;
	LC_RankManager* rank_Manager = SERVER_GET_RANK_MANAGER();
	rank_Manager->GetRankOpenTime(resp.m_timeData);
	if(resp.m_timeData.nSeasonId != m_SkyArenaData.nSeasonId)
	{
		m_SkyArenaData.Clear(resp.m_timeData.nSeasonId );
	}
}


void LC_ServerPlayer::SetSummitArenaHonorTimes(std::map<int8_t, int32_t>& nHonorTimes)
{
	m_nSummitArenaHonorMaps = nHonorTimes;

	{
		GetAchievementAsset().ResetAchievementByType(LC_ACHIEVEMENT_TYPE_SUMMIT_HONOR);
		std::stringstream logStr;
		AchievementEvent kEvent;
		for(std::map<int8_t, int32_t>::iterator it=m_nSummitArenaHonorMaps.begin(); it!=m_nSummitArenaHonorMaps.end(); ++it)
		{
			logStr << " key:" << it->first << " value:" << it->second;
			for(int8_t i=Top64MatchStartType; i<=it->first; ++i)
			{
				kEvent.SetConditionInfo(i);
				kEvent.SetNum(it->second);
				UpdateAchievementRecord(LC_ACHIEVEMENT_TYPE_SUMMIT_HONOR, kEvent);
			}
		}
		GfxWriteLog(LOG_INFO_FILELINE, LOG_SWITCH_INFO, "LC_ACHIEVEMENT_TYPE_SUMMIT_HONOR %s", logStr.str().c_str());
	}
}

int32_t LC_ServerPlayer::GetSummitArenaHonorTimesByStageType(int nType)
{
	std::map<int8_t, int32_t> ::iterator it = m_nSummitArenaHonorMaps.find(nType);
	if(it != m_nSummitArenaHonorMaps.end())
	{
		return it->second;
	}
	return 0;
}


void LC_ServerPlayer::SkyArenaChallengeResult(bool bSucess, int nGradeId,std::vector<PS_ItemRecord>& nSoloAward, int& nErrorCode)
{
	nSoloAward.clear();
	CF_SkyArenaRank::DataEntry* pkData = SafeGetCSVFileDataEntryPtr<CF_SkyArenaRank>(nGradeId);
	if(pkData == NULL)
	{
		return;
	}
	int uiRslt = -1;
	Utility::UT_SIMDataList addItem;
	if(bSucess)
	{
		addItem = pkData->_SucessMaterial;
		
	}
	else
	{
		addItem = pkData->_ErrMaterial;
		//uiRslt = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, pkData->_ErrMaterial, this, SYS_FUNC_TP_ARENA_SECTION, pkData->_iID, "", "");
	}
	for( Utility::UT_SIMDataList::iterator it = addItem.begin();
		it != addItem.end(); ++it )
	{
		int nCount = (*it).GetItemNum();
		if((*it).GetItemId() == GetGlobalSetting.iSkyArenaHonorItemId)
		{
			if(GetSkyArenaHonorValue() + nCount > pkData->_iMoneyMaxSeason)
			{
				nCount = pkData->_iMoneyMaxSeason - GetSkyArenaHonorValue();
			}

			if(nCount <= 0)
			{
				//AddSkyArenaHonorValue(nCount);
				nErrorCode = RE_SKYARENA_SOLO_HONOR_LIMIT;
			}
		}
		if(nCount > 0)
		{
			PS_ItemRecord data;
			data.m_iItemID = (*it).GetItemId();
			data.m_iItemCount = nCount;
			nSoloAward.push_back(data);
		}
	}
	if (!addItem.empty())
	{
		stringstream sMailTitle;
		/*sMailTitle<<GetGlobalSetting.iPackFullMailTitle;*/
		
		stringstream sMailDesc;
	/*	sMailDesc<<GetGlobalSetting.iPackFullMailDesc;*/
		uiRslt = UT_ServerHelper::HandleBonusItems(PACK_TYPE_UNDEFINE, addItem, this, SYS_FUNC_TP_SkyArenaSoloResult
			, nGradeId, "79;", "80;", true);
	}
	//const unique_id_impl& instance = GetInstance();
	//GfxWriteLog(LOG_ERROR_FILELINE, LOG_SWITCH_ERROR, "SkyArenaChallengeResult Error c_cid:%d, c_citizenship:%d, c_uid:%d, bSucess[%d],nGradeId[%d]", instance.detail(), instance.catagory(), GetUserID(),bSucess , nGradeId);
	return;
}

bool LC_ServerPlayer::LoadSkyArenaData(const ::char_data_define::PBSkyArenaData& data)
{
	m_SkyArenaData.nDailyChallengTimes = data.dailychallengtimes();
	m_SkyArenaData.nDailyRefreshTimes = data.skyarenarefreshtimes();
	m_SkyArenaData.nSeasonId = data.skyarenaseasonid();

	m_SkyArenaData.nGetHonorValue = data.skyarenarehonorvalue();

	return true;
}


bool LC_ServerPlayer::SaveSkyArenaData(::char_data_define::PBSkyArenaData* pkData)
{
	if(NULL == pkData)
	{
		return false;
	}

	pkData->set_dailychallengtimes(m_SkyArenaData.nDailyChallengTimes);
	pkData->set_skyarenarefreshtimes(m_SkyArenaData.nDailyRefreshTimes);
	pkData->set_skyarenaseasonid(m_SkyArenaData.nSeasonId);
	pkData->set_skyarenarehonorvalue(m_SkyArenaData.nGetHonorValue);

	return true;
}


void LC_ServerPlayer::NotifyGroupUserGuildData()
{
	MG_Notify_GG_GS2GROUPChangeGuild notify;
	notify.m_nGuildId = GetGuildID();
	SendMsgToGroup(MGPT_SS_NOTIFY_GS2GROUP_CHANGEGUILD, &notify, GetUserID(), GetInstance());
}


int32_t LC_ServerPlayer::GetSkyArenaGradeLimitPoint()
{
	int32_t scoreValue = GetSkyArenaScoreValue();
	CF_SkyArenaRank::DataEntry* pkData = NULL;
	CF_SkyArenaRank::DataEntryMapExternIterator kIt = CF_SkyArenaRank::GetSingletonPtr()->GetIterator();
	for(; kIt.HasMoreElements(); kIt.MoveNext())
	{
		CF_SkyArenaRank::DataEntry* pkTempData = kIt.PeekNextValuePtr();
		if(scoreValue < pkTempData->_iScoreNeed)
		{
			break;
		}
		pkData = pkTempData;
	}

	if(NULL == pkData)
	{
		return -1;
	}

	return pkData->_iMoneyMaxSeason;
}


bool LC_ServerPlayer::NotifySkyArenaGetHonor()
{
	MG_Notify_SkyArenaGetHonor resp;//
	resp.nAddValue = GetSkyArenaHonorValue();
	return SendMsgToClient(MGPT_NOTIFY_SKYARENA_GETHONOR, &resp);
}


void LC_ServerPlayer::ACTEnd(uint32_t iSchedule)
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->ACTEnd(iSchedule);
	}

	static Activity::ACT_ScheduleDataManager* pkDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	if(pkDataMgr)
	{
		pkDataMgr->ACTScheduleEnd(iSchedule, this);
	}
}

void LC_ServerPlayer::LoginCheckACTEnd()
{
	if(!IsMainController())
	{
		LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
		if(NULL == pkOwnerPlayer)
		{
			return;
		}
		return pkOwnerPlayer->LoginCheckACTEnd();
	}

	static Activity::ACT_ScheduleDataManager* pkDataMgr = Activity::ACT_ScheduleDataManager::GetSingletonPtr();
	if(pkDataMgr)
	{
		pkDataMgr->LoginCheckACTScheduleEnd(this);
	}
}


bool LC_ServerPlayer::LoadAtvChargeRedPointData(const ::char_data_define::PBAtvChargeRedPointInfo& data)
{
	for(int i = 0; i < data.scheduleid_size(); i++)
	{
		m_nChargeScheduleIdRedPoints.push_back(data.scheduleid(i));
	}
	return true;
}


bool LC_ServerPlayer::SaveAtvChargeRedPointData(::char_data_define::PBAtvChargeRedPointInfo* pkData)
{
	if(NULL == pkData)
	{
		return false;
	}
	for(int i = 0; i < m_nChargeScheduleIdRedPoints.size(); i++)
	{
		pkData->add_scheduleid(m_nChargeScheduleIdRedPoints[i]);
	}

	return true;
}

bool LC_ServerPlayer::SetAtvChargeRedPointByScheduleId(uint32_t nScheduleId)
{
	for(int i =0 ; i< m_nChargeScheduleIdRedPoints.size(); i++)
	{
		if(m_nChargeScheduleIdRedPoints[i] == nScheduleId)
		{
			return false;
		}
	}
	m_nChargeScheduleIdRedPoints.push_back(nScheduleId);
	return true;
}

bool LC_ServerPlayer::NotifyAtvChargeRedPoint2Client()
{
	MG_Notify_SetAtvCharge_RedPoint notifyMsg;
	notifyMsg.m_nScheduleIds = m_nChargeScheduleIdRedPoints;
	SendMsgToClient(MGPT_NOTIFY_SET_ATVCHARGE_REDPOINT, &notifyMsg);
	return true;
}


void LC_ServerPlayer::SetActivateSummitArena(int32_t bActivate)
{
	b_ActivateSummitArena = bActivate;
	if(GetActivateSummitArenaState())
	{
		NotifyActivateArena2Client();
	}
}

void LC_ServerPlayer::SetActivateSummitArenaState(bool bActivate)
{
	b_NotifySummitArenaState = bActivate;
}

bool LC_ServerPlayer::GetActivateSummitArenaState()
{
	return b_NotifySummitArenaState;
}

bool LC_ServerPlayer::NotifyActivateArena2Client()
{
	MG_NOTIFY_ActivateSummitArena rltMsg;
	rltMsg.m_nType = Arena_Type_Peak;
	rltMsg.m_Vaild = b_ActivateSummitArena;
	SendMsgToClient(MGPT_SC_NOTIFY_ACTIVATE_SUMMITARENA,  &rltMsg);
	b_ActivateSummitArena = false;
	return true;
}

ResultType LC_ServerPlayer::ClearScheduleData(uint32_t ActType, std::map<uint32_t, GameLogic::LC_IDSet>& rkIndices)
{
	LC_ServerPlayer* pkOwnerPlayer = GetOwnerPlayer();
	if(NULL == pkOwnerPlayer)
	{
		return RE_FAIL;
	}
	Activity::ACT_ScheduleSaveActivity* pkSaveActivity = pkOwnerPlayer->GetACTScheduleAsset().GetScheduleSaveActivity(ActType);
	if (NULL == pkSaveActivity)
	{
		return RE_FAIL;
	}
	for(std::map<uint32_t, GameLogic::LC_IDSet>::iterator it = rkIndices.begin(); it != rkIndices.end(); it++)
	{
		pkSaveActivity->ClearActData(it->first, it->second);
	}
	
	pkSaveActivity->UpdateDirtyFlag();
	pkOwnerPlayer->GetACTScheduleAsset().UpdateDirtyFlag();
	return RE_SUCCESS;
}